/* automatically generated by rust-bindgen 0.72.1 */

#[repr(C)]
#[derive(Copy, Clone, Debug, Default, Eq, Hash, Ord, PartialEq, PartialOrd)]
pub struct __BindgenBitfieldUnit<Storage> {
    storage: Storage,
}
impl<Storage> __BindgenBitfieldUnit<Storage> {
    #[inline]
    pub const fn new(storage: Storage) -> Self {
        Self { storage }
    }
}
impl<Storage> __BindgenBitfieldUnit<Storage>
where
    Storage: AsRef<[u8]> + AsMut<[u8]>,
{
    #[inline]
    fn extract_bit(byte: u8, index: usize) -> bool {
        let bit_index = if cfg!(target_endian = "big") {
            7 - (index % 8)
        } else {
            index % 8
        };
        let mask = 1 << bit_index;
        byte & mask == mask
    }
    #[inline]
    pub fn get_bit(&self, index: usize) -> bool {
        debug_assert!(index / 8 < self.storage.as_ref().len());
        let byte_index = index / 8;
        let byte = self.storage.as_ref()[byte_index];
        Self::extract_bit(byte, index)
    }
    #[inline]
    pub unsafe fn raw_get_bit(this: *const Self, index: usize) -> bool {
        debug_assert!(index / 8 < core::mem::size_of::<Storage>());
        let byte_index = index / 8;
        let byte = unsafe {
            *(core::ptr::addr_of!((*this).storage) as *const u8).offset(byte_index as isize)
        };
        Self::extract_bit(byte, index)
    }
    #[inline]
    fn change_bit(byte: u8, index: usize, val: bool) -> u8 {
        let bit_index = if cfg!(target_endian = "big") {
            7 - (index % 8)
        } else {
            index % 8
        };
        let mask = 1 << bit_index;
        if val { byte | mask } else { byte & !mask }
    }
    #[inline]
    pub fn set_bit(&mut self, index: usize, val: bool) {
        debug_assert!(index / 8 < self.storage.as_ref().len());
        let byte_index = index / 8;
        let byte = &mut self.storage.as_mut()[byte_index];
        *byte = Self::change_bit(*byte, index, val);
    }
    #[inline]
    pub unsafe fn raw_set_bit(this: *mut Self, index: usize, val: bool) {
        debug_assert!(index / 8 < core::mem::size_of::<Storage>());
        let byte_index = index / 8;
        let byte = unsafe {
            (core::ptr::addr_of_mut!((*this).storage) as *mut u8).offset(byte_index as isize)
        };
        unsafe { *byte = Self::change_bit(*byte, index, val) };
    }
    #[inline]
    pub fn get(&self, bit_offset: usize, bit_width: u8) -> u64 {
        debug_assert!(bit_width <= 64);
        debug_assert!(bit_offset / 8 < self.storage.as_ref().len());
        debug_assert!((bit_offset + (bit_width as usize)) / 8 <= self.storage.as_ref().len());
        let mut val = 0;
        for i in 0..(bit_width as usize) {
            if self.get_bit(i + bit_offset) {
                let index = if cfg!(target_endian = "big") {
                    bit_width as usize - 1 - i
                } else {
                    i
                };
                val |= 1 << index;
            }
        }
        val
    }
    #[inline]
    pub unsafe fn raw_get(this: *const Self, bit_offset: usize, bit_width: u8) -> u64 {
        debug_assert!(bit_width <= 64);
        debug_assert!(bit_offset / 8 < core::mem::size_of::<Storage>());
        debug_assert!((bit_offset + (bit_width as usize)) / 8 <= core::mem::size_of::<Storage>());
        let mut val = 0;
        for i in 0..(bit_width as usize) {
            if unsafe { Self::raw_get_bit(this, i + bit_offset) } {
                let index = if cfg!(target_endian = "big") {
                    bit_width as usize - 1 - i
                } else {
                    i
                };
                val |= 1 << index;
            }
        }
        val
    }
    #[inline]
    pub fn set(&mut self, bit_offset: usize, bit_width: u8, val: u64) {
        debug_assert!(bit_width <= 64);
        debug_assert!(bit_offset / 8 < self.storage.as_ref().len());
        debug_assert!((bit_offset + (bit_width as usize)) / 8 <= self.storage.as_ref().len());
        for i in 0..(bit_width as usize) {
            let mask = 1 << i;
            let val_bit_is_set = val & mask == mask;
            let index = if cfg!(target_endian = "big") {
                bit_width as usize - 1 - i
            } else {
                i
            };
            self.set_bit(index + bit_offset, val_bit_is_set);
        }
    }
    #[inline]
    pub unsafe fn raw_set(this: *mut Self, bit_offset: usize, bit_width: u8, val: u64) {
        debug_assert!(bit_width <= 64);
        debug_assert!(bit_offset / 8 < core::mem::size_of::<Storage>());
        debug_assert!((bit_offset + (bit_width as usize)) / 8 <= core::mem::size_of::<Storage>());
        for i in 0..(bit_width as usize) {
            let mask = 1 << i;
            let val_bit_is_set = val & mask == mask;
            let index = if cfg!(target_endian = "big") {
                bit_width as usize - 1 - i
            } else {
                i
            };
            unsafe { Self::raw_set_bit(this, index + bit_offset, val_bit_is_set) };
        }
    }
}
pub type guint8 = ::std::os::raw::c_uchar;
pub type guint16 = ::std::os::raw::c_ushort;
pub type gint32 = ::std::os::raw::c_int;
pub type guint32 = ::std::os::raw::c_uint;
pub type gint64 = ::std::os::raw::c_long;
pub type guint64 = ::std::os::raw::c_ulong;
pub type gsize = ::std::os::raw::c_ulong;
pub type __off_t = ::std::os::raw::c_long;
pub type __off64_t = ::std::os::raw::c_long;
pub type __time_t = ::std::os::raw::c_long;
pub type time_t = __time_t;
#[repr(C)]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub struct tm {
    pub tm_sec: ::std::os::raw::c_int,
    pub tm_min: ::std::os::raw::c_int,
    pub tm_hour: ::std::os::raw::c_int,
    pub tm_mday: ::std::os::raw::c_int,
    pub tm_mon: ::std::os::raw::c_int,
    pub tm_year: ::std::os::raw::c_int,
    pub tm_wday: ::std::os::raw::c_int,
    pub tm_yday: ::std::os::raw::c_int,
    pub tm_isdst: ::std::os::raw::c_int,
    pub tm_gmtoff: ::std::os::raw::c_long,
    pub tm_zone: *const ::std::os::raw::c_char,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of tm"][::std::mem::size_of::<tm>() - 56usize];
    ["Alignment of tm"][::std::mem::align_of::<tm>() - 8usize];
    ["Offset of field: tm::tm_sec"][::std::mem::offset_of!(tm, tm_sec) - 0usize];
    ["Offset of field: tm::tm_min"][::std::mem::offset_of!(tm, tm_min) - 4usize];
    ["Offset of field: tm::tm_hour"][::std::mem::offset_of!(tm, tm_hour) - 8usize];
    ["Offset of field: tm::tm_mday"][::std::mem::offset_of!(tm, tm_mday) - 12usize];
    ["Offset of field: tm::tm_mon"][::std::mem::offset_of!(tm, tm_mon) - 16usize];
    ["Offset of field: tm::tm_year"][::std::mem::offset_of!(tm, tm_year) - 20usize];
    ["Offset of field: tm::tm_wday"][::std::mem::offset_of!(tm, tm_wday) - 24usize];
    ["Offset of field: tm::tm_yday"][::std::mem::offset_of!(tm, tm_yday) - 28usize];
    ["Offset of field: tm::tm_isdst"][::std::mem::offset_of!(tm, tm_isdst) - 32usize];
    ["Offset of field: tm::tm_gmtoff"][::std::mem::offset_of!(tm, tm_gmtoff) - 40usize];
    ["Offset of field: tm::tm_zone"][::std::mem::offset_of!(tm, tm_zone) - 48usize];
};
impl Default for tm {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
pub type gchar = ::std::os::raw::c_char;
pub type glong = ::std::os::raw::c_long;
pub type gint = ::std::os::raw::c_int;
pub type gboolean = gint;
pub type gulong = ::std::os::raw::c_ulong;
pub type guint = ::std::os::raw::c_uint;
pub type gfloat = f32;
pub type gdouble = f64;
pub type gpointer = *mut ::std::os::raw::c_void;
pub type gconstpointer = *const ::std::os::raw::c_void;
pub type GCompareFunc =
    ::std::option::Option<unsafe extern "C" fn(a: gconstpointer, b: gconstpointer) -> gint>;
pub type GCompareDataFunc = ::std::option::Option<
    unsafe extern "C" fn(a: gconstpointer, b: gconstpointer, user_data: gpointer) -> gint,
>;
pub type GDestroyNotify = ::std::option::Option<unsafe extern "C" fn(data: gpointer)>;
pub type GFunc = ::std::option::Option<unsafe extern "C" fn(data: gpointer, user_data: gpointer)>;
#[doc = " GCopyFunc:\n @src: (not nullable): A pointer to the data which should be copied\n @data: Additional data\n\n A function of this signature is used to copy the node data\n when doing a deep-copy of a tree.\n\n Returns: (not nullable): A pointer to the copy\n\n Since: 2.4"]
pub type GCopyFunc =
    ::std::option::Option<unsafe extern "C" fn(src: gconstpointer, data: gpointer) -> gpointer>;
pub type GTimeVal = _GTimeVal;
#[repr(C)]
#[derive(Debug, Default, Copy, Clone, Hash, PartialEq, Eq)]
pub struct _GTimeVal {
    pub tv_sec: glong,
    pub tv_usec: glong,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of _GTimeVal"][::std::mem::size_of::<_GTimeVal>() - 16usize];
    ["Alignment of _GTimeVal"][::std::mem::align_of::<_GTimeVal>() - 8usize];
    ["Offset of field: _GTimeVal::tv_sec"][::std::mem::offset_of!(_GTimeVal, tv_sec) - 0usize];
    ["Offset of field: _GTimeVal::tv_usec"][::std::mem::offset_of!(_GTimeVal, tv_usec) - 8usize];
};
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _GTimeZone {
    _unused: [u8; 0],
}
pub type GTimeZone = _GTimeZone;
#[doc = " GTimeSpan:\n\n A value representing an interval of time, in microseconds.\n\n Since: 2.26"]
pub type GTimeSpan = gint64;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _GDateTime {
    _unused: [u8; 0],
}
#[doc = " GDateTime:\n\n `GDateTime` is a structure that combines a Gregorian date and time\n into a single structure.\n\n `GDateTime` provides many conversion and methods to manipulate dates and times.\n Time precision is provided down to microseconds and the time can range\n (proleptically) from 0001-01-01 00:00:00 to 9999-12-31 23:59:59.999999.\n `GDateTime` follows POSIX time in the sense that it is oblivious to leap\n seconds.\n\n `GDateTime` is an immutable object; once it has been created it cannot\n be modified further. All modifiers will create a new `GDateTime`.\n Nearly all such functions can fail due to the date or time going out\n of range, in which case %NULL will be returned.\n\n `GDateTime` is reference counted: the reference count is increased by calling\n [method@GLib.DateTime.ref] and decreased by calling [method@GLib.DateTime.unref].\n When the reference count drops to 0, the resources allocated by the `GDateTime`\n structure are released.\n\n Many parts of the API may produce non-obvious results. As an\n example, adding two months to January 31st will yield March 31st\n whereas adding one month and then one month again will yield either\n March 28th or March 29th.  Also note that adding 24 hours is not\n always the same as adding one day (since days containing daylight\n savings time transitions are either 23 or 25 hours in length).\n\n Since: 2.26"]
pub type GDateTime = _GDateTime;
unsafe extern "C" {
    pub fn g_date_time_unref(datetime: *mut GDateTime);
}
unsafe extern "C" {
    pub fn g_date_time_ref(datetime: *mut GDateTime) -> *mut GDateTime;
}
unsafe extern "C" {
    pub fn g_date_time_new_now(tz: *mut GTimeZone) -> *mut GDateTime;
}
unsafe extern "C" {
    pub fn g_date_time_new_now_local() -> *mut GDateTime;
}
unsafe extern "C" {
    pub fn g_date_time_new_now_utc() -> *mut GDateTime;
}
unsafe extern "C" {
    pub fn g_date_time_new_from_unix_local(t: gint64) -> *mut GDateTime;
}
unsafe extern "C" {
    pub fn g_date_time_new_from_unix_utc(t: gint64) -> *mut GDateTime;
}
unsafe extern "C" {
    pub fn g_date_time_new_from_unix_local_usec(usecs: gint64) -> *mut GDateTime;
}
unsafe extern "C" {
    pub fn g_date_time_new_from_unix_utc_usec(usecs: gint64) -> *mut GDateTime;
}
unsafe extern "C" {
    pub fn g_date_time_new_from_timeval_local(tv: *const GTimeVal) -> *mut GDateTime;
}
unsafe extern "C" {
    pub fn g_date_time_new_from_timeval_utc(tv: *const GTimeVal) -> *mut GDateTime;
}
unsafe extern "C" {
    pub fn g_date_time_new_from_iso8601(
        text: *const gchar,
        default_tz: *mut GTimeZone,
    ) -> *mut GDateTime;
}
unsafe extern "C" {
    pub fn g_date_time_new(
        tz: *mut GTimeZone,
        year: gint,
        month: gint,
        day: gint,
        hour: gint,
        minute: gint,
        seconds: gdouble,
    ) -> *mut GDateTime;
}
unsafe extern "C" {
    pub fn g_date_time_new_local(
        year: gint,
        month: gint,
        day: gint,
        hour: gint,
        minute: gint,
        seconds: gdouble,
    ) -> *mut GDateTime;
}
unsafe extern "C" {
    pub fn g_date_time_new_utc(
        year: gint,
        month: gint,
        day: gint,
        hour: gint,
        minute: gint,
        seconds: gdouble,
    ) -> *mut GDateTime;
}
unsafe extern "C" {
    pub fn g_date_time_add(datetime: *mut GDateTime, timespan: GTimeSpan) -> *mut GDateTime;
}
unsafe extern "C" {
    pub fn g_date_time_add_years(datetime: *mut GDateTime, years: gint) -> *mut GDateTime;
}
unsafe extern "C" {
    pub fn g_date_time_add_months(datetime: *mut GDateTime, months: gint) -> *mut GDateTime;
}
unsafe extern "C" {
    pub fn g_date_time_add_weeks(datetime: *mut GDateTime, weeks: gint) -> *mut GDateTime;
}
unsafe extern "C" {
    pub fn g_date_time_add_days(datetime: *mut GDateTime, days: gint) -> *mut GDateTime;
}
unsafe extern "C" {
    pub fn g_date_time_add_hours(datetime: *mut GDateTime, hours: gint) -> *mut GDateTime;
}
unsafe extern "C" {
    pub fn g_date_time_add_minutes(datetime: *mut GDateTime, minutes: gint) -> *mut GDateTime;
}
unsafe extern "C" {
    pub fn g_date_time_add_seconds(datetime: *mut GDateTime, seconds: gdouble) -> *mut GDateTime;
}
unsafe extern "C" {
    pub fn g_date_time_add_full(
        datetime: *mut GDateTime,
        years: gint,
        months: gint,
        days: gint,
        hours: gint,
        minutes: gint,
        seconds: gdouble,
    ) -> *mut GDateTime;
}
unsafe extern "C" {
    pub fn g_date_time_compare(dt1: gconstpointer, dt2: gconstpointer) -> gint;
}
unsafe extern "C" {
    pub fn g_date_time_difference(end: *mut GDateTime, begin: *mut GDateTime) -> GTimeSpan;
}
unsafe extern "C" {
    pub fn g_date_time_hash(datetime: gconstpointer) -> guint;
}
unsafe extern "C" {
    pub fn g_date_time_equal(dt1: gconstpointer, dt2: gconstpointer) -> gboolean;
}
unsafe extern "C" {
    pub fn g_date_time_get_ymd(
        datetime: *mut GDateTime,
        year: *mut gint,
        month: *mut gint,
        day: *mut gint,
    );
}
unsafe extern "C" {
    pub fn g_date_time_get_year(datetime: *mut GDateTime) -> gint;
}
unsafe extern "C" {
    pub fn g_date_time_get_month(datetime: *mut GDateTime) -> gint;
}
unsafe extern "C" {
    pub fn g_date_time_get_day_of_month(datetime: *mut GDateTime) -> gint;
}
unsafe extern "C" {
    pub fn g_date_time_get_week_numbering_year(datetime: *mut GDateTime) -> gint;
}
unsafe extern "C" {
    pub fn g_date_time_get_week_of_year(datetime: *mut GDateTime) -> gint;
}
unsafe extern "C" {
    pub fn g_date_time_get_day_of_week(datetime: *mut GDateTime) -> gint;
}
unsafe extern "C" {
    pub fn g_date_time_get_day_of_year(datetime: *mut GDateTime) -> gint;
}
unsafe extern "C" {
    pub fn g_date_time_get_hour(datetime: *mut GDateTime) -> gint;
}
unsafe extern "C" {
    pub fn g_date_time_get_minute(datetime: *mut GDateTime) -> gint;
}
unsafe extern "C" {
    pub fn g_date_time_get_second(datetime: *mut GDateTime) -> gint;
}
unsafe extern "C" {
    pub fn g_date_time_get_microsecond(datetime: *mut GDateTime) -> gint;
}
unsafe extern "C" {
    pub fn g_date_time_get_seconds(datetime: *mut GDateTime) -> gdouble;
}
unsafe extern "C" {
    pub fn g_date_time_to_unix(datetime: *mut GDateTime) -> gint64;
}
unsafe extern "C" {
    pub fn g_date_time_to_unix_usec(datetime: *mut GDateTime) -> gint64;
}
unsafe extern "C" {
    pub fn g_date_time_to_timeval(datetime: *mut GDateTime, tv: *mut GTimeVal) -> gboolean;
}
unsafe extern "C" {
    pub fn g_date_time_get_utc_offset(datetime: *mut GDateTime) -> GTimeSpan;
}
unsafe extern "C" {
    pub fn g_date_time_get_timezone(datetime: *mut GDateTime) -> *mut GTimeZone;
}
unsafe extern "C" {
    pub fn g_date_time_get_timezone_abbreviation(datetime: *mut GDateTime) -> *const gchar;
}
unsafe extern "C" {
    pub fn g_date_time_is_daylight_savings(datetime: *mut GDateTime) -> gboolean;
}
unsafe extern "C" {
    pub fn g_date_time_to_timezone(datetime: *mut GDateTime, tz: *mut GTimeZone) -> *mut GDateTime;
}
unsafe extern "C" {
    pub fn g_date_time_to_local(datetime: *mut GDateTime) -> *mut GDateTime;
}
unsafe extern "C" {
    pub fn g_date_time_to_utc(datetime: *mut GDateTime) -> *mut GDateTime;
}
unsafe extern "C" {
    pub fn g_date_time_format(datetime: *mut GDateTime, format: *const gchar) -> *mut gchar;
}
unsafe extern "C" {
    pub fn g_date_time_format_iso8601(datetime: *mut GDateTime) -> *mut gchar;
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _GData {
    _unused: [u8; 0],
}
pub type GData = _GData;
pub type GTime = gint32;
pub type GDateYear = guint16;
pub type GDateDay = guint8;
pub type GDate = _GDate;
pub const GDateWeekday_G_DATE_BAD_WEEKDAY: GDateWeekday = 0;
pub const GDateWeekday_G_DATE_MONDAY: GDateWeekday = 1;
pub const GDateWeekday_G_DATE_TUESDAY: GDateWeekday = 2;
pub const GDateWeekday_G_DATE_WEDNESDAY: GDateWeekday = 3;
pub const GDateWeekday_G_DATE_THURSDAY: GDateWeekday = 4;
pub const GDateWeekday_G_DATE_FRIDAY: GDateWeekday = 5;
pub const GDateWeekday_G_DATE_SATURDAY: GDateWeekday = 6;
pub const GDateWeekday_G_DATE_SUNDAY: GDateWeekday = 7;
pub type GDateWeekday = ::std::os::raw::c_uint;
pub const GDateMonth_G_DATE_BAD_MONTH: GDateMonth = 0;
pub const GDateMonth_G_DATE_JANUARY: GDateMonth = 1;
pub const GDateMonth_G_DATE_FEBRUARY: GDateMonth = 2;
pub const GDateMonth_G_DATE_MARCH: GDateMonth = 3;
pub const GDateMonth_G_DATE_APRIL: GDateMonth = 4;
pub const GDateMonth_G_DATE_MAY: GDateMonth = 5;
pub const GDateMonth_G_DATE_JUNE: GDateMonth = 6;
pub const GDateMonth_G_DATE_JULY: GDateMonth = 7;
pub const GDateMonth_G_DATE_AUGUST: GDateMonth = 8;
pub const GDateMonth_G_DATE_SEPTEMBER: GDateMonth = 9;
pub const GDateMonth_G_DATE_OCTOBER: GDateMonth = 10;
pub const GDateMonth_G_DATE_NOVEMBER: GDateMonth = 11;
pub const GDateMonth_G_DATE_DECEMBER: GDateMonth = 12;
pub type GDateMonth = ::std::os::raw::c_uint;
#[repr(C)]
#[derive(Debug, Default, Copy, Clone, Hash, PartialEq, Eq)]
pub struct _GDate {
    pub _bitfield_align_1: [u32; 0],
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 8usize]>,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of _GDate"][::std::mem::size_of::<_GDate>() - 8usize];
    ["Alignment of _GDate"][::std::mem::align_of::<_GDate>() - 4usize];
};
impl _GDate {
    #[inline]
    pub fn julian_days(&self) -> guint {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(0usize, 32u8) as u32) }
    }
    #[inline]
    pub fn set_julian_days(&mut self, val: guint) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(0usize, 32u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn julian_days_raw(this: *const Self) -> guint {
        unsafe {
            ::std::mem::transmute(<__BindgenBitfieldUnit<[u8; 8usize]>>::raw_get(
                ::std::ptr::addr_of!((*this)._bitfield_1),
                0usize,
                32u8,
            ) as u32)
        }
    }
    #[inline]
    pub unsafe fn set_julian_days_raw(this: *mut Self, val: guint) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 8usize]>>::raw_set(
                ::std::ptr::addr_of_mut!((*this)._bitfield_1),
                0usize,
                32u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn julian(&self) -> guint {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(32usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_julian(&mut self, val: guint) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(32usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn julian_raw(this: *const Self) -> guint {
        unsafe {
            ::std::mem::transmute(<__BindgenBitfieldUnit<[u8; 8usize]>>::raw_get(
                ::std::ptr::addr_of!((*this)._bitfield_1),
                32usize,
                1u8,
            ) as u32)
        }
    }
    #[inline]
    pub unsafe fn set_julian_raw(this: *mut Self, val: guint) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 8usize]>>::raw_set(
                ::std::ptr::addr_of_mut!((*this)._bitfield_1),
                32usize,
                1u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn dmy(&self) -> guint {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(33usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_dmy(&mut self, val: guint) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(33usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn dmy_raw(this: *const Self) -> guint {
        unsafe {
            ::std::mem::transmute(<__BindgenBitfieldUnit<[u8; 8usize]>>::raw_get(
                ::std::ptr::addr_of!((*this)._bitfield_1),
                33usize,
                1u8,
            ) as u32)
        }
    }
    #[inline]
    pub unsafe fn set_dmy_raw(this: *mut Self, val: guint) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 8usize]>>::raw_set(
                ::std::ptr::addr_of_mut!((*this)._bitfield_1),
                33usize,
                1u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn day(&self) -> guint {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(34usize, 6u8) as u32) }
    }
    #[inline]
    pub fn set_day(&mut self, val: guint) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(34usize, 6u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn day_raw(this: *const Self) -> guint {
        unsafe {
            ::std::mem::transmute(<__BindgenBitfieldUnit<[u8; 8usize]>>::raw_get(
                ::std::ptr::addr_of!((*this)._bitfield_1),
                34usize,
                6u8,
            ) as u32)
        }
    }
    #[inline]
    pub unsafe fn set_day_raw(this: *mut Self, val: guint) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 8usize]>>::raw_set(
                ::std::ptr::addr_of_mut!((*this)._bitfield_1),
                34usize,
                6u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn month(&self) -> guint {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(40usize, 4u8) as u32) }
    }
    #[inline]
    pub fn set_month(&mut self, val: guint) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(40usize, 4u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn month_raw(this: *const Self) -> guint {
        unsafe {
            ::std::mem::transmute(<__BindgenBitfieldUnit<[u8; 8usize]>>::raw_get(
                ::std::ptr::addr_of!((*this)._bitfield_1),
                40usize,
                4u8,
            ) as u32)
        }
    }
    #[inline]
    pub unsafe fn set_month_raw(this: *mut Self, val: guint) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 8usize]>>::raw_set(
                ::std::ptr::addr_of_mut!((*this)._bitfield_1),
                40usize,
                4u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn year(&self) -> guint {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(44usize, 16u8) as u32) }
    }
    #[inline]
    pub fn set_year(&mut self, val: guint) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(44usize, 16u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn year_raw(this: *const Self) -> guint {
        unsafe {
            ::std::mem::transmute(<__BindgenBitfieldUnit<[u8; 8usize]>>::raw_get(
                ::std::ptr::addr_of!((*this)._bitfield_1),
                44usize,
                16u8,
            ) as u32)
        }
    }
    #[inline]
    pub unsafe fn set_year_raw(this: *mut Self, val: guint) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 8usize]>>::raw_set(
                ::std::ptr::addr_of_mut!((*this)._bitfield_1),
                44usize,
                16u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn new_bitfield_1(
        julian_days: guint,
        julian: guint,
        dmy: guint,
        day: guint,
        month: guint,
        year: guint,
    ) -> __BindgenBitfieldUnit<[u8; 8usize]> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 8usize]> = Default::default();
        __bindgen_bitfield_unit.set(0usize, 32u8, {
            let julian_days: u32 = unsafe { ::std::mem::transmute(julian_days) };
            julian_days as u64
        });
        __bindgen_bitfield_unit.set(32usize, 1u8, {
            let julian: u32 = unsafe { ::std::mem::transmute(julian) };
            julian as u64
        });
        __bindgen_bitfield_unit.set(33usize, 1u8, {
            let dmy: u32 = unsafe { ::std::mem::transmute(dmy) };
            dmy as u64
        });
        __bindgen_bitfield_unit.set(34usize, 6u8, {
            let day: u32 = unsafe { ::std::mem::transmute(day) };
            day as u64
        });
        __bindgen_bitfield_unit.set(40usize, 4u8, {
            let month: u32 = unsafe { ::std::mem::transmute(month) };
            month as u64
        });
        __bindgen_bitfield_unit.set(44usize, 16u8, {
            let year: u32 = unsafe { ::std::mem::transmute(year) };
            year as u64
        });
        __bindgen_bitfield_unit
    }
}
unsafe extern "C" {
    pub fn g_date_new() -> *mut GDate;
}
unsafe extern "C" {
    pub fn g_date_new_dmy(day: GDateDay, month: GDateMonth, year: GDateYear) -> *mut GDate;
}
unsafe extern "C" {
    pub fn g_date_new_julian(julian_day: guint32) -> *mut GDate;
}
unsafe extern "C" {
    pub fn g_date_free(date: *mut GDate);
}
unsafe extern "C" {
    pub fn g_date_copy(date: *const GDate) -> *mut GDate;
}
unsafe extern "C" {
    pub fn g_date_valid(date: *const GDate) -> gboolean;
}
unsafe extern "C" {
    pub fn g_date_valid_day(day: GDateDay) -> gboolean;
}
unsafe extern "C" {
    pub fn g_date_valid_month(month: GDateMonth) -> gboolean;
}
unsafe extern "C" {
    pub fn g_date_valid_year(year: GDateYear) -> gboolean;
}
unsafe extern "C" {
    pub fn g_date_valid_weekday(weekday: GDateWeekday) -> gboolean;
}
unsafe extern "C" {
    pub fn g_date_valid_julian(julian_date: guint32) -> gboolean;
}
unsafe extern "C" {
    pub fn g_date_valid_dmy(day: GDateDay, month: GDateMonth, year: GDateYear) -> gboolean;
}
unsafe extern "C" {
    pub fn g_date_get_weekday(date: *const GDate) -> GDateWeekday;
}
unsafe extern "C" {
    pub fn g_date_get_month(date: *const GDate) -> GDateMonth;
}
unsafe extern "C" {
    pub fn g_date_get_year(date: *const GDate) -> GDateYear;
}
unsafe extern "C" {
    pub fn g_date_get_day(date: *const GDate) -> GDateDay;
}
unsafe extern "C" {
    pub fn g_date_get_julian(date: *const GDate) -> guint32;
}
unsafe extern "C" {
    pub fn g_date_get_day_of_year(date: *const GDate) -> guint;
}
unsafe extern "C" {
    pub fn g_date_get_monday_week_of_year(date: *const GDate) -> guint;
}
unsafe extern "C" {
    pub fn g_date_get_sunday_week_of_year(date: *const GDate) -> guint;
}
unsafe extern "C" {
    pub fn g_date_get_iso8601_week_of_year(date: *const GDate) -> guint;
}
unsafe extern "C" {
    pub fn g_date_clear(date: *mut GDate, n_dates: guint);
}
unsafe extern "C" {
    pub fn g_date_set_parse(date: *mut GDate, str_: *const gchar);
}
unsafe extern "C" {
    pub fn g_date_set_time_t(date: *mut GDate, timet: time_t);
}
unsafe extern "C" {
    pub fn g_date_set_time_val(date: *mut GDate, timeval: *mut GTimeVal);
}
unsafe extern "C" {
    pub fn g_date_set_time(date: *mut GDate, time_: GTime);
}
unsafe extern "C" {
    pub fn g_date_set_month(date: *mut GDate, month: GDateMonth);
}
unsafe extern "C" {
    pub fn g_date_set_day(date: *mut GDate, day: GDateDay);
}
unsafe extern "C" {
    pub fn g_date_set_year(date: *mut GDate, year: GDateYear);
}
unsafe extern "C" {
    pub fn g_date_set_dmy(date: *mut GDate, day: GDateDay, month: GDateMonth, y: GDateYear);
}
unsafe extern "C" {
    pub fn g_date_set_julian(date: *mut GDate, julian_date: guint32);
}
unsafe extern "C" {
    pub fn g_date_is_first_of_month(date: *const GDate) -> gboolean;
}
unsafe extern "C" {
    pub fn g_date_is_last_of_month(date: *const GDate) -> gboolean;
}
unsafe extern "C" {
    pub fn g_date_add_days(date: *mut GDate, n_days: guint);
}
unsafe extern "C" {
    pub fn g_date_subtract_days(date: *mut GDate, n_days: guint);
}
unsafe extern "C" {
    pub fn g_date_add_months(date: *mut GDate, n_months: guint);
}
unsafe extern "C" {
    pub fn g_date_subtract_months(date: *mut GDate, n_months: guint);
}
unsafe extern "C" {
    pub fn g_date_add_years(date: *mut GDate, n_years: guint);
}
unsafe extern "C" {
    pub fn g_date_subtract_years(date: *mut GDate, n_years: guint);
}
unsafe extern "C" {
    pub fn g_date_is_leap_year(year: GDateYear) -> gboolean;
}
unsafe extern "C" {
    pub fn g_date_get_days_in_month(month: GDateMonth, year: GDateYear) -> guint8;
}
unsafe extern "C" {
    pub fn g_date_get_monday_weeks_in_year(year: GDateYear) -> guint8;
}
unsafe extern "C" {
    pub fn g_date_get_sunday_weeks_in_year(year: GDateYear) -> guint8;
}
unsafe extern "C" {
    pub fn g_date_days_between(date1: *const GDate, date2: *const GDate) -> gint;
}
unsafe extern "C" {
    pub fn g_date_compare(lhs: *const GDate, rhs: *const GDate) -> gint;
}
unsafe extern "C" {
    pub fn g_date_to_struct_tm(date: *const GDate, tm: *mut tm);
}
unsafe extern "C" {
    pub fn g_date_clamp(date: *mut GDate, min_date: *const GDate, max_date: *const GDate);
}
unsafe extern "C" {
    pub fn g_date_order(date1: *mut GDate, date2: *mut GDate);
}
unsafe extern "C" {
    pub fn g_date_strftime(
        s: *mut gchar,
        slen: gsize,
        format: *const gchar,
        date: *const GDate,
    ) -> gsize;
}
unsafe extern "C" {
    pub fn g_free(mem: gpointer);
}
pub type GList = _GList;
#[repr(C)]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub struct _GList {
    pub data: gpointer,
    pub next: *mut GList,
    pub prev: *mut GList,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of _GList"][::std::mem::size_of::<_GList>() - 24usize];
    ["Alignment of _GList"][::std::mem::align_of::<_GList>() - 8usize];
    ["Offset of field: _GList::data"][::std::mem::offset_of!(_GList, data) - 0usize];
    ["Offset of field: _GList::next"][::std::mem::offset_of!(_GList, next) - 8usize];
    ["Offset of field: _GList::prev"][::std::mem::offset_of!(_GList, prev) - 16usize];
};
impl Default for _GList {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
unsafe extern "C" {
    pub fn g_list_alloc() -> *mut GList;
}
unsafe extern "C" {
    pub fn g_list_free(list: *mut GList);
}
unsafe extern "C" {
    pub fn g_list_free_1(list: *mut GList);
}
unsafe extern "C" {
    pub fn g_list_free_full(list: *mut GList, free_func: GDestroyNotify);
}
unsafe extern "C" {
    pub fn g_list_append(list: *mut GList, data: gpointer) -> *mut GList;
}
unsafe extern "C" {
    pub fn g_list_prepend(list: *mut GList, data: gpointer) -> *mut GList;
}
unsafe extern "C" {
    pub fn g_list_insert(list: *mut GList, data: gpointer, position: gint) -> *mut GList;
}
unsafe extern "C" {
    pub fn g_list_insert_sorted(list: *mut GList, data: gpointer, func: GCompareFunc)
    -> *mut GList;
}
unsafe extern "C" {
    pub fn g_list_insert_sorted_with_data(
        list: *mut GList,
        data: gpointer,
        func: GCompareDataFunc,
        user_data: gpointer,
    ) -> *mut GList;
}
unsafe extern "C" {
    pub fn g_list_insert_before(
        list: *mut GList,
        sibling: *mut GList,
        data: gpointer,
    ) -> *mut GList;
}
unsafe extern "C" {
    pub fn g_list_insert_before_link(
        list: *mut GList,
        sibling: *mut GList,
        link_: *mut GList,
    ) -> *mut GList;
}
unsafe extern "C" {
    pub fn g_list_concat(list1: *mut GList, list2: *mut GList) -> *mut GList;
}
unsafe extern "C" {
    pub fn g_list_remove(list: *mut GList, data: gconstpointer) -> *mut GList;
}
unsafe extern "C" {
    pub fn g_list_remove_all(list: *mut GList, data: gconstpointer) -> *mut GList;
}
unsafe extern "C" {
    pub fn g_list_remove_link(list: *mut GList, llink: *mut GList) -> *mut GList;
}
unsafe extern "C" {
    pub fn g_list_delete_link(list: *mut GList, link_: *mut GList) -> *mut GList;
}
unsafe extern "C" {
    pub fn g_list_reverse(list: *mut GList) -> *mut GList;
}
unsafe extern "C" {
    pub fn g_list_copy(list: *mut GList) -> *mut GList;
}
unsafe extern "C" {
    pub fn g_list_copy_deep(list: *mut GList, func: GCopyFunc, user_data: gpointer) -> *mut GList;
}
unsafe extern "C" {
    pub fn g_list_nth(list: *mut GList, n: guint) -> *mut GList;
}
unsafe extern "C" {
    pub fn g_list_nth_prev(list: *mut GList, n: guint) -> *mut GList;
}
unsafe extern "C" {
    pub fn g_list_find(list: *mut GList, data: gconstpointer) -> *mut GList;
}
unsafe extern "C" {
    pub fn g_list_find_custom(
        list: *mut GList,
        data: gconstpointer,
        func: GCompareFunc,
    ) -> *mut GList;
}
unsafe extern "C" {
    pub fn g_list_position(list: *mut GList, llink: *mut GList) -> gint;
}
unsafe extern "C" {
    pub fn g_list_index(list: *mut GList, data: gconstpointer) -> gint;
}
unsafe extern "C" {
    pub fn g_list_last(list: *mut GList) -> *mut GList;
}
unsafe extern "C" {
    pub fn g_list_first(list: *mut GList) -> *mut GList;
}
unsafe extern "C" {
    pub fn g_list_length(list: *mut GList) -> guint;
}
unsafe extern "C" {
    pub fn g_list_foreach(list: *mut GList, func: GFunc, user_data: gpointer);
}
unsafe extern "C" {
    pub fn g_list_sort(list: *mut GList, compare_func: GCompareFunc) -> *mut GList;
}
unsafe extern "C" {
    pub fn g_list_sort_with_data(
        list: *mut GList,
        compare_func: GCompareDataFunc,
        user_data: gpointer,
    ) -> *mut GList;
}
unsafe extern "C" {
    pub fn g_list_nth_data(list: *mut GList, n: guint) -> gpointer;
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _GHashTable {
    _unused: [u8; 0],
}
pub type GHashTable = _GHashTable;
pub type GSList = _GSList;
#[repr(C)]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub struct _GSList {
    pub data: gpointer,
    pub next: *mut GSList,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of _GSList"][::std::mem::size_of::<_GSList>() - 16usize];
    ["Alignment of _GSList"][::std::mem::align_of::<_GSList>() - 8usize];
    ["Offset of field: _GSList::data"][::std::mem::offset_of!(_GSList, data) - 0usize];
    ["Offset of field: _GSList::next"][::std::mem::offset_of!(_GSList, next) - 8usize];
};
impl Default for _GSList {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
unsafe extern "C" {
    pub fn g_slist_alloc() -> *mut GSList;
}
unsafe extern "C" {
    pub fn g_slist_free(list: *mut GSList);
}
unsafe extern "C" {
    pub fn g_slist_free_1(list: *mut GSList);
}
unsafe extern "C" {
    pub fn g_slist_free_full(list: *mut GSList, free_func: GDestroyNotify);
}
unsafe extern "C" {
    pub fn g_slist_append(list: *mut GSList, data: gpointer) -> *mut GSList;
}
unsafe extern "C" {
    pub fn g_slist_prepend(list: *mut GSList, data: gpointer) -> *mut GSList;
}
unsafe extern "C" {
    pub fn g_slist_insert(list: *mut GSList, data: gpointer, position: gint) -> *mut GSList;
}
unsafe extern "C" {
    pub fn g_slist_insert_sorted(
        list: *mut GSList,
        data: gpointer,
        func: GCompareFunc,
    ) -> *mut GSList;
}
unsafe extern "C" {
    pub fn g_slist_insert_sorted_with_data(
        list: *mut GSList,
        data: gpointer,
        func: GCompareDataFunc,
        user_data: gpointer,
    ) -> *mut GSList;
}
unsafe extern "C" {
    pub fn g_slist_insert_before(
        slist: *mut GSList,
        sibling: *mut GSList,
        data: gpointer,
    ) -> *mut GSList;
}
unsafe extern "C" {
    pub fn g_slist_concat(list1: *mut GSList, list2: *mut GSList) -> *mut GSList;
}
unsafe extern "C" {
    pub fn g_slist_remove(list: *mut GSList, data: gconstpointer) -> *mut GSList;
}
unsafe extern "C" {
    pub fn g_slist_remove_all(list: *mut GSList, data: gconstpointer) -> *mut GSList;
}
unsafe extern "C" {
    pub fn g_slist_remove_link(list: *mut GSList, link_: *mut GSList) -> *mut GSList;
}
unsafe extern "C" {
    pub fn g_slist_delete_link(list: *mut GSList, link_: *mut GSList) -> *mut GSList;
}
unsafe extern "C" {
    pub fn g_slist_reverse(list: *mut GSList) -> *mut GSList;
}
unsafe extern "C" {
    pub fn g_slist_copy(list: *mut GSList) -> *mut GSList;
}
unsafe extern "C" {
    pub fn g_slist_copy_deep(
        list: *mut GSList,
        func: GCopyFunc,
        user_data: gpointer,
    ) -> *mut GSList;
}
unsafe extern "C" {
    pub fn g_slist_nth(list: *mut GSList, n: guint) -> *mut GSList;
}
unsafe extern "C" {
    pub fn g_slist_find(list: *mut GSList, data: gconstpointer) -> *mut GSList;
}
unsafe extern "C" {
    pub fn g_slist_find_custom(
        list: *mut GSList,
        data: gconstpointer,
        func: GCompareFunc,
    ) -> *mut GSList;
}
unsafe extern "C" {
    pub fn g_slist_position(list: *mut GSList, llink: *mut GSList) -> gint;
}
unsafe extern "C" {
    pub fn g_slist_index(list: *mut GSList, data: gconstpointer) -> gint;
}
unsafe extern "C" {
    pub fn g_slist_last(list: *mut GSList) -> *mut GSList;
}
unsafe extern "C" {
    pub fn g_slist_length(list: *mut GSList) -> guint;
}
unsafe extern "C" {
    pub fn g_slist_foreach(list: *mut GSList, func: GFunc, user_data: gpointer);
}
unsafe extern "C" {
    pub fn g_slist_sort(list: *mut GSList, compare_func: GCompareFunc) -> *mut GSList;
}
unsafe extern "C" {
    pub fn g_slist_sort_with_data(
        list: *mut GSList,
        compare_func: GCompareDataFunc,
        user_data: gpointer,
    ) -> *mut GSList;
}
unsafe extern "C" {
    pub fn g_slist_nth_data(list: *mut GSList, n: guint) -> gpointer;
}
#[doc = " gunichar:\n\n A type which can hold any UTF-32 or UCS-4 character code,\n also known as a Unicode code point.\n\n If you want to produce the UTF-8 representation of a #gunichar,\n use g_ucs4_to_utf8(). See also g_utf8_to_ucs4() for the reverse\n process.\n\n To print/scan values of this type as integer, use\n %G_GINT32_MODIFIER and/or %G_GUINT32_FORMAT.\n\n The notation to express a Unicode code point in running text is\n as a hexadecimal number with four to six digits and uppercase\n letters, prefixed by the string \"U+\". Leading zeros are omitted,\n unless the code point would have fewer than four hexadecimal digits.\n For example, \"U+0041 LATIN CAPITAL LETTER A\". To print a code point\n in the U+-notation, use the format string \"U+\\%04\"G_GINT32_FORMAT\"X\".\n To scan, use the format string \"U+\\%06\"G_GINT32_FORMAT\"X\".\n\n |[\n gunichar c;\n sscanf (\"U+0041\", \"U+%06\"G_GINT32_FORMAT\"X\", &amp;c)\n g_print (\"Read U+%04\"G_GINT32_FORMAT\"X\", c);\n ]|"]
pub type gunichar = guint32;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _GAllocator {
    _unused: [u8; 0],
}
pub type GAllocator = _GAllocator;
unsafe extern "C" {
    pub fn g_list_push_allocator(allocator: *mut GAllocator);
}
unsafe extern "C" {
    pub fn g_list_pop_allocator();
}
unsafe extern "C" {
    pub fn g_slist_push_allocator(allocator: *mut GAllocator);
}
unsafe extern "C" {
    pub fn g_slist_pop_allocator();
}
pub type GType = gsize;
#[doc = " GValue:\n\n An opaque structure used to hold different types of values.\n\n The data within the structure has protected scope: it is accessible only\n to functions within a #GTypeValueTable structure, or implementations of\n the g_value_*() API. That is, code portions which implement new fundamental\n types.\n\n #GValue users cannot make any assumptions about how data is stored\n within the 2 element @data union, and the @g_type member should\n only be accessed through the G_VALUE_TYPE() macro."]
pub type GValue = _GValue;
#[doc = " GTypeClass:\n\n An opaque structure used as the base of all classes."]
pub type GTypeClass = _GTypeClass;
#[doc = " GTypeInstance:\n\n An opaque structure used as the base of all type instances."]
pub type GTypeInstance = _GTypeInstance;
#[doc = " GTypeClass:\n\n An opaque structure used as the base of all classes."]
#[repr(C)]
#[derive(Debug, Default, Copy, Clone, Hash, PartialEq, Eq)]
pub struct _GTypeClass {
    pub g_type: GType,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of _GTypeClass"][::std::mem::size_of::<_GTypeClass>() - 8usize];
    ["Alignment of _GTypeClass"][::std::mem::align_of::<_GTypeClass>() - 8usize];
    ["Offset of field: _GTypeClass::g_type"][::std::mem::offset_of!(_GTypeClass, g_type) - 0usize];
};
#[doc = " GTypeInstance:\n\n An opaque structure used as the base of all type instances."]
#[repr(C)]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub struct _GTypeInstance {
    pub g_class: *mut GTypeClass,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of _GTypeInstance"][::std::mem::size_of::<_GTypeInstance>() - 8usize];
    ["Alignment of _GTypeInstance"][::std::mem::align_of::<_GTypeInstance>() - 8usize];
    ["Offset of field: _GTypeInstance::g_class"]
        [::std::mem::offset_of!(_GTypeInstance, g_class) - 0usize];
};
impl Default for _GTypeInstance {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[doc = " GValue:\n\n An opaque structure used to hold different types of values.\n\n The data within the structure has protected scope: it is accessible only\n to functions within a #GTypeValueTable structure, or implementations of\n the g_value_*() API. That is, code portions which implement new fundamental\n types.\n\n #GValue users cannot make any assumptions about how data is stored\n within the 2 element @data union, and the @g_type member should\n only be accessed through the G_VALUE_TYPE() macro."]
#[repr(C)]
#[derive(Copy, Clone)]
pub struct _GValue {
    pub g_type: GType,
    pub data: [_GValue__bindgen_ty_1; 2usize],
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union _GValue__bindgen_ty_1 {
    pub v_int: gint,
    pub v_uint: guint,
    pub v_long: glong,
    pub v_ulong: gulong,
    pub v_int64: gint64,
    pub v_uint64: guint64,
    pub v_float: gfloat,
    pub v_double: gdouble,
    pub v_pointer: gpointer,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of _GValue__bindgen_ty_1"][::std::mem::size_of::<_GValue__bindgen_ty_1>() - 8usize];
    ["Alignment of _GValue__bindgen_ty_1"]
        [::std::mem::align_of::<_GValue__bindgen_ty_1>() - 8usize];
    ["Offset of field: _GValue__bindgen_ty_1::v_int"]
        [::std::mem::offset_of!(_GValue__bindgen_ty_1, v_int) - 0usize];
    ["Offset of field: _GValue__bindgen_ty_1::v_uint"]
        [::std::mem::offset_of!(_GValue__bindgen_ty_1, v_uint) - 0usize];
    ["Offset of field: _GValue__bindgen_ty_1::v_long"]
        [::std::mem::offset_of!(_GValue__bindgen_ty_1, v_long) - 0usize];
    ["Offset of field: _GValue__bindgen_ty_1::v_ulong"]
        [::std::mem::offset_of!(_GValue__bindgen_ty_1, v_ulong) - 0usize];
    ["Offset of field: _GValue__bindgen_ty_1::v_int64"]
        [::std::mem::offset_of!(_GValue__bindgen_ty_1, v_int64) - 0usize];
    ["Offset of field: _GValue__bindgen_ty_1::v_uint64"]
        [::std::mem::offset_of!(_GValue__bindgen_ty_1, v_uint64) - 0usize];
    ["Offset of field: _GValue__bindgen_ty_1::v_float"]
        [::std::mem::offset_of!(_GValue__bindgen_ty_1, v_float) - 0usize];
    ["Offset of field: _GValue__bindgen_ty_1::v_double"]
        [::std::mem::offset_of!(_GValue__bindgen_ty_1, v_double) - 0usize];
    ["Offset of field: _GValue__bindgen_ty_1::v_pointer"]
        [::std::mem::offset_of!(_GValue__bindgen_ty_1, v_pointer) - 0usize];
};
impl Default for _GValue__bindgen_ty_1 {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of _GValue"][::std::mem::size_of::<_GValue>() - 24usize];
    ["Alignment of _GValue"][::std::mem::align_of::<_GValue>() - 8usize];
    ["Offset of field: _GValue::g_type"][::std::mem::offset_of!(_GValue, g_type) - 0usize];
    ["Offset of field: _GValue::data"][::std::mem::offset_of!(_GValue, data) - 8usize];
};
impl Default for _GValue {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
pub const GParamFlags_G_PARAM_READABLE: GParamFlags = 1;
pub const GParamFlags_G_PARAM_WRITABLE: GParamFlags = 2;
pub const GParamFlags_G_PARAM_READWRITE: GParamFlags = 3;
pub const GParamFlags_G_PARAM_CONSTRUCT: GParamFlags = 4;
pub const GParamFlags_G_PARAM_CONSTRUCT_ONLY: GParamFlags = 8;
pub const GParamFlags_G_PARAM_LAX_VALIDATION: GParamFlags = 16;
pub const GParamFlags_G_PARAM_STATIC_NAME: GParamFlags = 32;
pub const GParamFlags_G_PARAM_PRIVATE: GParamFlags = 32;
pub const GParamFlags_G_PARAM_STATIC_NICK: GParamFlags = 64;
pub const GParamFlags_G_PARAM_STATIC_BLURB: GParamFlags = 128;
pub const GParamFlags_G_PARAM_EXPLICIT_NOTIFY: GParamFlags = 1073741824;
pub const GParamFlags_G_PARAM_DEPRECATED: GParamFlags = -2147483648;
#[doc = " GParamFlags:\n @G_PARAM_READABLE: the parameter is readable\n @G_PARAM_WRITABLE: the parameter is writable\n @G_PARAM_READWRITE: alias for %G_PARAM_READABLE | %G_PARAM_WRITABLE\n @G_PARAM_CONSTRUCT: the parameter will be set upon object construction.\n   See [vfunc@Object.constructed] for more details\n @G_PARAM_CONSTRUCT_ONLY: the parameter can only be set upon object construction.\n   See [vfunc@Object.constructed] for more details\n @G_PARAM_LAX_VALIDATION: upon parameter conversion (see g_param_value_convert())\n  strict validation is not required\n @G_PARAM_STATIC_NAME: the string used as name when constructing the\n  parameter is guaranteed to remain valid and\n  unmodified for the lifetime of the parameter.\n  Since 2.8\n @G_PARAM_STATIC_NICK: the string used as nick when constructing the\n  parameter is guaranteed to remain valid and\n  unmmodified for the lifetime of the parameter.\n  Since 2.8\n @G_PARAM_STATIC_BLURB: the string used as blurb when constructing the\n  parameter is guaranteed to remain valid and\n  unmodified for the lifetime of the parameter.\n  Since 2.8\n @G_PARAM_EXPLICIT_NOTIFY: calls to g_object_set_property() for this\n   property will not automatically result in a \"notify\" signal being\n   emitted: the implementation must call g_object_notify() themselves\n   in case the property actually changes.  Since: 2.42.\n @G_PARAM_PRIVATE: internal\n @G_PARAM_DEPRECATED: the parameter is deprecated and will be removed\n  in a future version. A warning will be generated if it is used\n  while running with G_ENABLE_DIAGNOSTIC=1.\n  Since 2.26\n\n Through the #GParamFlags flag values, certain aspects of parameters\n can be configured.\n\n See also: %G_PARAM_STATIC_STRINGS"]
pub type GParamFlags = ::std::os::raw::c_int;
pub type GParamSpec = _GParamSpec;
#[repr(C)]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub struct _GParamSpec {
    pub g_type_instance: GTypeInstance,
    pub name: *const gchar,
    pub flags: GParamFlags,
    pub value_type: GType,
    pub owner_type: GType,
    pub _nick: *mut gchar,
    pub _blurb: *mut gchar,
    pub qdata: *mut GData,
    pub ref_count: guint,
    pub param_id: guint,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of _GParamSpec"][::std::mem::size_of::<_GParamSpec>() - 72usize];
    ["Alignment of _GParamSpec"][::std::mem::align_of::<_GParamSpec>() - 8usize];
    ["Offset of field: _GParamSpec::g_type_instance"]
        [::std::mem::offset_of!(_GParamSpec, g_type_instance) - 0usize];
    ["Offset of field: _GParamSpec::name"][::std::mem::offset_of!(_GParamSpec, name) - 8usize];
    ["Offset of field: _GParamSpec::flags"][::std::mem::offset_of!(_GParamSpec, flags) - 16usize];
    ["Offset of field: _GParamSpec::value_type"]
        [::std::mem::offset_of!(_GParamSpec, value_type) - 24usize];
    ["Offset of field: _GParamSpec::owner_type"]
        [::std::mem::offset_of!(_GParamSpec, owner_type) - 32usize];
    ["Offset of field: _GParamSpec::_nick"][::std::mem::offset_of!(_GParamSpec, _nick) - 40usize];
    ["Offset of field: _GParamSpec::_blurb"][::std::mem::offset_of!(_GParamSpec, _blurb) - 48usize];
    ["Offset of field: _GParamSpec::qdata"][::std::mem::offset_of!(_GParamSpec, qdata) - 56usize];
    ["Offset of field: _GParamSpec::ref_count"]
        [::std::mem::offset_of!(_GParamSpec, ref_count) - 64usize];
    ["Offset of field: _GParamSpec::param_id"]
        [::std::mem::offset_of!(_GParamSpec, param_id) - 68usize];
};
impl Default for _GParamSpec {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
unsafe extern "C" {
    pub fn g_date_get_type() -> GType;
}
unsafe extern "C" {
    pub fn g_date_time_get_type() -> GType;
}
pub type GObject = _GObject;
#[doc = " GObjectClass:\n @g_type_class: the parent class\n @constructor: the @constructor function is called by g_object_new () to\n  complete the object initialization after all the construction properties are\n  set. The first thing a @constructor implementation must do is chain up to the\n  @constructor of the parent class. Overriding @constructor should be rarely\n  needed, e.g. to handle construct properties, or to implement singletons.\n @set_property: the generic setter for all properties of this type. Should be\n  overridden for every type with properties. If implementations of\n  @set_property don't emit property change notification explicitly, this will\n  be done implicitly by the type system. However, if the notify signal is\n  emitted explicitly, the type system will not emit it a second time.\n @get_property: the generic getter for all properties of this type. Should be\n  overridden for every type with properties.\n @dispose: the @dispose function is supposed to drop all references to other\n  objects, but keep the instance otherwise intact, so that client method\n  invocations still work. It may be run multiple times (due to reference\n  loops). Before returning, @dispose should chain up to the @dispose method\n  of the parent class.\n @finalize: instance finalization function, should finish the finalization of\n  the instance begun in @dispose and chain up to the @finalize method of the\n  parent class.\n @dispatch_properties_changed: emits property change notification for a bunch\n  of properties. Overriding @dispatch_properties_changed should be rarely\n  needed.\n @notify: the class closure for the notify signal\n @constructed: the @constructed function is called by g_object_new() as the\n  final step of the object creation process.  At the point of the call, all\n  construction properties have been set on the object.  The purpose of this\n  call is to allow for object initialisation steps that can only be performed\n  after construction properties have been set.  @constructed implementors\n  should chain up to the @constructed call of their parent class to allow it\n  to complete its initialisation.\n\n The class structure for the GObject type.\n\n |[<!-- language=\"C\" -->\n // Example of implementing a singleton using a constructor.\n static MySingleton *the_singleton = NULL;\n\n static GObject*\n my_singleton_constructor (GType                  type,\n                           guint                  n_construct_params,\n                           GObjectConstructParam *construct_params)\n {\n   GObject *object;\n\n   if (!the_singleton)\n     {\n       object = G_OBJECT_CLASS (parent_class)->constructor (type,\n                                                            n_construct_params,\n                                                            construct_params);\n       the_singleton = MY_SINGLETON (object);\n     }\n   else\n     object = g_object_ref (G_OBJECT (the_singleton));\n\n   return object;\n }\n ]|"]
pub type GObjectClass = _GObjectClass;
#[doc = " GObjectConstructParam:\n @pspec: the #GParamSpec of the construct parameter\n @value: the value to set the parameter to\n\n The GObjectConstructParam struct is an auxiliary structure used to hand\n #GParamSpec/#GValue pairs to the @constructor of a #GObjectClass."]
pub type GObjectConstructParam = _GObjectConstructParam;
#[repr(C)]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub struct _GObject {
    pub g_type_instance: GTypeInstance,
    pub ref_count: guint,
    pub qdata: *mut GData,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of _GObject"][::std::mem::size_of::<_GObject>() - 24usize];
    ["Alignment of _GObject"][::std::mem::align_of::<_GObject>() - 8usize];
    ["Offset of field: _GObject::g_type_instance"]
        [::std::mem::offset_of!(_GObject, g_type_instance) - 0usize];
    ["Offset of field: _GObject::ref_count"][::std::mem::offset_of!(_GObject, ref_count) - 8usize];
    ["Offset of field: _GObject::qdata"][::std::mem::offset_of!(_GObject, qdata) - 16usize];
};
impl Default for _GObject {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[doc = " GObjectClass:\n @g_type_class: the parent class\n @constructor: the @constructor function is called by g_object_new () to\n  complete the object initialization after all the construction properties are\n  set. The first thing a @constructor implementation must do is chain up to the\n  @constructor of the parent class. Overriding @constructor should be rarely\n  needed, e.g. to handle construct properties, or to implement singletons.\n @set_property: the generic setter for all properties of this type. Should be\n  overridden for every type with properties. If implementations of\n  @set_property don't emit property change notification explicitly, this will\n  be done implicitly by the type system. However, if the notify signal is\n  emitted explicitly, the type system will not emit it a second time.\n @get_property: the generic getter for all properties of this type. Should be\n  overridden for every type with properties.\n @dispose: the @dispose function is supposed to drop all references to other\n  objects, but keep the instance otherwise intact, so that client method\n  invocations still work. It may be run multiple times (due to reference\n  loops). Before returning, @dispose should chain up to the @dispose method\n  of the parent class.\n @finalize: instance finalization function, should finish the finalization of\n  the instance begun in @dispose and chain up to the @finalize method of the\n  parent class.\n @dispatch_properties_changed: emits property change notification for a bunch\n  of properties. Overriding @dispatch_properties_changed should be rarely\n  needed.\n @notify: the class closure for the notify signal\n @constructed: the @constructed function is called by g_object_new() as the\n  final step of the object creation process.  At the point of the call, all\n  construction properties have been set on the object.  The purpose of this\n  call is to allow for object initialisation steps that can only be performed\n  after construction properties have been set.  @constructed implementors\n  should chain up to the @constructed call of their parent class to allow it\n  to complete its initialisation.\n\n The class structure for the GObject type.\n\n |[<!-- language=\"C\" -->\n // Example of implementing a singleton using a constructor.\n static MySingleton *the_singleton = NULL;\n\n static GObject*\n my_singleton_constructor (GType                  type,\n                           guint                  n_construct_params,\n                           GObjectConstructParam *construct_params)\n {\n   GObject *object;\n\n   if (!the_singleton)\n     {\n       object = G_OBJECT_CLASS (parent_class)->constructor (type,\n                                                            n_construct_params,\n                                                            construct_params);\n       the_singleton = MY_SINGLETON (object);\n     }\n   else\n     object = g_object_ref (G_OBJECT (the_singleton));\n\n   return object;\n }\n ]|"]
#[repr(C)]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub struct _GObjectClass {
    pub g_type_class: GTypeClass,
    pub construct_properties: *mut GSList,
    pub constructor: ::std::option::Option<
        unsafe extern "C" fn(
            type_: GType,
            n_construct_properties: guint,
            construct_properties: *mut GObjectConstructParam,
        ) -> *mut GObject,
    >,
    pub set_property: ::std::option::Option<
        unsafe extern "C" fn(
            object: *mut GObject,
            property_id: guint,
            value: *const GValue,
            pspec: *mut GParamSpec,
        ),
    >,
    pub get_property: ::std::option::Option<
        unsafe extern "C" fn(
            object: *mut GObject,
            property_id: guint,
            value: *mut GValue,
            pspec: *mut GParamSpec,
        ),
    >,
    pub dispose: ::std::option::Option<unsafe extern "C" fn(object: *mut GObject)>,
    pub finalize: ::std::option::Option<unsafe extern "C" fn(object: *mut GObject)>,
    pub dispatch_properties_changed: ::std::option::Option<
        unsafe extern "C" fn(object: *mut GObject, n_pspecs: guint, pspecs: *mut *mut GParamSpec),
    >,
    pub notify:
        ::std::option::Option<unsafe extern "C" fn(object: *mut GObject, pspec: *mut GParamSpec)>,
    pub constructed: ::std::option::Option<unsafe extern "C" fn(object: *mut GObject)>,
    pub flags: gsize,
    pub n_construct_properties: gsize,
    pub pspecs: gpointer,
    pub n_pspecs: gsize,
    pub pdummy: [gpointer; 3usize],
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of _GObjectClass"][::std::mem::size_of::<_GObjectClass>() - 136usize];
    ["Alignment of _GObjectClass"][::std::mem::align_of::<_GObjectClass>() - 8usize];
    ["Offset of field: _GObjectClass::g_type_class"]
        [::std::mem::offset_of!(_GObjectClass, g_type_class) - 0usize];
    ["Offset of field: _GObjectClass::construct_properties"]
        [::std::mem::offset_of!(_GObjectClass, construct_properties) - 8usize];
    ["Offset of field: _GObjectClass::constructor"]
        [::std::mem::offset_of!(_GObjectClass, constructor) - 16usize];
    ["Offset of field: _GObjectClass::set_property"]
        [::std::mem::offset_of!(_GObjectClass, set_property) - 24usize];
    ["Offset of field: _GObjectClass::get_property"]
        [::std::mem::offset_of!(_GObjectClass, get_property) - 32usize];
    ["Offset of field: _GObjectClass::dispose"]
        [::std::mem::offset_of!(_GObjectClass, dispose) - 40usize];
    ["Offset of field: _GObjectClass::finalize"]
        [::std::mem::offset_of!(_GObjectClass, finalize) - 48usize];
    ["Offset of field: _GObjectClass::dispatch_properties_changed"]
        [::std::mem::offset_of!(_GObjectClass, dispatch_properties_changed) - 56usize];
    ["Offset of field: _GObjectClass::notify"]
        [::std::mem::offset_of!(_GObjectClass, notify) - 64usize];
    ["Offset of field: _GObjectClass::constructed"]
        [::std::mem::offset_of!(_GObjectClass, constructed) - 72usize];
    ["Offset of field: _GObjectClass::flags"]
        [::std::mem::offset_of!(_GObjectClass, flags) - 80usize];
    ["Offset of field: _GObjectClass::n_construct_properties"]
        [::std::mem::offset_of!(_GObjectClass, n_construct_properties) - 88usize];
    ["Offset of field: _GObjectClass::pspecs"]
        [::std::mem::offset_of!(_GObjectClass, pspecs) - 96usize];
    ["Offset of field: _GObjectClass::n_pspecs"]
        [::std::mem::offset_of!(_GObjectClass, n_pspecs) - 104usize];
    ["Offset of field: _GObjectClass::pdummy"]
        [::std::mem::offset_of!(_GObjectClass, pdummy) - 112usize];
};
impl Default for _GObjectClass {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[doc = " GObjectConstructParam:\n @pspec: the #GParamSpec of the construct parameter\n @value: the value to set the parameter to\n\n The GObjectConstructParam struct is an auxiliary structure used to hand\n #GParamSpec/#GValue pairs to the @constructor of a #GObjectClass."]
#[repr(C)]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub struct _GObjectConstructParam {
    pub pspec: *mut GParamSpec,
    pub value: *mut GValue,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of _GObjectConstructParam"][::std::mem::size_of::<_GObjectConstructParam>() - 16usize];
    ["Alignment of _GObjectConstructParam"]
        [::std::mem::align_of::<_GObjectConstructParam>() - 8usize];
    ["Offset of field: _GObjectConstructParam::pspec"]
        [::std::mem::offset_of!(_GObjectConstructParam, pspec) - 0usize];
    ["Offset of field: _GObjectConstructParam::value"]
        [::std::mem::offset_of!(_GObjectConstructParam, value) - 8usize];
};
impl Default for _GObjectConstructParam {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[doc = " The type used to store guids in C"]
#[repr(C)]
#[derive(Debug, Default, Copy, Clone, Hash, PartialEq, Eq)]
pub struct _gncGuid {
    pub reserved: [::std::os::raw::c_uchar; 16usize],
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of _gncGuid"][::std::mem::size_of::<_gncGuid>() - 16usize];
    ["Alignment of _gncGuid"][::std::mem::align_of::<_gncGuid>() - 1usize];
    ["Offset of field: _gncGuid::reserved"][::std::mem::offset_of!(_gncGuid, reserved) - 0usize];
};
#[doc = " The type used to store guids in C"]
pub type GncGUID = _gncGuid;
unsafe extern "C" {
    pub fn gnc_guid_get_type() -> GType;
}
unsafe extern "C" {
    pub fn gnc_value_get_guid(value: *const GValue) -> *const GncGUID;
}
unsafe extern "C" {
    #[doc = " Generate a new guid.\n\n  @param guid A pointer to an allocated guid data structure.  The\n  existing value will be replaced with a new value."]
    pub fn guid_replace(guid: *mut GncGUID);
}
unsafe extern "C" {
    #[doc = " Generate a new id.\n\n @return guid A data structure containing a copy of a newly constructed GncGUID."]
    pub fn guid_new_return() -> GncGUID;
}
unsafe extern "C" {
    #[doc = " Returns a GncGUID which is guaranteed to never reference any entity.\n\n Do not free this value! The same pointer is returned on each call."]
    pub fn guid_null() -> *const GncGUID;
}
unsafe extern "C" {
    #[doc = " Allocate memory for a GUID. This does not construct a GUID. In other words,\n the returned pointer has not necessarily been initialized. The returned\n pointer must be freed with * guid_free."]
    pub fn guid_malloc() -> *mut GncGUID;
}
unsafe extern "C" {
    #[doc = " Allocate and construct a new GUID. The returned pointer must be\n released with guid_free."]
    pub fn guid_new() -> *mut GncGUID;
}
unsafe extern "C" {
    pub fn guid_free(guid: *mut GncGUID);
}
unsafe extern "C" {
    #[doc = " Returns a newly allocated GncGUID that matches the passed-in GUID.\n The returned pointer must be freed using guid_free."]
    pub fn guid_copy(guid: *const GncGUID) -> *mut GncGUID;
}
unsafe extern "C" {
    #[doc = " The guid_to_string() routine returns a null-terminated string\n  encoding of the id. String encodings of identifiers are hex\n  numbers printed only with the characters '0' through '9' and\n  'a' through 'f'. The encoding will always be GUID_ENCODING_LENGTH\n  characters long (not including the null terminator).\n\n  @param guid The guid to print.\n\n  @return A pointer to the starting character of the string.  The\n  returned memory is owned by the calling routine and must be freed\n  using g_free."]
    pub fn guid_to_string(guid: *const GncGUID) -> *mut gchar;
}
unsafe extern "C" {
    #[doc = " The guid_to_string_buff() routine puts a null-terminated string\n  encoding of the id into the memory pointed at by buff.  The\n  buffer must be at least GUID_ENCODING_LENGTH+1 characters long.\n  This routine is handy for avoiding a malloc/free cycle.  It\n  returns a pointer to the >>end<< of what was written.  (i.e. it\n  can be used like 'stpcpy' during string concatenation)\n\n  @param guid The guid to print.\n\n  @param buff The buffer to print it into.\n\n  @return A pointer to the terminating null character of the string,\n     or, if no copy took place, NULL."]
    pub fn guid_to_string_buff(guid: *const GncGUID, buff: *mut gchar) -> *mut gchar;
}
unsafe extern "C" {
    #[doc = " Given a string, replace the given guid with the parsed one unless\n the given value is null.\n If null is passed as guid or string, false is returned and nothing\n is done, otherwise, the function returns true.\n This function accepts both uppor and lower case hex digits. If\n letters outside the range of [a-fA-F] are passed, they are silently\n replaced. If non-alphanumeric digits are given, this function will\n either return false or replace those values with others."]
    pub fn string_to_guid(string: *const gchar, guid: *mut GncGUID) -> gboolean;
}
unsafe extern "C" {
    #[doc = " Given two GUIDs, return TRUE if they are non-NULL and equal.\n Return FALSE, otherwise."]
    pub fn guid_equal(guid_1: *const GncGUID, guid_2: *const GncGUID) -> gboolean;
}
unsafe extern "C" {
    pub fn guid_compare(g1: *const GncGUID, g2: *const GncGUID) -> gint;
}
unsafe extern "C" {
    #[doc = " Hash function for a GUID. Given a GncGUID *, hash it to a guint"]
    pub fn guid_hash_to_guint(ptr: gconstpointer) -> guint;
}
unsafe extern "C" {
    #[doc = " Equality function for two GUIDs in a GHashTable."]
    pub fn guid_g_hash_table_equal(guid_a: gconstpointer, guid_b: gconstpointer) -> gint;
}
unsafe extern "C" {
    #[doc = " Returns a GHashTable with <GUID*> as key and a <gpointer> as\n value and no destructor functions for key or value set."]
    pub fn guid_hash_table_new() -> *mut GHashTable;
}
#[repr(C)]
#[derive(Debug, Default, Copy, Clone, Hash, PartialEq, Eq)]
pub struct _gnc_numeric {
    pub num: gint64,
    pub denom: gint64,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of _gnc_numeric"][::std::mem::size_of::<_gnc_numeric>() - 16usize];
    ["Alignment of _gnc_numeric"][::std::mem::align_of::<_gnc_numeric>() - 8usize];
    ["Offset of field: _gnc_numeric::num"][::std::mem::offset_of!(_gnc_numeric, num) - 0usize];
    ["Offset of field: _gnc_numeric::denom"][::std::mem::offset_of!(_gnc_numeric, denom) - 8usize];
};
#[doc = " @brief An rational-number type\n\n This is a rational number, defined by numerator and denominator."]
pub type gnc_numeric = _gnc_numeric;
#[repr(i32)]
#[doc = " Error codes"]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub enum GNCNumericErrorCode {
    #[doc = "< No error"]
    GNC_ERROR_OK = 0,
    #[doc = "< Argument is not a valid number"]
    GNC_ERROR_ARG = -1,
    #[doc = "< Intermediate result overflow"]
    GNC_ERROR_OVERFLOW = -2,
    #[doc = " GNC_HOW_DENOM_FIXED was specified, but argument denominators differed."]
    GNC_ERROR_DENOM_DIFF = -3,
    #[doc = " GNC_HOW_RND_NEVER  was specified, but the result could not be\n  converted to the desired denominator without a remainder."]
    GNC_ERROR_REMAINDER = -4,
}
unsafe extern "C" {
    #[doc = " Convert a floating-point number to a gnc_numeric.\n\n Both 'denom' and 'how' are used as in arithmetic.\n\n \\sa \\ref Arguments\n\n \\param n The double value that is converted into a gnc_numeric\n\n \\param denom The denominator of the gnc_numeric return value. If\n the 'how' argument contains the GNC_HOW_DENOM_SIGFIG flag, this\n value will be ignored.  If GNC_DENOM_AUTO is given an appropriate\n power of ten will be used for the denominator (it may be reduced\n by rounding if appropriate).\n\n \\param how Describes the rounding policy and output\n denominator. Watch out: You must specify a rounding policy such\n as GNC_HOW_RND_NEVER, otherwise the fractional part of the input\n value is silently discarded! Common values for 'how' are\n (GNC_HOW_DENOM_REDUCE|GNC_HOW_RND_NEVER) or\n (GNC_HOW_DENOM_FIXED|GNC_HOW_RND_NEVER).\n\n \\return The newly created gnc_numeric rational value."]
    pub fn double_to_gnc_numeric(n: f64, denom: gint64, how: gint) -> gnc_numeric;
}
unsafe extern "C" {
    #[doc = " Read a gnc_numeric from str, skipping any leading whitespace.\n  Returns the resulting gnc_numeric.\n  Return GNC_ERROR_ARG on error."]
    pub fn gnc_numeric_from_string(str_: *const gchar) -> gnc_numeric;
}
unsafe extern "C" {
    #[doc = " Create a gnc_numeric object that signals the error condition\n  noted by error_code, rather than a number."]
    pub fn gnc_numeric_error(error_code: GNCNumericErrorCode) -> gnc_numeric;
}
unsafe extern "C" {
    #[doc = " Returns a string representation of the given GNCNumericErrorCode."]
    pub fn gnc_numeric_errorCode_to_string(
        error_code: GNCNumericErrorCode,
    ) -> *const ::std::os::raw::c_char;
}
unsafe extern "C" {
    #[doc = " Convert numeric to floating-point value."]
    pub fn gnc_numeric_to_double(n: gnc_numeric) -> gdouble;
}
unsafe extern "C" {
    #[doc = " Convert to string. The returned buffer is to be g_free'd by the\n  caller (it was allocated through g_strdup)"]
    pub fn gnc_numeric_to_string(n: gnc_numeric) -> *mut gchar;
}
unsafe extern "C" {
    #[doc = " Convert to string. Uses a static, non-thread-safe buffer.\n  For internal use only."]
    pub fn gnc_num_dbg_to_string(n: gnc_numeric) -> *mut gchar;
}
unsafe extern "C" {
    #[doc = " @name Comparisons and Predicates\n@{\n/\n/** Check for error signal in value. Returns GNC_ERROR_OK (==0) if\n  the number appears to be valid, otherwise it returns the\n  type of error.  Error values always have a denominator of zero."]
    pub fn gnc_numeric_check(a: gnc_numeric) -> GNCNumericErrorCode;
}
unsafe extern "C" {
    #[doc = " Returns 1 if a>b, -1 if b>a, 0 if a == b"]
    pub fn gnc_numeric_compare(a: gnc_numeric, b: gnc_numeric) -> gint;
}
unsafe extern "C" {
    #[doc = " Returns 1 if the given gnc_numeric is 0 (zero), else returns 0."]
    pub fn gnc_numeric_zero_p(a: gnc_numeric) -> gboolean;
}
unsafe extern "C" {
    #[doc = " Returns 1 if a < 0, otherwise returns 0."]
    pub fn gnc_numeric_negative_p(a: gnc_numeric) -> gboolean;
}
unsafe extern "C" {
    #[doc = " Returns 1 if a > 0, otherwise returns 0."]
    pub fn gnc_numeric_positive_p(a: gnc_numeric) -> gboolean;
}
unsafe extern "C" {
    #[doc = " Equivalence predicate: Returns TRUE (1) if a and b are\n  exactly the same (have the same numerator and denominator)"]
    pub fn gnc_numeric_eq(a: gnc_numeric, b: gnc_numeric) -> gboolean;
}
unsafe extern "C" {
    #[doc = " Equivalence predicate: Returns TRUE (1) if a and b represent\n  the same number.  That is, return TRUE if the ratios, when\n  reduced by eliminating common factors, are identical."]
    pub fn gnc_numeric_equal(a: gnc_numeric, b: gnc_numeric) -> gboolean;
}
unsafe extern "C" {
    #[doc = " Equivalence predicate:\n  Convert both a and b to denom using the\n  specified DENOM and method HOW, and compare numerators\n  the results using gnc_numeric_equal.\n\nFor example, if a == 7/16 and b == 3/4,\ngnc_numeric_same(a, b, 2, GNC_HOW_RND_TRUNC) == 1\nbecause both 7/16 and 3/4 round to 1/2 under truncation. However,\ngnc_numeric_same(a, b, 2, GNC_HOW_RND_ROUND) == 0\nbecause 7/16 rounds to 1/2 under unbiased rounding but 3/4 rounds\nto 2/2."]
    pub fn gnc_numeric_same(a: gnc_numeric, b: gnc_numeric, denom: gint64, how: gint) -> gint;
}
unsafe extern "C" {
    #[doc = " @name Arithmetic Operations\n@{\n/\n/** Return a+b."]
    pub fn gnc_numeric_add(a: gnc_numeric, b: gnc_numeric, denom: gint64, how: gint)
    -> gnc_numeric;
}
unsafe extern "C" {
    #[doc = " Return a-b."]
    pub fn gnc_numeric_sub(a: gnc_numeric, b: gnc_numeric, denom: gint64, how: gint)
    -> gnc_numeric;
}
unsafe extern "C" {
    #[doc = " Multiply a times b, returning the product.  An overflow\n  may occur if the result of the multiplication can't\n  be represented as a ratio of 64-bit int's after removing\n  common factors."]
    pub fn gnc_numeric_mul(a: gnc_numeric, b: gnc_numeric, denom: gint64, how: gint)
    -> gnc_numeric;
}
unsafe extern "C" {
    #[doc = " Division.  Note that division can overflow, in the following\n  sense: if we write x=a/b and y=c/d  then x/y = (a*d)/(b*c)\n  If, after eliminating all common factors between the numerator\n  (a*d) and the denominator (b*c),  then if either the numerator\n  and/or the denominator are *still* greater than 2^63, then\n  the division has overflowed."]
    pub fn gnc_numeric_div(x: gnc_numeric, y: gnc_numeric, denom: gint64, how: gint)
    -> gnc_numeric;
}
unsafe extern "C" {
    #[doc = " Returns a newly created gnc_numeric that is the negative of the\n given gnc_numeric value. For a given gnc_numeric \"a/b\" the returned\n value is \"-a/b\"."]
    pub fn gnc_numeric_neg(a: gnc_numeric) -> gnc_numeric;
}
unsafe extern "C" {
    #[doc = " Returns a newly created gnc_numeric that is the absolute value of\n the given gnc_numeric value. For a given gnc_numeric \"a/b\" the\n returned value is \"|a/b|\"."]
    pub fn gnc_numeric_abs(a: gnc_numeric) -> gnc_numeric;
}
unsafe extern "C" {
    #[doc = " @name Change Denominator\n@{\n/\n/** Change the denominator of a gnc_numeric value to the\n  specified denominator under standard arguments\n  'denom' and 'how'."]
    pub fn gnc_numeric_convert(n: gnc_numeric, denom: gint64, how: gint) -> gnc_numeric;
}
unsafe extern "C" {
    #[doc = " Return input after reducing it by Greater Common Factor (GCF)\n  elimination"]
    pub fn gnc_numeric_reduce(n: gnc_numeric) -> gnc_numeric;
}
unsafe extern "C" {
    #[doc = " Attempt to convert the denominator to an exact power of ten without\n  rounding.\n\n  @param a the ::gnc_numeric value to convert\n\n  @param max_decimal_places the number of decimal places of the\n  converted value. This parameter may be @c NULL.\n\n  @return @c TRUE if @a a has been converted or was already decimal.\n  Otherwise, @c FALSE is returned and @a a and @a max_decimal_places\n  remain unchanged."]
    pub fn gnc_numeric_to_decimal(a: *mut gnc_numeric, max_decimal_places: *mut guint8)
    -> gboolean;
}
unsafe extern "C" {
    #[doc = " Invert a gnc_numeric.\n Much faster than dividing 1 by it.\n @param num The number to be inverted\n @return a gnc_numeric that is the inverse of num"]
    pub fn gnc_numeric_invert(num: gnc_numeric) -> gnc_numeric;
}
unsafe extern "C" {
    #[doc = " @name GValue\n@{"]
    pub fn gnc_numeric_get_type() -> GType;
}
#[doc = " Most systems that are currently maintained, including Microsoft Windows,\n BSD-derived Unixes and Linux, support 64-bit time_t even on 32-bit\n architectures. See https://en.wikipedia.org/wiki/Year_2038_problem\n\n For practical reasons -- as not all have made the transition to 64-bit --\n we define our own 64-bit time type."]
pub type time64 = gint64;
#[repr(C)]
#[derive(Debug, Default, Copy, Clone, Hash, PartialEq, Eq)]
pub struct Time64 {
    pub t: time64,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of Time64"][::std::mem::size_of::<Time64>() - 8usize];
    ["Alignment of Time64"][::std::mem::align_of::<Time64>() - 8usize];
    ["Offset of field: Time64::t"][::std::mem::offset_of!(Time64, t) - 0usize];
};
#[repr(u32)]
#[doc = " Enum for determining a date format"]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub enum QofDateFormat {
    #[doc = "< United states: mm/dd/yyyy"]
    QOF_DATE_FORMAT_US = 0,
    #[doc = "< Britain: dd/mm/yyyy"]
    QOF_DATE_FORMAT_UK = 1,
    #[doc = "< Continental Europe: dd.mm.yyyy"]
    QOF_DATE_FORMAT_CE = 2,
    #[doc = "< ISO: yyyy-mm-dd"]
    QOF_DATE_FORMAT_ISO = 3,
    #[doc = "< Take from locale information"]
    QOF_DATE_FORMAT_LOCALE = 4,
    #[doc = "< UTC: 2004-12-12T23:39:11Z"]
    QOF_DATE_FORMAT_UTC = 5,
    #[doc = "< Used by the check printing code"]
    QOF_DATE_FORMAT_CUSTOM = 6,
    #[doc = "< No Fancy Date Format, use Global"]
    QOF_DATE_FORMAT_UNSET = 7,
}
#[repr(u32)]
#[doc = " Enum for date completion modes (for dates entered without year)"]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub enum QofDateCompletion {
    #[doc = "< use current year"]
    QOF_DATE_COMPLETION_THISYEAR = 0,
    #[doc = "< use sliding 12-month window"]
    QOF_DATE_COMPLETION_SLIDING = 1,
}
pub const GNCDateMonthFormat_GNCDATE_MONTH_NUMBER: GNCDateMonthFormat = 0;
pub const GNCDateMonthFormat_GNCDATE_MONTH_ABBREV: GNCDateMonthFormat = 1;
pub const GNCDateMonthFormat_GNCDATE_MONTH_NAME: GNCDateMonthFormat = 2;
#[doc = " This is how to format the month, as a number, an abbreviated string,\n or the full name."]
pub type GNCDateMonthFormat = ::std::os::raw::c_uint;
unsafe extern "C" {
    #[doc = " \\brief fill out a time struct from a 64-bit time value.\n  \\param secs: Seconds since 00:00:00 UTC 01 January 1970 (negative values\n are seconds before that moment).\n  \\return A struct tm*, allocated on the heap. Must be freed with gnc_tm_free().\n  The time is adjusted for the current local time zone."]
    pub fn gnc_localtime(secs: *const time64) -> *mut tm;
}
unsafe extern "C" {
    #[doc = " \\brief fill out a time struct from a 64-bit time value adjusted for the current time zone.\n  \\param secs: Seconds since 00:00:00 UTC 01 January 1970 (negative values\n are seconds before that moment)\n  \\param time: A struct tm* for the function to fill.\n  The time is adjusted for the current local time zone."]
    pub fn gnc_localtime_r(secs: *const time64, time: *mut tm) -> *mut tm;
}
unsafe extern "C" {
    #[doc = " \\brief fill out a time struct from a 64-bit time value\n  \\param secs: Seconds since 00:00:00 UTC 01 January 1970 (negative values\n are seconds before that moment)\n  \\return A struct tm*, allocated on the heap. Must be freed with gnc_tm_free()\n  The time is UTC."]
    pub fn gnc_gmtime(secs: *const time64) -> *mut tm;
}
unsafe extern "C" {
    #[doc = " \\brief returns an integer corresponding to locale start of week\n  \\return An integer 1=Sunday, 2=Monday etc. If error, return 0."]
    pub fn gnc_start_of_week() -> gint;
}
unsafe extern "C" {
    #[doc = " \\brief calculate seconds from the epoch given a time struct\n  \\param time: A struct tm* containing the date-time information.\n  The time is understood to be in the current local time zone.\n  \\return Seconds since 00:00:00 UTC 01 January 1970 (negative values\n are seconds before that moment)."]
    pub fn gnc_mktime(time: *mut tm) -> time64;
}
unsafe extern "C" {
    #[doc = " \\brief calculate seconds from the epoch given a time struct\n  \\param time: A struct tm* containing the date-time information\n  The time is understood to be utc.\n  \\return Seconds since 00:00:00 UTC 01 January 1970 (negative values\n are seconds before that moment)."]
    pub fn gnc_timegm(time: *mut tm) -> time64;
}
unsafe extern "C" {
    #[doc = " \\brief Return a string representation of a date from a 64-bit time value\n  \\param secs: Seconds since 00:00:00 UTC 01 January 1970 (negative values\n are seconds before that moment)\n \\return A string, which must be freed with g_free(), representing the date\n in the following format:\n       Thu Nov 24 18:22:48 1986\\n\\0\n This is equivalent to the strftime format %a %b %H:%M:%S %Y."]
    pub fn gnc_ctime(secs: *const time64) -> *mut gchar;
}
unsafe extern "C" {
    #[doc = " \\brief get the current time\n  \\param A time64* which, if not NULL, will be filled in with the same\n value as is returned.\n \\return Seconds since 00:00:00 UTC 01 January 1970 (negative values\n are seconds before that moment)"]
    pub fn gnc_time(tbuf: *mut time64) -> time64;
}
unsafe extern "C" {
    #[doc = " \\brief Find the difference in seconds between two time values\n         (deprecated)\n  \\param secs1: The first time value, in Seconds since\n 00:00:00 UTC 01 January 1970 (negative values are seconds before that moment)\n  \\param secs2: The second time value, in Seconds since\n 00:00:00 UTC 01 January 1970 (negative values are seconds before that moment)\n  \\return The difference in seconds between secs1 and secs2. If secs2 is\n later than secs1 the value will be negative."]
    pub fn gnc_difftime(secs1: time64, secs2: time64) -> gdouble;
}
unsafe extern "C" {
    #[doc = " \\brief free a struct tm* created with gnc_localtime() or gnc_gmtime()\n \\param time: The struct tm* to be freed."]
    pub fn gnc_tm_free(time: *mut tm);
}
unsafe extern "C" {
    #[doc = " \\brief The string->value versions return FALSE on success and TRUE on failure"]
    pub fn gnc_date_dateformat_to_string(format: QofDateFormat) -> *const gchar;
}
unsafe extern "C" {
    #[doc = " \\brief Converts the date format to a printable string.\n\nNote the reversed return values!\n@return FALSE on success, TRUE on failure."]
    pub fn gnc_date_string_to_dateformat(
        format_string: *const gchar,
        format: *mut QofDateFormat,
    ) -> gboolean;
}
unsafe extern "C" {
    pub fn gnc_date_monthformat_to_string(format: GNCDateMonthFormat) -> *const gchar;
}
unsafe extern "C" {
    #[doc = " \\brief Converts the month format to a printable string.\n\nNote the reversed return values!\n@return FALSE on success, TRUE on failure."]
    pub fn gnc_date_string_to_monthformat(
        format_string: *const gchar,
        format: *mut GNCDateMonthFormat,
    ) -> gboolean;
}
unsafe extern "C" {
    #[doc = " \\brief print a time64 as a date string per format\n \\param time The time64 to print\n \\param format A date format conforming to the strftime format rules.\n \\return a raw heap-allocated char* which must be freed."]
    pub fn gnc_print_time64(
        time: time64,
        format: *const ::std::os::raw::c_char,
    ) -> *mut ::std::os::raw::c_char;
}
unsafe extern "C" {
    #[doc = " @name GDate time64 setters\n    @{ */\n/** Returns a newly allocated date of the current clock time, taken from\n time(2). The caller must g_date_free() the object afterwards."]
    pub fn gnc_g_date_new_today() -> *mut GDate;
}
unsafe extern "C" {
    #[doc = " Set a GDate to the current day\n @param gd The date to act on"]
    pub fn gnc_gdate_set_today(gd: *mut GDate);
}
unsafe extern "C" {
    #[doc = " Set a GDate to a time64\n @param gd the date to act on\n @param time the time to set it to."]
    pub fn gnc_gdate_set_time64(gd: *mut GDate, time: time64);
}
unsafe extern "C" {
    #[doc = " Turns a GDate into a time64, returning the first second of the day"]
    pub fn gdate_to_time64(d: GDate) -> time64;
}
unsafe extern "C" {
    #[doc = " Convert a day, month, and year to a time64, returning the first second of the day"]
    pub fn gnc_dmy2time64(day: gint, month: gint, year: gint) -> time64;
}
unsafe extern "C" {
    #[doc = " Converts a day, month, and year to a time64 representing 11:00:00 UTC\n  11:00:00 UTC falls on the same time in almost all timezones, the exceptions\n  being the +13, +14, and -12 timezones used by countries along the\n  International Date Line. Since users in those timezones would see dates\n  immediately change by one day, the function checks the current timezone for\n  those changes and adjusts the UTC time so that the date will be consistent."]
    pub fn gnc_dmy2time64_neutral(day: gint, month: gint, year: gint) -> time64;
}
unsafe extern "C" {
    #[doc = " Same as gnc_dmy2time64, but last second of the day"]
    pub fn gnc_dmy2time64_end(day: gint, month: gint, year: gint) -> time64;
}
unsafe extern "C" {
    #[doc = " The gnc_iso8601_to_time64_gmt() routine converts an ISO-8601 style\n    date/time string to time64.  Please note that ISO-8601 strings\n    are a representation of Universal Time (UTC), and as such, they\n    'store' UTC.  To make them human readable, they show time zone\n    information along with a local-time string.  But fundamentally,\n    they *are* UTC.  Thus, this routine takes a UTC input, and\n    returns a UTC output.\n\n    For example: 1998-07-17 11:00:00.68-0500\n    is 680 milliseconds after 11 o'clock, central daylight time\n    It is also 680 milliseconds after 16:00:00 hours UTC.\n    \\return The universal time.\n\n XXX Caution: this routine does not handle strings that specify\n times before January 1 1970."]
    pub fn gnc_iso8601_to_time64_gmt(arg1: *const gchar) -> time64;
}
unsafe extern "C" {
    #[doc = " The gnc_time64_to_iso8601_buff() routine takes the input\n    UTC time64 value and prints it as an ISO-8601 style string.\n    The buffer must be long enough to contain the NULL-terminated\n    string (32 characters + NUL).  This routine returns a pointer\n    to the null terminator (and can thus be used in the 'stpcpy'\n    metaphor of string concatenation).\n\n    Please note that ISO-8601 strings are a representation of\n    Universal Time (UTC), and as such, they 'store' UTC.  To make them\n    human readable, they show time zone information along with a\n    local-time string.  But fundamentally, they *are* UTC.  Thus,\n    this routine takes a UTC input, and returns a UTC output.\n\n    The string generated by this routine uses the local time zone\n    on the machine on which it is executing to create the time string."]
    pub fn gnc_time64_to_iso8601_buff(
        arg1: time64,
        buff: *mut ::std::os::raw::c_char,
    ) -> *mut gchar;
}
unsafe extern "C" {
    #[doc = " The qof_date_format_get routine returns the date format that\n  the date printing will use when printing a date, and the scanning\n  routines will assume when parsing a date.\n @returns: the one of the enumerated date formats."]
    pub fn qof_date_format_get() -> QofDateFormat;
}
unsafe extern "C" {
    #[doc = " The qof_date_format_set() routine sets date format to one of\n    US, UK, CE, OR ISO.  Checks to make sure it's a legal value.\n    Args: QofDateFormat: enumeration indicating preferred format"]
    pub fn qof_date_format_set(df: QofDateFormat);
}
unsafe extern "C" {
    #[doc = " This function returns a strftime formatting string for printing an\n  all numeric date (e.g. 2005-09-14).  The string returned is based\n  upon the location specified.\n\n  @param df The date style (us, uk, iso, etc) that should be provided.\n\n  @return A formatting string that will print a date in the\n  requested style"]
    pub fn qof_date_format_get_string(df: QofDateFormat) -> *const gchar;
}
unsafe extern "C" {
    #[doc = " This function returns a strftime formatting string for printing a\n  date using words and numbers (e.g. 2005-September-14).  The string\n  returned is based upon the location specified.\n\n  @param df The date style (us, uk, iso, etc) that should be provided.\n\n  @return A formatting string that will print a date in the\n  requested style"]
    pub fn qof_date_text_format_get_string(df: QofDateFormat) -> *const gchar;
}
unsafe extern "C" {
    #[doc = " The qof_date_completion_set() routing sets the date completion method to\n    one of QOF_DATE_COMPLETION_THISYEAR (for completing the year to\n    the current calendar year) or QOF_DATE_COMPLETION_SLIDING (for\n    using a sliding 12-month window). The sliding window starts\n    'backmonth' months before the current month (0-11)"]
    pub fn qof_date_completion_set(dc: QofDateCompletion, backmonths: ::std::os::raw::c_int);
}
unsafe extern "C" {
    #[doc = " qof_strftime calls qof_format_time to print a given time and afterwards tries\n  to put the result into a buffer of fixed size.\n\n  @param buf A buffer.\n\n  @param max The size of buf in bytes.\n\n  @param format A format specification in UTF-8.\n\n  @param tm A broken-down time.\n\n  @return The number of characters written, not include the null byte, if the\n  complete string, including the null byte, fits into the buffer.  Otherwise 0."]
    pub fn qof_strftime(buf: *mut gchar, max: gsize, format: *const gchar, tm: *const tm) -> gsize;
}
unsafe extern "C" {
    #[doc = " qof_print_date_dmy_buff\n    Convert a date as day / month / year integers into a localized string\n    representation\n\n Args:   buff - pointer to previously allocated character array; its size\n                must be at lease MAX_DATE_LENTH bytes.\n         len - length of the buffer, in bytes.\n         day - day of the month as 1 ... 31\n         month - month of the year as 1 ... 12\n         year - year (4-digit)\n\n Returns: number of characters printed\n\n Globals: global dateFormat value"]
    pub fn qof_print_date_dmy_buff(
        buff: *mut gchar,
        buflen: usize,
        day: ::std::os::raw::c_int,
        month: ::std::os::raw::c_int,
        year: ::std::os::raw::c_int,
    ) -> usize;
}
unsafe extern "C" {
    #[doc = " Convenience: calls through to qof_print_date_dmy_buff()."]
    pub fn qof_print_date_buff(
        buff: *mut ::std::os::raw::c_char,
        buflen: usize,
        secs: time64,
    ) -> usize;
}
unsafe extern "C" {
    #[doc = " Convenience; calls through to qof_print_date_dmy_buff()."]
    pub fn qof_print_gdate(
        buf: *mut ::std::os::raw::c_char,
        bufflen: usize,
        gd: *const GDate,
    ) -> usize;
}
unsafe extern "C" {
    #[doc = " Convenience; calls through to qof_print_date_dmy_buff().\n  Return: string, which should be freed when no longer needed."]
    pub fn qof_print_date(secs: time64) -> *mut ::std::os::raw::c_char;
}
unsafe extern "C" {
    #[doc = "    Returns the number of bytes printed."]
    pub fn qof_print_date_time_buff(
        buff: *mut ::std::os::raw::c_char,
        len: usize,
        secs: time64,
    ) -> usize;
}
unsafe extern "C" {
    #[doc = " qof_scan_date\n    Convert a string into  day / month / year integers according to\n    the current dateFormat value.\n\n Args:   buff - pointer to date string\n         day -  will store day of the month as 1 ... 31\n         month - will store month of the year as 1 ... 12\n         year - will store the year (4-digit)\n\n Return: TRUE if the string seemed to be a valid date; else FALSE.\n\n Globals: uses global dateFormat value to assist in parsing."]
    pub fn qof_scan_date(
        buff: *const ::std::os::raw::c_char,
        day: *mut ::std::os::raw::c_int,
        month: *mut ::std::os::raw::c_int,
        year: *mut ::std::os::raw::c_int,
    ) -> gboolean;
}
unsafe extern "C" {
    #[doc = " The gnc_tm_set_day_neutral() inline routine will set the appropriate\n  fields in the struct tm to indicate 10:59am of that day."]
    pub fn gnc_tm_set_day_neutral(tm: *mut tm);
}
unsafe extern "C" {
    #[doc = " The gnc_time64_get_day_start() routine will take the given time in\n  seconds and adjust it to the first second of that day."]
    pub fn gnc_time64_get_day_start(time_val: time64) -> time64;
}
unsafe extern "C" {
    #[doc = " The gnc_time64_get_day_neutral() routine will take the given time in\n  seconds and adjust it to 10:59:00Z of that day."]
    pub fn gnc_time64_get_day_neutral(time_val: time64) -> time64;
}
unsafe extern "C" {
    #[doc = " The gnc_time64_get_day_end() routine will take the given time in\n  seconds and adjust it to the last second of that day."]
    pub fn gnc_time64_get_day_end(time_val: time64) -> time64;
}
unsafe extern "C" {
    #[doc = " Get the numerical last date of the month. (28, 29, 30, 31)"]
    pub fn gnc_date_get_last_mday(
        month: ::std::os::raw::c_int,
        year: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    #[doc = " The gnc_tm_get_today_start() routine takes a pointer to a struct\n  tm and fills it in with the first second of the today."]
    pub fn gnc_tm_get_today_start(tm: *mut tm);
}
unsafe extern "C" {
    #[doc = " The gnc_tm_get_today_start() routine takes a pointer to a struct\n  tm and fills it in with the timezone neutral time (10:59:00Z)."]
    pub fn gnc_tm_get_today_neutral(tm: *mut tm);
}
unsafe extern "C" {
    #[doc = " The gnc_tm_get_today_end() routine takes a pointer to a struct\n  tm and fills it in with the last second of the today."]
    pub fn gnc_tm_get_today_end(tm: *mut tm);
}
unsafe extern "C" {
    #[doc = " The gnc_time64_get_today_start() routine returns a time64 value\n  corresponding to the first second of today."]
    pub fn gnc_time64_get_today_start() -> time64;
}
unsafe extern "C" {
    #[doc = " The gnc_time64_get_today_end() routine returns a time64 value\n  corresponding to the last second of today."]
    pub fn gnc_time64_get_today_end() -> time64;
}
unsafe extern "C" {
    #[doc = " \\brief Make a timestamp in YYYYMMDDHHMMSS format.\n  @return A pointer to the generated string.\n  @note The caller owns this buffer and must g_free it when done."]
    pub fn gnc_date_timestamp() -> *mut ::std::os::raw::c_char;
}
unsafe extern "C" {
    #[doc = " Localized DOW abbreviation.\n @param buf_len at least MIN_BUF_LEN\n @param dow struct tm semantics: 0=sunday .. 6=saturday"]
    pub fn gnc_dow_abbrev(
        buf: *mut gchar,
        buf_len: ::std::os::raw::c_int,
        dow: ::std::os::raw::c_int,
    );
}
unsafe extern "C" {
    #[doc = " Compares two GDate*'s for equality; useful for using GDate*'s as\n  GHashTable keys."]
    pub fn gnc_gdate_equal(gda: gconstpointer, gdb: gconstpointer) -> gint;
}
unsafe extern "C" {
    #[doc = " Provides a \"hash\" of a GDate* value; useful for using GDate*'s as\n  GHashTable keys."]
    pub fn gnc_gdate_hash(gd: gconstpointer) -> guint;
}
unsafe extern "C" {
    #[doc = " Returns the GDate in which the time64 occurs.\n @param t The time64\n @returns A GDate for the day in which the time64 occurs."]
    pub fn time64_to_gdate(t: time64) -> GDate;
}
unsafe extern "C" {
    #[doc = " The gnc_time64_get_day_start() routine will take the given time in\n  GLib GDate format and adjust it to the first second of that day."]
    pub fn gnc_time64_get_day_start_gdate(date: *const GDate) -> time64;
}
unsafe extern "C" {
    #[doc = " The gnc_time64_get_day_end() routine will take the given time in\n  GLib GDate format and adjust it to the last second of that day."]
    pub fn gnc_time64_get_day_end_gdate(date: *const GDate) -> time64;
}
unsafe extern "C" {
    #[doc = " This function modifies a GDate to set it to the first day of the\n  month in which it falls.  For example, if this function is called\n  with a date of 2003-09-24 the date will be modified to 2003-09-01.\n\n  @param date The GDate to modify."]
    pub fn gnc_gdate_set_month_start(date: *mut GDate);
}
unsafe extern "C" {
    #[doc = " This function modifies a GDate to set it to the last day of the\n  month in which it falls.  For example, if this function is called\n  with a date of 2003-09-24 the date will be modified to 2003-09-30.\n\n  @param date The GDate to modify."]
    pub fn gnc_gdate_set_month_end(date: *mut GDate);
}
unsafe extern "C" {
    #[doc = " This function modifies a GDate to set it to the first day of the\n  month prior to the one in which it falls.  For example, if this\n  function is called with a date of 2003-09-24 the date will be\n  modified to 2003-08-01.\n\n  @param date The GDate to modify."]
    pub fn gnc_gdate_set_prev_month_start(date: *mut GDate);
}
unsafe extern "C" {
    #[doc = " This function modifies a GDate to set it to the last day of the\n  month prior to the one in which it falls.  For example, if this\n  function is called with a date of 2003-09-24 the date will be\n  modified to 2003-08-31.\n\n  @param date The GDate to modify."]
    pub fn gnc_gdate_set_prev_month_end(date: *mut GDate);
}
unsafe extern "C" {
    #[doc = " This function modifies a GDate to set it to the first day of the\n  quarter in which it falls.  For example, if this function is called\n  with a date of 2003-09-24 the date will be modified to 2003-07-01.\n\n  @param date The GDate to modify."]
    pub fn gnc_gdate_set_quarter_start(date: *mut GDate);
}
unsafe extern "C" {
    #[doc = " This function modifies a GDate to set it to the last day of the\n  quarter in which it falls.  For example, if this function is called\n  with a date of 2003-09-24 the date will be modified to 2003-09-30.\n\n  @param date The GDate to modify."]
    pub fn gnc_gdate_set_quarter_end(date: *mut GDate);
}
unsafe extern "C" {
    #[doc = " This function modifies a GDate to set it to the first day of the\n  quarter prior to the one in which it falls.  For example, if this\n  function is called with a date of 2003-09-24 the date will be\n  modified to 2003-04-01.\n\n  @param date The GDate to modify."]
    pub fn gnc_gdate_set_prev_quarter_start(date: *mut GDate);
}
unsafe extern "C" {
    #[doc = " This function modifies a GDate to set it to the last day of the\n  quarter prior to the one in which it falls.  For example, if this\n  function is called with a date of 2003-09-24 the date will be\n  modified to 2003-06-30.\n\n  @param date The GDate to modify."]
    pub fn gnc_gdate_set_prev_quarter_end(date: *mut GDate);
}
unsafe extern "C" {
    #[doc = " This function modifies a GDate to set it to the first day of the\n  year in which it falls.  For example, if this function is called\n  with a date of 2003-09-24 the date will be modified to 2003-01-01.\n\n  @param date The GDate to modify."]
    pub fn gnc_gdate_set_year_start(date: *mut GDate);
}
unsafe extern "C" {
    #[doc = " This function modifies a GDate to set it to the last day of the\n  year in which it falls.  For example, if this function is called\n  with a date of 2003-09-24 the date will be modified to 2003-12-31.\n\n  @param date The GDate to modify."]
    pub fn gnc_gdate_set_year_end(date: *mut GDate);
}
unsafe extern "C" {
    #[doc = " This function modifies a GDate to set it to the first day of the\n  year prior to the one in which it falls.  For example, if this\n  function is called with a date of 2003-09-24 the date will be\n  modified to 2002-01-01.\n\n  @param date The GDate to modify."]
    pub fn gnc_gdate_set_prev_year_start(date: *mut GDate);
}
unsafe extern "C" {
    #[doc = " This function modifies a GDate to set it to the last day of the\n  year prior to the one in which it falls.  For example, if this\n  function is called with a date of 2003-09-24 the date will be\n  modified to 2002-12-31.\n\n  @param date The GDate to modify."]
    pub fn gnc_gdate_set_prev_year_end(date: *mut GDate);
}
unsafe extern "C" {
    #[doc = " This function modifies a GDate to set it to the first day of the\n  fiscal year in which it falls.  For example, if this function is\n  called with a date of 2003-09-24 and a fiscal year ending July\n  31st, the date will be modified to 2003-08-01.\n\n  @param date The GDate to modify.\n\n  @param year_end A GDate containing the last month and day of the\n  fiscal year.  The year field of this argument is ignored."]
    pub fn gnc_gdate_set_fiscal_year_start(date: *mut GDate, year_end: *const GDate);
}
unsafe extern "C" {
    #[doc = " This function modifies a GDate to set it to the last day of the\n  fiscal year in which it falls.  For example, if this function is\n  called with a date of 2003-09-24 and a fiscal year ending July\n  31st, the date will be modified to 2004-07-31.\n\n  @param date The GDate to modify.\n\n  @param year_end A GDate containing the last month and day of the\n  fiscal year.  The year field of this argument is ignored."]
    pub fn gnc_gdate_set_fiscal_year_end(date: *mut GDate, year_end: *const GDate);
}
unsafe extern "C" {
    #[doc = " This function modifies a GDate to set it to the first day of the\n  fiscal year prior to the one in which it falls.  For example, if\n  this function is called with a date of 2003-09-24 and a fiscal\n  year ending July 31st, the date will be modified to 2002-08-01.\n\n  @param date The GDate to modify.\n\n  @param year_end A GDate containing the last month and day of the\n  fiscal year.  The year field of this argument is ignored."]
    pub fn gnc_gdate_set_prev_fiscal_year_start(date: *mut GDate, year_end: *const GDate);
}
unsafe extern "C" {
    #[doc = " This function modifies a GDate to set it to the last day of the\n  fiscal year prior to the one in which it falls.  For example, if\n  this function is called with a date of 2003-09-24 and a fiscal\n  year ending July 31st, the date will be modified to 2003-07-31.\n\n  @param date The GDate to modify.\n\n  @param year_end A GDate containing the last month and day of the\n  fiscal year.  The year field of this argument is ignored."]
    pub fn gnc_gdate_set_prev_fiscal_year_end(date: *mut GDate, year_end: *const GDate);
}
#[doc = " QofIdType declaration"]
pub type QofIdType = *const gchar;
#[doc = " QofIdTypeConst declaration"]
pub type QofIdTypeConst = *const gchar;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct QofCollection_s {
    _unused: [u8; 0],
}
pub type QofCollection = QofCollection_s;
pub type QofInstanceClass = _QofInstanceClass;
pub type QofInstance = QofInstance_s;
#[doc = " \\brief QofBook reference"]
pub type QofBook = _QofBook;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct KvpFrameImpl {
    _unused: [u8; 0],
}
pub type KvpFrame = KvpFrameImpl;
#[repr(C)]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub struct QofInstance_s {
    pub object: GObject,
    #[doc = "<\tEntity type"]
    pub e_type: QofIdType,
    pub kvp_data: *mut KvpFrame,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of QofInstance_s"][::std::mem::size_of::<QofInstance_s>() - 40usize];
    ["Alignment of QofInstance_s"][::std::mem::align_of::<QofInstance_s>() - 8usize];
    ["Offset of field: QofInstance_s::object"]
        [::std::mem::offset_of!(QofInstance_s, object) - 0usize];
    ["Offset of field: QofInstance_s::e_type"]
        [::std::mem::offset_of!(QofInstance_s, e_type) - 24usize];
    ["Offset of field: QofInstance_s::kvp_data"]
        [::std::mem::offset_of!(QofInstance_s, kvp_data) - 32usize];
};
impl Default for QofInstance_s {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub struct _QofInstanceClass {
    pub parent_class: GObjectClass,
    pub get_display_name:
        ::std::option::Option<unsafe extern "C" fn(arg1: *const QofInstance) -> *mut gchar>,
    pub refers_to_object: ::std::option::Option<
        unsafe extern "C" fn(inst: *const QofInstance, ref_: *const QofInstance) -> gboolean,
    >,
    pub get_typed_referring_object_list: ::std::option::Option<
        unsafe extern "C" fn(inst: *const QofInstance, ref_: *const QofInstance) -> *mut GList,
    >,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of _QofInstanceClass"][::std::mem::size_of::<_QofInstanceClass>() - 160usize];
    ["Alignment of _QofInstanceClass"][::std::mem::align_of::<_QofInstanceClass>() - 8usize];
    ["Offset of field: _QofInstanceClass::parent_class"]
        [::std::mem::offset_of!(_QofInstanceClass, parent_class) - 0usize];
    ["Offset of field: _QofInstanceClass::get_display_name"]
        [::std::mem::offset_of!(_QofInstanceClass, get_display_name) - 136usize];
    ["Offset of field: _QofInstanceClass::refers_to_object"]
        [::std::mem::offset_of!(_QofInstanceClass, refers_to_object) - 144usize];
    ["Offset of field: _QofInstanceClass::get_typed_referring_object_list"]
        [::std::mem::offset_of!(_QofInstanceClass, get_typed_referring_object_list) - 152usize];
};
impl Default for _QofInstanceClass {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
unsafe extern "C" {
    #[doc = " Return the GType of a QofInstance"]
    pub fn qof_instance_get_type() -> GType;
}
unsafe extern "C" {
    #[doc = " Initialise the settings associated with an instance"]
    pub fn qof_instance_init_data(arg1: *mut QofInstance, arg2: QofIdType, arg3: *mut QofBook);
}
unsafe extern "C" {
    pub fn qof_instance_get_book(arg1: gconstpointer) -> *mut QofBook;
}
unsafe extern "C" {
    #[doc = " Set the book pointer"]
    pub fn qof_instance_set_book(inst: gconstpointer, book: *mut QofBook);
}
unsafe extern "C" {
    #[doc = " Copy the book from one QofInstances to another."]
    pub fn qof_instance_copy_book(ptr1: gpointer, ptr2: gconstpointer);
}
unsafe extern "C" {
    #[doc = " See if two QofInstances share the same book."]
    pub fn qof_instance_books_equal(ptr1: gconstpointer, ptr2: gconstpointer) -> gboolean;
}
unsafe extern "C" {
    pub fn qof_instance_get_guid(arg1: gconstpointer) -> *const GncGUID;
}
unsafe extern "C" {
    pub fn qof_entity_get_guid(arg1: gconstpointer) -> *const GncGUID;
}
unsafe extern "C" {
    pub fn qof_instance_get_collection(inst: gconstpointer) -> *mut QofCollection;
}
unsafe extern "C" {
    #[doc = " Compare the GncGUID values of two instances.  This routine returns 0\n  if the two values are equal, <0 if the first is smaller than the\n  second, or >0 if the second is smaller tan the first."]
    pub fn qof_instance_guid_compare(ptr1: gconstpointer, ptr2: gconstpointer) -> gint;
}
unsafe extern "C" {
    pub fn qof_instance_get_editlevel(ptr: gconstpointer) -> gint;
}
unsafe extern "C" {
    #[doc = " Compare two instances, based on their last update times.\n  Returns a negative, zero or positive value, respectively,\n  if 'left' is earlier, same as or later than 'right'.\n  Accepts NULL pointers, NULL's are by definition earlier\n  than any value."]
    pub fn qof_instance_version_cmp(
        left: *const QofInstance,
        right: *const QofInstance,
    ) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    #[doc = " Retrieve the flag that indicates whether or not this object is\n  about to be destroyed.\n\n  @param ptr The object whose flag should be retrieved.\n\n  @return TRUE if the object has been marked for destruction. FALSE\n  if the object is not marked for destruction, or if a bad parameter\n  is passed to the function."]
    pub fn qof_instance_get_destroying(ptr: gconstpointer) -> gboolean;
}
unsafe extern "C" {
    #[doc = " Retrieve the flag that indicates whether or not this object has\n  been modified.  This is specifically the flag on the object. It\n  does not perform any other checking which might normally be\n  performed when testing to see if an object is dirty.  If there is\n  any question, use the qof_instance_is_dirty() function instead.\n\n  @param ptr The object whose flag should be retrieved.\n\n  @return TRUE if the object has been modified and not saved. FALSE\n  if the object has not been modified, or if a bad parameter is\n  passed to the function."]
    pub fn qof_instance_get_dirty_flag(ptr: gconstpointer) -> gboolean;
}
unsafe extern "C" {
    pub fn qof_instance_print_dirty(entity: *const QofInstance, dummy: gpointer);
}
unsafe extern "C" {
    pub fn qof_instance_get_dirty(arg1: *mut QofInstance) -> gboolean;
}
unsafe extern "C" {
    pub fn qof_instance_get_infant(inst: *const QofInstance) -> gboolean;
}
unsafe extern "C" {
    #[doc = " \\brief Wrapper for g_object_get"]
    pub fn qof_instance_get(inst: *const QofInstance, first_param: *const gchar, ...);
}
unsafe extern "C" {
    #[doc = " \\brief Wrapper for g_object_set\n Group setting multiple parameters in a single begin/commit/rollback"]
    pub fn qof_instance_set(inst: *mut QofInstance, first_param: *const gchar, ...);
}
unsafe extern "C" {
    #[doc = " get the instance tag number\nused for kvp management in sql backends."]
    pub fn qof_instance_get_idata(inst: gconstpointer) -> guint32;
}
unsafe extern "C" {
    #[doc = " Returns a displayable name for this object.  The returned string must be freed by the caller."]
    pub fn qof_instance_get_display_name(inst: *const QofInstance) -> *mut gchar;
}
unsafe extern "C" {
    #[doc = " Returns a list of objects which refer to a specific object.  The list must be freed by the caller,\n but the objects on the list must not."]
    pub fn qof_instance_get_referring_object_list(inst: *const QofInstance) -> *mut GList;
}
unsafe extern "C" {
    #[doc = " Does this object refer to a specific object"]
    pub fn qof_instance_refers_to_object(
        inst: *const QofInstance,
        ref_: *const QofInstance,
    ) -> gboolean;
}
unsafe extern "C" {
    #[doc = " Returns a list of my type of object which refers to an object.  For example, when called as\nqof_instance_get_typed_referring_object_list(taxtable, account);\nit will return the list of taxtables which refer to a specific account.  The result should be the\nsame regardless of which taxtable object is used.  The list must be freed by the caller but the\nobjects on the list must not."]
    pub fn qof_instance_get_typed_referring_object_list(
        inst: *const QofInstance,
        ref_: *const QofInstance,
    ) -> *mut GList;
}
unsafe extern "C" {
    #[doc = " Returns a list of objects from the collection which refer to the specific object.  The list must be\nfreed by the caller but the objects on the list must not."]
    pub fn qof_instance_get_referring_object_list_from_collection(
        coll: *const QofCollection,
        ref_: *const QofInstance,
    ) -> *mut GList;
}
unsafe extern "C" {
    #[doc = " create a new collection of entities of type"]
    pub fn qof_collection_new(type_: QofIdType) -> *mut QofCollection;
}
unsafe extern "C" {
    #[doc = " return the number of entities in the collection."]
    pub fn qof_collection_count(col: *const QofCollection) -> guint;
}
unsafe extern "C" {
    #[doc = " destroy the collection"]
    pub fn qof_collection_destroy(col: *mut QofCollection);
}
unsafe extern "C" {
    #[doc = " return the type that the collection stores"]
    pub fn qof_collection_get_type(arg1: *const QofCollection) -> QofIdType;
}
unsafe extern "C" {
    pub fn qof_collection_lookup_entity(
        arg1: *const QofCollection,
        arg2: *const GncGUID,
    ) -> *mut QofInstance;
}
#[doc = " Callback type for qof_collection_foreach"]
pub type QofInstanceForeachCB =
    ::std::option::Option<unsafe extern "C" fn(arg1: *mut QofInstance, user_data: gpointer)>;
unsafe extern "C" {
    #[doc = " Call the callback for each entity in the collection."]
    pub fn qof_collection_foreach_sorted(
        col: *const QofCollection,
        cb_func: QofInstanceForeachCB,
        user_data: gpointer,
        sort_fn: GCompareFunc,
    );
}
unsafe extern "C" {
    pub fn qof_collection_foreach(
        arg1: *const QofCollection,
        arg2: QofInstanceForeachCB,
        user_data: gpointer,
    );
}
unsafe extern "C" {
    #[doc = " Store and retrieve arbitrary object-defined data\n\n XXX We need to add a callback for when the collection is being\n destroyed, so that the user has a chance to clean up anything\n that was put in the 'data' member here."]
    pub fn qof_collection_get_data(col: *const QofCollection) -> gpointer;
}
unsafe extern "C" {
    pub fn qof_collection_set_data(col: *mut QofCollection, user_data: gpointer);
}
unsafe extern "C" {
    #[doc = " Return value of 'dirty' flag on collection"]
    pub fn qof_collection_is_dirty(col: *const QofCollection) -> gboolean;
}
unsafe extern "C" {
    #[doc = " @name QOF_TYPE_COLLECT: Linking one entity to many of one type\n\n\\note These are \\b NOT the same as the main collections in the book.\n\nQOF_TYPE_COLLECT is a secondary collection, used to select entities\nof one object type as references of another entity.\n\\sa QOF_TYPE_CHOICE.\n\n@{\n/\n/** \\brief Add an entity to a QOF_TYPE_COLLECT.\n\n\\note These are \\b NOT the same as the main collections in the book.\n\nEntities can be\nfreely added and merged across these secondary collections, they\nwill not be removed from the original collection as they would\nby using ::qof_instance_insert_entity or ::qof_instance_remove_entity."]
    pub fn qof_collection_add_entity(coll: *mut QofCollection, ent: *mut QofInstance) -> gboolean;
}
unsafe extern "C" {
    pub fn qof_collection_remove_entity(ent: *mut QofInstance);
}
unsafe extern "C" {
    #[doc = " \\brief Compare two secondary collections.\n\nPerforms a deep comparison of the collections. Each QofInstance in\neach collection is looked up in the other collection, via the GncGUID.\n\n\\return 0 if the collections are identical or both are NULL\notherwise -1 if target is NULL or either collection contains an entity with an invalid\nGncGUID or if the types of the two collections do not match,\nor +1 if merge is NULL or if any entity exists in one collection but\nnot in the other."]
    pub fn qof_collection_compare(target: *mut QofCollection, merge: *mut QofCollection) -> gint;
}
unsafe extern "C" {
    #[doc = " \\brief Create a secondary collection from a GList\n\n@param type The QofIdType of the QofCollection \\b and of\n\\b all entities in the GList.\n@param glist GList of entities of the same QofIdType.\n\n@return NULL if any of the entities fail to match the\nQofCollection type, else a pointer to the collection\non success."]
    pub fn qof_collection_from_glist(type_: QofIdType, glist: *const GList) -> *mut QofCollection;
}
pub type FILE = _IO_FILE;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _IO_marker {
    _unused: [u8; 0],
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _IO_codecvt {
    _unused: [u8; 0],
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _IO_wide_data {
    _unused: [u8; 0],
}
pub type _IO_lock_t = ::std::os::raw::c_void;
#[repr(C)]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub struct _IO_FILE {
    pub _flags: ::std::os::raw::c_int,
    pub _IO_read_ptr: *mut ::std::os::raw::c_char,
    pub _IO_read_end: *mut ::std::os::raw::c_char,
    pub _IO_read_base: *mut ::std::os::raw::c_char,
    pub _IO_write_base: *mut ::std::os::raw::c_char,
    pub _IO_write_ptr: *mut ::std::os::raw::c_char,
    pub _IO_write_end: *mut ::std::os::raw::c_char,
    pub _IO_buf_base: *mut ::std::os::raw::c_char,
    pub _IO_buf_end: *mut ::std::os::raw::c_char,
    pub _IO_save_base: *mut ::std::os::raw::c_char,
    pub _IO_backup_base: *mut ::std::os::raw::c_char,
    pub _IO_save_end: *mut ::std::os::raw::c_char,
    pub _markers: *mut _IO_marker,
    pub _chain: *mut _IO_FILE,
    pub _fileno: ::std::os::raw::c_int,
    pub _bitfield_align_1: [u32; 0],
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 3usize]>,
    pub _short_backupbuf: [::std::os::raw::c_char; 1usize],
    pub _old_offset: __off_t,
    pub _cur_column: ::std::os::raw::c_ushort,
    pub _vtable_offset: ::std::os::raw::c_schar,
    pub _shortbuf: [::std::os::raw::c_char; 1usize],
    pub _lock: *mut _IO_lock_t,
    pub _offset: __off64_t,
    pub _codecvt: *mut _IO_codecvt,
    pub _wide_data: *mut _IO_wide_data,
    pub _freeres_list: *mut _IO_FILE,
    pub _freeres_buf: *mut ::std::os::raw::c_void,
    pub _prevchain: *mut *mut _IO_FILE,
    pub _mode: ::std::os::raw::c_int,
    pub _unused2: [::std::os::raw::c_char; 20usize],
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of _IO_FILE"][::std::mem::size_of::<_IO_FILE>() - 216usize];
    ["Alignment of _IO_FILE"][::std::mem::align_of::<_IO_FILE>() - 8usize];
    ["Offset of field: _IO_FILE::_flags"][::std::mem::offset_of!(_IO_FILE, _flags) - 0usize];
    ["Offset of field: _IO_FILE::_IO_read_ptr"]
        [::std::mem::offset_of!(_IO_FILE, _IO_read_ptr) - 8usize];
    ["Offset of field: _IO_FILE::_IO_read_end"]
        [::std::mem::offset_of!(_IO_FILE, _IO_read_end) - 16usize];
    ["Offset of field: _IO_FILE::_IO_read_base"]
        [::std::mem::offset_of!(_IO_FILE, _IO_read_base) - 24usize];
    ["Offset of field: _IO_FILE::_IO_write_base"]
        [::std::mem::offset_of!(_IO_FILE, _IO_write_base) - 32usize];
    ["Offset of field: _IO_FILE::_IO_write_ptr"]
        [::std::mem::offset_of!(_IO_FILE, _IO_write_ptr) - 40usize];
    ["Offset of field: _IO_FILE::_IO_write_end"]
        [::std::mem::offset_of!(_IO_FILE, _IO_write_end) - 48usize];
    ["Offset of field: _IO_FILE::_IO_buf_base"]
        [::std::mem::offset_of!(_IO_FILE, _IO_buf_base) - 56usize];
    ["Offset of field: _IO_FILE::_IO_buf_end"]
        [::std::mem::offset_of!(_IO_FILE, _IO_buf_end) - 64usize];
    ["Offset of field: _IO_FILE::_IO_save_base"]
        [::std::mem::offset_of!(_IO_FILE, _IO_save_base) - 72usize];
    ["Offset of field: _IO_FILE::_IO_backup_base"]
        [::std::mem::offset_of!(_IO_FILE, _IO_backup_base) - 80usize];
    ["Offset of field: _IO_FILE::_IO_save_end"]
        [::std::mem::offset_of!(_IO_FILE, _IO_save_end) - 88usize];
    ["Offset of field: _IO_FILE::_markers"][::std::mem::offset_of!(_IO_FILE, _markers) - 96usize];
    ["Offset of field: _IO_FILE::_chain"][::std::mem::offset_of!(_IO_FILE, _chain) - 104usize];
    ["Offset of field: _IO_FILE::_fileno"][::std::mem::offset_of!(_IO_FILE, _fileno) - 112usize];
    ["Offset of field: _IO_FILE::_short_backupbuf"]
        [::std::mem::offset_of!(_IO_FILE, _short_backupbuf) - 119usize];
    ["Offset of field: _IO_FILE::_old_offset"]
        [::std::mem::offset_of!(_IO_FILE, _old_offset) - 120usize];
    ["Offset of field: _IO_FILE::_cur_column"]
        [::std::mem::offset_of!(_IO_FILE, _cur_column) - 128usize];
    ["Offset of field: _IO_FILE::_vtable_offset"]
        [::std::mem::offset_of!(_IO_FILE, _vtable_offset) - 130usize];
    ["Offset of field: _IO_FILE::_shortbuf"]
        [::std::mem::offset_of!(_IO_FILE, _shortbuf) - 131usize];
    ["Offset of field: _IO_FILE::_lock"][::std::mem::offset_of!(_IO_FILE, _lock) - 136usize];
    ["Offset of field: _IO_FILE::_offset"][::std::mem::offset_of!(_IO_FILE, _offset) - 144usize];
    ["Offset of field: _IO_FILE::_codecvt"][::std::mem::offset_of!(_IO_FILE, _codecvt) - 152usize];
    ["Offset of field: _IO_FILE::_wide_data"]
        [::std::mem::offset_of!(_IO_FILE, _wide_data) - 160usize];
    ["Offset of field: _IO_FILE::_freeres_list"]
        [::std::mem::offset_of!(_IO_FILE, _freeres_list) - 168usize];
    ["Offset of field: _IO_FILE::_freeres_buf"]
        [::std::mem::offset_of!(_IO_FILE, _freeres_buf) - 176usize];
    ["Offset of field: _IO_FILE::_prevchain"]
        [::std::mem::offset_of!(_IO_FILE, _prevchain) - 184usize];
    ["Offset of field: _IO_FILE::_mode"][::std::mem::offset_of!(_IO_FILE, _mode) - 192usize];
    ["Offset of field: _IO_FILE::_unused2"][::std::mem::offset_of!(_IO_FILE, _unused2) - 196usize];
};
impl Default for _IO_FILE {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
impl _IO_FILE {
    #[inline]
    pub fn _flags2(&self) -> ::std::os::raw::c_int {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(0usize, 24u8) as u32) }
    }
    #[inline]
    pub fn set__flags2(&mut self, val: ::std::os::raw::c_int) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(0usize, 24u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn _flags2_raw(this: *const Self) -> ::std::os::raw::c_int {
        unsafe {
            ::std::mem::transmute(<__BindgenBitfieldUnit<[u8; 3usize]>>::raw_get(
                ::std::ptr::addr_of!((*this)._bitfield_1),
                0usize,
                24u8,
            ) as u32)
        }
    }
    #[inline]
    pub unsafe fn set__flags2_raw(this: *mut Self, val: ::std::os::raw::c_int) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 3usize]>>::raw_set(
                ::std::ptr::addr_of_mut!((*this)._bitfield_1),
                0usize,
                24u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn new_bitfield_1(_flags2: ::std::os::raw::c_int) -> __BindgenBitfieldUnit<[u8; 3usize]> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 3usize]> = Default::default();
        __bindgen_bitfield_unit.set(0usize, 24u8, {
            let _flags2: u32 = unsafe { ::std::mem::transmute(_flags2) };
            _flags2 as u64
        });
        __bindgen_bitfield_unit
    }
}
#[repr(u32)]
#[doc = " \\brief The errors that can be reported to the GUI & other front-end users"]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub enum QofBackendError {
    ERR_BACKEND_NO_ERR = 0,
    #[doc = "< no backend handler found for this access method (ENOSYS)"]
    ERR_BACKEND_NO_HANDLER = 1,
    #[doc = "< Backend * pointer was unexpectedly null"]
    ERR_BACKEND_NO_BACKEND = 2,
    #[doc = "< Can't parse url"]
    ERR_BACKEND_BAD_URL = 3,
    #[doc = "< the named database doesn't exist"]
    ERR_BACKEND_NO_SUCH_DB = 4,
    #[doc = "< bad dbname/login/passwd or network failure"]
    ERR_BACKEND_CANT_CONNECT = 5,
    #[doc = "< Lost connection to server"]
    ERR_BACKEND_CONN_LOST = 6,
    #[doc = "< in use by another user (ETXTBSY)"]
    ERR_BACKEND_LOCKED = 7,
    #[doc = "< File exists, data would be destroyed"]
    ERR_BACKEND_STORE_EXISTS = 8,
    #[doc = "< cannot write to file/directory"]
    ERR_BACKEND_READONLY = 9,
    #[doc = "< file/db version newer than what we can read"]
    ERR_BACKEND_TOO_NEW = 10,
    #[doc = "< data in db is corrupt"]
    ERR_BACKEND_DATA_CORRUPT = 11,
    #[doc = "< error in response from server"]
    ERR_BACKEND_SERVER_ERR = 12,
    #[doc = "< internal memory allocation failure"]
    ERR_BACKEND_ALLOC = 13,
    #[doc = "< user login successful, but no permissions\nto access the desired object"]
    ERR_BACKEND_PERM = 14,
    #[doc = "< commit of object update failed because\nanother user has modified the object"]
    ERR_BACKEND_MODIFIED = 15,
    #[doc = "< commit of object update failed because\nanother user has deleted the object"]
    ERR_BACKEND_MOD_DESTROY = 16,
    #[doc = "< undetermined error"]
    ERR_BACKEND_MISC = 17,
    #[doc = "< EOVERFLOW - generated by strtol or strtoll.\n\nWhen converting XML strings into numbers, an overflow has been detected. The XML file\ncontains invalid data in a field that is meant to hold a signed long integer or signed long long\ninteger."]
    ERR_QOF_OVERFLOW = 18,
    #[doc = "< read failed or file prematurely truncated"]
    ERR_FILEIO_FILE_BAD_READ = 1000,
    #[doc = "< file exists, is readable, but is empty"]
    ERR_FILEIO_FILE_EMPTY = 1001,
    #[doc = "< mangled locks (unspecified error)"]
    ERR_FILEIO_FILE_LOCKERR = 1002,
    #[doc = "< not found / no such file"]
    ERR_FILEIO_FILE_NOT_FOUND = 1003,
    #[doc = "< file version so old we can't read it"]
    ERR_FILEIO_FILE_TOO_OLD = 1004,
    #[doc = "< didn't recognize the file type"]
    ERR_FILEIO_UNKNOWN_FILE_TYPE = 1005,
    #[doc = "< couldn't parse the data in the file"]
    ERR_FILEIO_PARSE_ERROR = 1006,
    #[doc = "< couldn't make a backup of the file"]
    ERR_FILEIO_BACKUP_ERROR = 1007,
    #[doc = "< couldn't write to the file"]
    ERR_FILEIO_WRITE_ERROR = 1008,
    #[doc = "< Could not open the file for reading."]
    ERR_FILEIO_READ_ERROR = 1009,
    #[doc = "< file does not specify encoding"]
    ERR_FILEIO_NO_ENCODING = 1010,
    #[doc = "< No read access permission for the given file"]
    ERR_FILEIO_FILE_EACCES = 1011,
    #[doc = "< User attempt to write to a directory reserved\nfor internal use by GnuCash"]
    ERR_FILEIO_RESERVED_WRITE = 1012,
    #[doc = "< file will be upgraded and not be able to be\nread by prior versions - warn users"]
    ERR_FILEIO_FILE_UPGRADE = 1013,
    #[doc = "< not enough bytes received"]
    ERR_NETIO_SHORT_READ = 2000,
    #[doc = "< wrong kind of server, wrong data served"]
    ERR_NETIO_WRONG_CONTENT_TYPE = 2001,
    #[doc = "< whatever it is, we can't parse it."]
    ERR_NETIO_NOT_GNCXML = 2002,
    #[doc = "< database doesn't contain expected data"]
    ERR_SQL_MISSING_DATA = 3000,
    #[doc = "< database is old and needs upgrading"]
    ERR_SQL_DB_TOO_OLD = 3001,
    #[doc = "< database is newer, we can't write to it"]
    ERR_SQL_DB_TOO_NEW = 3002,
    #[doc = "< database is busy, cannot upgrade version"]
    ERR_SQL_DB_BUSY = 3003,
    #[doc = "< LibDBI has numeric errors"]
    ERR_SQL_BAD_DBI = 3004,
    #[doc = "< could not complete test for LibDBI bug"]
    ERR_SQL_DBI_UNTESTABLE = 3005,
    #[doc = "< Host unknown"]
    ERR_RPC_HOST_UNK = 4000,
    #[doc = "< can't bind to address"]
    ERR_RPC_CANT_BIND = 4001,
    #[doc = "< can't accept connection"]
    ERR_RPC_CANT_ACCEPT = 4002,
    #[doc = "< no connection to server"]
    ERR_RPC_NO_CONNECTION = 4003,
    #[doc = "< RPC Version Mismatch"]
    ERR_RPC_BAD_VERSION = 4004,
    #[doc = "< Operation failed"]
    ERR_RPC_FAILED = 4005,
    #[doc = "< object not added"]
    ERR_RPC_NOT_ADDED = 4006,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct QofBackend {
    _unused: [u8; 0],
}
unsafe extern "C" {
    #[doc = " Get the last backend error."]
    pub fn qof_backend_get_error(arg1: *mut QofBackend) -> QofBackendError;
}
unsafe extern "C" {
    #[doc = " Set the error on the specified QofBackend."]
    pub fn qof_backend_set_error(arg1: *mut QofBackend, arg2: QofBackendError);
}
unsafe extern "C" {
    pub fn qof_backend_can_rollback(arg1: *mut QofBackend) -> gboolean;
}
unsafe extern "C" {
    pub fn qof_backend_rollback_instance(arg1: *mut QofBackend, arg2: *mut QofInstance);
}
unsafe extern "C" {
    #[doc = " \\brief Load a QOF-compatible backend shared library.\n\n\\param directory Can be NULL if filename is a complete path.\n\\param module_name  Name of the .la file that describes the\nshared library. This provides platform independence,\ncourtesy of libtool.\n\n\\return FALSE in case or error, otherwise TRUE."]
    pub fn qof_load_backend_library(directory: *const gchar, module_name: *const gchar)
    -> gboolean;
}
unsafe extern "C" {
    #[doc = " \\brief Finalize all loaded backend shareable libraries."]
    pub fn qof_finalize_backend_libraries();
}
unsafe extern "C" {
    #[doc = " \\brief Retrieve the backend used by this book"]
    pub fn qof_book_get_backend(book: *const QofBook) -> *mut QofBackend;
}
unsafe extern "C" {
    pub fn qof_book_set_backend(book: *mut QofBook, arg1: *mut QofBackend);
}
#[doc = " @} */\n/** Type of Parameters (String, Date, Numeric, GncGUID, etc.)"]
pub type QofType = *const ::std::os::raw::c_char;
#[doc = " This structure is for each queryable parameter in an object\n\n -- param_name is the name of the parameter.\n -- param_type is the type of the parameter, which can be either another\n    object (QofIdType) or it can be a core data type (QofType).\n -- param_getfcn is the function to actually obtain the parameter\n -- param_setfcn is the function to actually set the parameter\n -- param_userdata is a place where the object author can place any\n    desired object-author-defined data (and thus can be used by the\n    author-defined setter/getter).\n\n Either the getter or the setter may be NULL.\n\n  XXX todo/fixme: need to define a destroy callback, so that when\n the param memory is freed, the callback can be used to release the\n user-defined data."]
pub type QofParam = _QofParam;
#[doc = " The QofAccessFunc defines an arbitrary function pointer\n  for access functions.  This is needed because C doesn't have\n  templates, so we just cast a lot.  Real functions must be of\n  the form:\n\n        param_type getter_func (object_type *self);\n  or\n        param_type getter_func (object_type *self, QofParam *param);\n\n The additional argument 'param' allows generic getter functions\n to be implemented, because this argument provides for a way to\n identify the expected getter_func return type at runtime.  It\n also provides a place for the user to hang additional user-defined\n data."]
pub type QofAccessFunc = ::std::option::Option<
    unsafe extern "C" fn(object: gpointer, param: *const QofParam) -> gpointer,
>;
#[doc = " The QofSetterFunc defines an function pointer for parameter\n  setters. Real functions must be of the form:\n\n void setter_func (object_type *self, param_type *param);"]
pub type QofSetterFunc =
    ::std::option::Option<unsafe extern "C" fn(arg1: gpointer, arg2: gpointer)>;
pub type QofCompareFunc = ::std::option::Option<
    unsafe extern "C" fn(
        a: gpointer,
        b: gpointer,
        compare_options: gint,
        getter: *mut QofParam,
    ) -> gint,
>;
#[doc = " This structure is for each queryable parameter in an object\n\n -- param_name is the name of the parameter.\n -- param_type is the type of the parameter, which can be either another\n    object (QofIdType) or it can be a core data type (QofType).\n -- param_getfcn is the function to actually obtain the parameter\n -- param_setfcn is the function to actually set the parameter\n -- param_userdata is a place where the object author can place any\n    desired object-author-defined data (and thus can be used by the\n    author-defined setter/getter).\n\n Either the getter or the setter may be NULL.\n\n  XXX todo/fixme: need to define a destroy callback, so that when\n the param memory is freed, the callback can be used to release the\n user-defined data."]
#[repr(C)]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub struct _QofParam {
    pub param_name: *const ::std::os::raw::c_char,
    pub param_type: QofType,
    pub param_getfcn: QofAccessFunc,
    pub param_setfcn: QofSetterFunc,
    pub param_compfcn: QofCompareFunc,
    pub param_userdata: gpointer,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of _QofParam"][::std::mem::size_of::<_QofParam>() - 48usize];
    ["Alignment of _QofParam"][::std::mem::align_of::<_QofParam>() - 8usize];
    ["Offset of field: _QofParam::param_name"]
        [::std::mem::offset_of!(_QofParam, param_name) - 0usize];
    ["Offset of field: _QofParam::param_type"]
        [::std::mem::offset_of!(_QofParam, param_type) - 8usize];
    ["Offset of field: _QofParam::param_getfcn"]
        [::std::mem::offset_of!(_QofParam, param_getfcn) - 16usize];
    ["Offset of field: _QofParam::param_setfcn"]
        [::std::mem::offset_of!(_QofParam, param_setfcn) - 24usize];
    ["Offset of field: _QofParam::param_compfcn"]
        [::std::mem::offset_of!(_QofParam, param_compfcn) - 32usize];
    ["Offset of field: _QofParam::param_userdata"]
        [::std::mem::offset_of!(_QofParam, param_userdata) - 40usize];
};
impl Default for _QofParam {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[doc = " This function is the default sort function for a particular object type"]
pub type QofSortFunc = ::std::option::Option<
    unsafe extern "C" fn(arg1: gconstpointer, arg2: gconstpointer) -> ::std::os::raw::c_int,
>;
unsafe extern "C" {
    #[doc = " This function registers a new object class with the Qof subsystem.\n  In particular, it registers the set of setters and getters for\n  controlling the object.   The getters are typically used by the\n  query subsystem to query type specific data.   Note that there\n  is no particular requirement for there to be a setter for every\n  getter or even vice-versa, nor is there any requirement for these\n  to map 'cleanly' or orthogonally to the underlying object.  The\n  parameters are really just a set of value setting and getting\n  routines.\n\n  The \"params\" argument must be a NULL-terminated array of QofParam.\n  It may be NULL if there are no parameters to be registered."]
    pub fn qof_class_register(
        obj_name: QofIdTypeConst,
        default_sort_fcn: QofSortFunc,
        params: *const QofParam,
    );
}
unsafe extern "C" {
    #[doc = " Return true if the the indicated type is registered,\n  else return FALSE."]
    pub fn qof_class_is_registered(obj_name: QofIdTypeConst) -> gboolean;
}
unsafe extern "C" {
    #[doc = " Return the core datatype of the specified object's parameter"]
    pub fn qof_class_get_parameter_type(
        obj_name: QofIdTypeConst,
        param_name: *const ::std::os::raw::c_char,
    ) -> QofType;
}
unsafe extern "C" {
    #[doc = " Return the registered Parameter Definition for the requested parameter"]
    pub fn qof_class_get_parameter(
        obj_name: QofIdTypeConst,
        parameter: *const ::std::os::raw::c_char,
    ) -> *const QofParam;
}
unsafe extern "C" {
    #[doc = " Return the object's parameter getter function"]
    pub fn qof_class_get_parameter_getter(
        obj_name: QofIdTypeConst,
        parameter: *const ::std::os::raw::c_char,
    ) -> QofAccessFunc;
}
unsafe extern "C" {
    #[doc = " Return the object's parameter setter function"]
    pub fn qof_class_get_parameter_setter(
        obj_name: QofIdTypeConst,
        parameter: *const ::std::os::raw::c_char,
    ) -> QofSetterFunc;
}
#[doc = " Type definition for the class callback function."]
pub type QofClassForeachCB =
    ::std::option::Option<unsafe extern "C" fn(arg1: QofIdTypeConst, arg2: gpointer)>;
unsafe extern "C" {
    #[doc = " Call the callback once for each object class that is registered\n  with the system.  The 'user_data' is passed back to the callback."]
    pub fn qof_class_foreach(arg1: QofClassForeachCB, user_data: gpointer);
}
#[doc = " Type definition for the parameter callback function."]
pub type QofParamForeachCB =
    ::std::option::Option<unsafe extern "C" fn(arg1: *mut QofParam, user_data: gpointer)>;
unsafe extern "C" {
    #[doc = " Call the callback once for each parameter on the indicated\n  object class.  The 'user_data' is passed back to the callback."]
    pub fn qof_class_param_foreach(
        obj_name: QofIdTypeConst,
        arg1: QofParamForeachCB,
        user_data: gpointer,
    );
}
unsafe extern "C" {
    #[doc = " \\brief List of the parameters that could be references.\n\nSimple check to return a GList of all parameters\nof this object type that are not known QOF data types.\nUsed for partial QofBook support, see ::QofInstanceReference"]
    pub fn qof_class_get_referenceList(type_: QofIdTypeConst) -> *mut GList;
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct GncOptionDB {
    _unused: [u8; 0],
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct KvpValueImpl {
    _unused: [u8; 0],
}
pub type KvpValue = KvpValueImpl;
pub type QofBookDirtyCB = ::std::option::Option<
    unsafe extern "C" fn(arg1: *mut QofBook, dirty: gboolean, user_data: gpointer),
>;
pub type GncOptionSave = ::std::option::Option<
    unsafe extern "C" fn(arg1: *mut GncOptionDB, arg2: *mut QofBook, arg3: gboolean),
>;
pub type GncOptionLoad =
    ::std::option::Option<unsafe extern "C" fn(arg1: *mut GncOptionDB, arg2: *mut QofBook)>;
#[repr(C)]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub struct _QofBook {
    pub inst: QofInstance,
    pub session_dirty: gboolean,
    pub dirty_time: time64,
    pub dirty_cb: QofBookDirtyCB,
    pub dirty_data: gpointer,
    pub hash_of_collections: *mut GHashTable,
    pub data_tables: *mut GHashTable,
    pub data_table_finalizers: *mut GHashTable,
    pub read_only: gboolean,
    pub book_open: ::std::os::raw::c_char,
    pub shutting_down: gboolean,
    pub version: gint32,
    pub backend: *mut QofBackend,
    pub cached_num_field_source: gboolean,
    pub cached_num_field_source_isvalid: gboolean,
    pub cached_num_days_autoreadonly: gint,
    pub cached_num_days_autoreadonly_isvalid: gboolean,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of _QofBook"][::std::mem::size_of::<_QofBook>() - 136usize];
    ["Alignment of _QofBook"][::std::mem::align_of::<_QofBook>() - 8usize];
    ["Offset of field: _QofBook::inst"][::std::mem::offset_of!(_QofBook, inst) - 0usize];
    ["Offset of field: _QofBook::session_dirty"]
        [::std::mem::offset_of!(_QofBook, session_dirty) - 40usize];
    ["Offset of field: _QofBook::dirty_time"]
        [::std::mem::offset_of!(_QofBook, dirty_time) - 48usize];
    ["Offset of field: _QofBook::dirty_cb"][::std::mem::offset_of!(_QofBook, dirty_cb) - 56usize];
    ["Offset of field: _QofBook::dirty_data"]
        [::std::mem::offset_of!(_QofBook, dirty_data) - 64usize];
    ["Offset of field: _QofBook::hash_of_collections"]
        [::std::mem::offset_of!(_QofBook, hash_of_collections) - 72usize];
    ["Offset of field: _QofBook::data_tables"]
        [::std::mem::offset_of!(_QofBook, data_tables) - 80usize];
    ["Offset of field: _QofBook::data_table_finalizers"]
        [::std::mem::offset_of!(_QofBook, data_table_finalizers) - 88usize];
    ["Offset of field: _QofBook::read_only"][::std::mem::offset_of!(_QofBook, read_only) - 96usize];
    ["Offset of field: _QofBook::book_open"]
        [::std::mem::offset_of!(_QofBook, book_open) - 100usize];
    ["Offset of field: _QofBook::shutting_down"]
        [::std::mem::offset_of!(_QofBook, shutting_down) - 104usize];
    ["Offset of field: _QofBook::version"][::std::mem::offset_of!(_QofBook, version) - 108usize];
    ["Offset of field: _QofBook::backend"][::std::mem::offset_of!(_QofBook, backend) - 112usize];
    ["Offset of field: _QofBook::cached_num_field_source"]
        [::std::mem::offset_of!(_QofBook, cached_num_field_source) - 120usize];
    ["Offset of field: _QofBook::cached_num_field_source_isvalid"]
        [::std::mem::offset_of!(_QofBook, cached_num_field_source_isvalid) - 124usize];
    ["Offset of field: _QofBook::cached_num_days_autoreadonly"]
        [::std::mem::offset_of!(_QofBook, cached_num_days_autoreadonly) - 128usize];
    ["Offset of field: _QofBook::cached_num_days_autoreadonly_isvalid"]
        [::std::mem::offset_of!(_QofBook, cached_num_days_autoreadonly_isvalid) - 132usize];
};
impl Default for _QofBook {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
unsafe extern "C" {
    pub fn qof_book_get_type() -> GType;
}
pub type QofBookFinalCB = ::std::option::Option<
    unsafe extern "C" fn(arg1: *mut QofBook, key: gpointer, user_data: gpointer),
>;
unsafe extern "C" {
    #[doc = " Register the book object with the QOF object system."]
    pub fn qof_book_register() -> gboolean;
}
unsafe extern "C" {
    #[doc = " Allocate, initialise and return a new QofBook.  Books contain references\n  to all of the top-level object containers."]
    pub fn qof_book_new() -> *mut QofBook;
}
unsafe extern "C" {
    #[doc = " End any editing sessions associated with book, and free all memory\nassociated with it."]
    pub fn qof_book_destroy(book: *mut QofBook);
}
unsafe extern "C" {
    #[doc = " Close a book to editing.\n\nIt is up to the application to check this flag,\nand once marked closed, books cannot be marked as open."]
    pub fn qof_book_mark_closed(book: *mut QofBook);
}
unsafe extern "C" {
    pub fn qof_book_get_collection(arg1: *const QofBook, arg2: QofIdType) -> *mut QofCollection;
}
#[doc = " Invoke the indicated callback on each collection in the book."]
pub type QofCollectionForeachCB =
    ::std::option::Option<unsafe extern "C" fn(arg1: *mut QofCollection, user_data: gpointer)>;
unsafe extern "C" {
    pub fn qof_book_foreach_collection(
        arg1: *const QofBook,
        arg2: QofCollectionForeachCB,
        arg3: gpointer,
    );
}
unsafe extern "C" {
    #[doc = " The qof_book_set_data() allows arbitrary pointers to structs\n    to be stored in QofBook. This is the \"preferred\" method for\n    extending QofBook to hold new data types.  This is also\n    the ideal location to store other arbitrary runtime data\n    that the application may need."]
    pub fn qof_book_set_data(book: *mut QofBook, key: *const gchar, data: gpointer);
}
unsafe extern "C" {
    #[doc = " Same as qof_book_set_data(), except that the callback will be called\n  when the book is destroyed.  The argument to the callback will be\n  the book followed by the data pointer."]
    pub fn qof_book_set_data_fin(
        book: *mut QofBook,
        key: *const gchar,
        data: gpointer,
        arg1: QofBookFinalCB,
    );
}
unsafe extern "C" {
    #[doc = " Retrieves arbitrary pointers to structs stored by qof_book_set_data."]
    pub fn qof_book_get_data(book: *const QofBook, key: *const gchar) -> gpointer;
}
unsafe extern "C" {
    #[doc = " Return whether the book is read only."]
    pub fn qof_book_is_readonly(book: *const QofBook) -> gboolean;
}
unsafe extern "C" {
    #[doc = " Mark the book as read only."]
    pub fn qof_book_mark_readonly(book: *mut QofBook);
}
unsafe extern "C" {
    #[doc = " Check if the book has had anything loaded into it."]
    pub fn qof_book_empty(book: *const QofBook) -> gboolean;
}
unsafe extern "C" {
    #[doc = " Returns flag indicating whether this book uses trading accounts"]
    pub fn qof_book_use_trading_accounts(book: *const QofBook) -> gboolean;
}
unsafe extern "C" {
    #[doc = " Returns TRUE if the auto-read-only feature should be used, otherwise\n FALSE. This is just a wrapper on qof_book_get_num_days_autoreadonly() == 0."]
    pub fn qof_book_uses_autoreadonly(book: *const QofBook) -> gboolean;
}
unsafe extern "C" {
    #[doc = " Returns the number of days for auto-read-only transactions. If zero,\n the auto-read-only feature should be disabled (and qof_book_uses_autoreadonly()\n returns FALSE)."]
    pub fn qof_book_get_num_days_autoreadonly(book: *const QofBook) -> gint;
}
unsafe extern "C" {
    #[doc = " Returns the GDate that is the threshold for auto-read-only. Any txn\n with posted-date lesser than this date should be considered read-only.\n\n If the auto-read-only feature is not used (qof_book_uses_autoreadonly()\n returns FALSE), NULL is returned here.\n\n The returned object was allocated newly; the caller must\n g_date_free() the object afterwards."]
    pub fn qof_book_get_autoreadonly_gdate(book: *const QofBook) -> *mut GDate;
}
unsafe extern "C" {
    #[doc = " Save the Invoice Report name / guid to be used as the default for printing\n  Invoices"]
    pub fn qof_book_set_default_invoice_report(
        book: *mut QofBook,
        guid: *const gchar,
        name: *const gchar,
    );
}
unsafe extern "C" {
    #[doc = " Get the guid of the Invoice Report to be used as the default for printing\n  Invoices"]
    pub fn qof_book_get_default_invoice_report_guid(book: *const QofBook) -> *mut gchar;
}
unsafe extern "C" {
    #[doc = " Get the name of the Invoice Report to be used as the default for printing\n  Invoices"]
    pub fn qof_book_get_default_invoice_report_name(book: *const QofBook) -> *mut gchar;
}
unsafe extern "C" {
    #[doc = " Get the length of time available to change the used Invoice Report\n  when printing Invoices"]
    pub fn qof_book_get_default_invoice_report_timeout(book: *const QofBook) -> gdouble;
}
unsafe extern "C" {
    #[doc = " Returns TRUE if this book uses split action field as the 'Num' field, FALSE\n  if it uses transaction number field"]
    pub fn qof_book_use_split_action_for_num_field(book: *const QofBook) -> gboolean;
}
unsafe extern "C" {
    #[doc = " Is the book shutting down?"]
    pub fn qof_book_shutting_down(book: *const QofBook) -> gboolean;
}
unsafe extern "C" {
    #[doc = " qof_book_not_saved() returns the value of the session_dirty flag,\n set when changes to any object in the book are committed\n (qof_backend->commit_edit has been called) and the backend hasn't\n yet written out the changes. (Note that SQL backends write commits\n out immediately; file backends don't, and use the flag to control\n an autosave timer.)"]
    pub fn qof_book_session_not_saved(book: *const QofBook) -> gboolean;
}
unsafe extern "C" {
    #[doc = " The qof_book_mark_saved() routine marks the book as having been\n    saved (to a file, to a database). Used by backends to mark the\n    notsaved flag as FALSE just after loading.  Can also be used\n    by the frontend when the used has said to abandon any changes."]
    pub fn qof_book_mark_session_saved(book: *mut QofBook);
}
unsafe extern "C" {
    #[doc = " The qof_book_mark_dirty() routine marks the book as having been\n    modified. It can be used by frontend when the used has made a\n    change at the book level."]
    pub fn qof_book_mark_session_dirty(book: *mut QofBook);
}
unsafe extern "C" {
    #[doc = " Retrieve the earliest modification time on the book."]
    pub fn qof_book_get_session_dirty_time(book: *const QofBook) -> time64;
}
unsafe extern "C" {
    #[doc = " Set the function to call when a book transitions from clean to\n    dirty, or vice versa."]
    pub fn qof_book_set_dirty_cb(book: *mut QofBook, cb: QofBookDirtyCB, user_data: gpointer);
}
unsafe extern "C" {
    #[doc = " This will get the named counter for this book. The return value is\n    -1 on error or the current value of the counter."]
    pub fn qof_book_get_counter(
        book: *mut QofBook,
        counter_name: *const ::std::os::raw::c_char,
    ) -> gint64;
}
unsafe extern "C" {
    #[doc = " This will increment the named counter for this book and format it.\n    The return value is NULL on error or the formatted (new) value of\n    the counter. The caller should free the result with g_gree."]
    pub fn qof_book_increment_and_format_counter(
        book: *mut QofBook,
        counter_name: *const ::std::os::raw::c_char,
    ) -> *mut gchar;
}
unsafe extern "C" {
    #[doc = " Validate a counter format string. If valid, returns a normalized format string,\n    that is whatever long int specifier was used will be replaced with the value of\n    the posix \"PRIx64\" macro.\n    If not valid returns NULL and optionally set an error message is a non-null\n    err_msg parameter was passed.\n    The caller should free the returned format string and  error message with g_free."]
    pub fn qof_book_normalize_counter_format(
        format: *const gchar,
        err_msg: *mut *mut gchar,
    ) -> *mut gchar;
}
unsafe extern "C" {
    #[doc = " Get the format string to use for the named counter.\n    The return value is NULL on error or the format string of the\n    counter. The returned string should be freed by the caller."]
    pub fn qof_book_get_counter_format(
        book: *const QofBook,
        counter_name: *const ::std::os::raw::c_char,
    ) -> *mut ::std::os::raw::c_char;
}
unsafe extern "C" {
    pub fn qof_book_get_string_option(
        book: *const QofBook,
        opt_name: *const ::std::os::raw::c_char,
    ) -> *const ::std::os::raw::c_char;
}
unsafe extern "C" {
    pub fn qof_book_set_string_option(
        book: *mut QofBook,
        opt_name: *const ::std::os::raw::c_char,
        opt_val: *const ::std::os::raw::c_char,
    );
}
unsafe extern "C" {
    pub fn qof_book_get_guid_option(book: *mut QofBook, path: *mut GSList) -> *const GncGUID;
}
unsafe extern "C" {
    pub fn qof_book_option_frame_delete(
        book: *mut QofBook,
        opt_name: *const ::std::os::raw::c_char,
    );
}
unsafe extern "C" {
    #[doc = " Access functions for reading and setting the used-features on this book."]
    pub fn qof_book_get_features(book: *mut QofBook) -> *mut GHashTable;
}
unsafe extern "C" {
    pub fn qof_book_unset_feature(book: *mut QofBook, key: *const gchar);
}
unsafe extern "C" {
    pub fn qof_book_set_feature(book: *mut QofBook, key: *const gchar, descr: *const gchar);
}
unsafe extern "C" {
    pub fn qof_book_begin_edit(book: *mut QofBook);
}
unsafe extern "C" {
    pub fn qof_book_commit_edit(book: *mut QofBook);
}
unsafe extern "C" {
    #[doc = " @ingroup KVP\n@{\n/\n/** Load a GncOptionsDB from KVP data.\n @param book: The book.\n @param load_cb: A callback function that does the loading.\n @param odb: The GncOptionDB to load."]
    pub fn qof_book_load_options(book: *mut QofBook, load_cb: GncOptionLoad, odb: *mut GncOptionDB);
}
unsafe extern "C" {
    #[doc = " Save a GncOptionsDB back to the book's KVP.\n @param book: The book.\n @param save_cb: A callback function that does the saving.\n @param odb: The GncOptionsDB to save from.\n @param clear: Should the GncOptionsDB be emptied after the save?"]
    pub fn qof_book_save_options(
        book: *mut QofBook,
        save_cb: GncOptionSave,
        odb: *mut GncOptionDB,
        clear: gboolean,
    );
}
unsafe extern "C" {
    #[doc = " Save a single option value.\n Used from Scheme, the KvpValue<-->SCM translation is handled by the functions\n in kvp-scm.c and automated by SWIG. The starting element is set as\n KVP_OPTION_PATH in qofbookslots.h.\n @param book: The book.\n @param value: The KvpValue to store.\n @param path: A GSList of keys which form a path under KVP_OPTION_PATH."]
    pub fn qof_book_set_option(book: *mut QofBook, value: *mut KvpValue, path: *mut GSList);
}
unsafe extern "C" {
    #[doc = " Read a single option value.\n Used from Scheme, the KvpValue<-->SCM translation is handled by the functions\n in kvp-scm.c and automated by SWIG. The starting element is set as\n KVP_OPTION_PATH in qofbookslots.h.\n @param book: The book.\n @param path: A GSList of keys which form a path under KVP_OPTION_PATH."]
    pub fn qof_book_get_option(book: *mut QofBook, path: *mut GSList) -> *mut KvpValue;
}
unsafe extern "C" {
    #[doc = " Delete the options.\n Primarily used from Scheme to clear out the options before saving a new set.\n @param book: The book.\n @param list: A GList of keys which from a path under KVP_OPTION_PATH.\n              If GList is Null, the whole option is deleted."]
    pub fn qof_book_options_delete(book: *mut QofBook, path: *mut GSList);
}
unsafe extern "C" {
    #[doc = " \\brief Initialise the Query Object Framework\n\nUse in place of separate init functions (like qof_query_init(),\netc.) to protect against future changes."]
    pub fn qof_init();
}
unsafe extern "C" {
    #[doc = " \\brief Safely close down the Query Object Framework\n\nUse in place of separate close / shutdown functions\n(like qof_query_shutdown(), etc.) to protect\nagainst future changes."]
    pub fn qof_close();
}
unsafe extern "C" {
    #[doc = " Search for an occurrence of the substring needle in the string\n haystack, ignoring case. Return TRUE if one is found or FALSE\n otherwise."]
    pub fn qof_utf8_substr_nocase(haystack: *const gchar, needle: *const gchar) -> gboolean;
}
unsafe extern "C" {
    #[doc = " Returns true if string s is a number, possibly surrounded by\n whitespace."]
    pub fn gnc_strisnum(s: *const gchar) -> gboolean;
}
unsafe extern "C" {
    #[doc = " begin_edit\n\n @param  inst: an instance of QofInstance\n\n The caller should use this macro first and then perform any other operations."]
    pub fn qof_begin_edit(inst: *mut QofInstance) -> gboolean;
}
unsafe extern "C" {
    #[doc = " part1 -- deal with the editlevel\n\n @param inst: an instance of QofInstance"]
    pub fn qof_commit_edit(inst: *mut QofInstance) -> gboolean;
}
unsafe extern "C" {
    #[doc = " part2 -- deal with the backend\n\n @param inst: an instance of QofInstance\n @param on_error: a function called if there is a backend error.\n                void (*on_error)(inst, QofBackendError)\n @param on_done: a function called after the commit is completed\n                successfully for an object which remained valid.\n                void (*on_done)(inst)\n @param on_free: a function called if the commit succeeded and the instance\n                 is to be freed.\n                void (*on_free)(inst)\n\n Note that only *one* callback will be called (or zero, if that\n callback is NULL).  In particular, 'on_done' will not be called for\n an object which is to be freed.\n\n Returns TRUE, if the commit succeeded, FALSE otherwise."]
    pub fn qof_commit_edit_part2(
        inst: *mut QofInstance,
        on_error: ::std::option::Option<
            unsafe extern "C" fn(arg1: *mut QofInstance, arg2: QofBackendError),
        >,
        on_done: ::std::option::Option<unsafe extern "C" fn(arg1: *mut QofInstance)>,
        on_free: ::std::option::Option<unsafe extern "C" fn(arg1: *mut QofInstance)>,
    ) -> gboolean;
}
pub type QofLogModule = *const gchar;
pub const QofLogLevel_QOF_LOG_FATAL: QofLogLevel = 4;
pub const QofLogLevel_QOF_LOG_ERROR: QofLogLevel = 8;
pub const QofLogLevel_QOF_LOG_WARNING: QofLogLevel = 16;
pub const QofLogLevel_QOF_LOG_MESSAGE: QofLogLevel = 32;
pub const QofLogLevel_QOF_LOG_INFO: QofLogLevel = 64;
pub const QofLogLevel_QOF_LOG_DEBUG: QofLogLevel = 128;
pub type QofLogLevel = ::std::os::raw::c_uint;
unsafe extern "C" {
    pub fn qof_log_level_to_string(lvl: QofLogLevel) -> *const ::std::os::raw::c_char;
}
unsafe extern "C" {
    pub fn qof_log_level_from_string(str_: *const ::std::os::raw::c_char) -> QofLogLevel;
}
unsafe extern "C" {
    #[doc = " Indents one level; see ENTER macro."]
    pub fn qof_log_indent();
}
unsafe extern "C" {
    #[doc = " De-dent one level, capped at 0; see LEAVE macro."]
    pub fn qof_log_dedent();
}
unsafe extern "C" {
    #[doc = " Initialize the error logging subsystem.  Defaults to a level-threshold of\n \"warning\", and logging to stderr."]
    pub fn qof_log_init();
}
unsafe extern "C" {
    #[doc = " Set the logging level of the given log_module."]
    pub fn qof_log_set_level(module: QofLogModule, level: QofLogLevel);
}
unsafe extern "C" {
    #[doc = " Specify an alternate log output, to pipe or file."]
    pub fn qof_log_set_file(outfile: *mut FILE);
}
unsafe extern "C" {
    #[doc = " Specify a filename for log output."]
    pub fn qof_log_init_filename(logfilename: *const gchar);
}
unsafe extern "C" {
    #[doc = " If @a log_to_filename is \"stderr\" or \"stdout\" (exactly,\n case-insensitive), then those special files are used; otherwise, the\n literal filename as given, as qof_log_init_filename(gchar*)"]
    pub fn qof_log_init_filename_special(log_to_filename: *const ::std::os::raw::c_char);
}
unsafe extern "C" {
    #[doc = " Parse a log-configuration file.  A GKeyFile-format file of the schema:\n @verbatim\n[levels]\n# log.ger.path=level\ngnc.engine.sx=debug\ngnc.gui.sx=debug\ngnc.import-export.qif.parse=debug\n[output]\n# to=[\"stderr\"|\"stdout\"|filename]\nto=stderr\n@endverbatim"]
    pub fn qof_log_parse_log_config(filename: *const ::std::os::raw::c_char);
}
unsafe extern "C" {
    #[doc = " Be nice, close the logfile if possible."]
    pub fn qof_log_shutdown();
}
unsafe extern "C" {
    #[doc = " Cleans up subroutine names. AIX/xlC has the habit of printing signatures\n not names; clean this up. On other operating systems, truncate name to\n QOF_LOG_MAX_CHARS chars."]
    pub fn qof_log_prettify(name: *const gchar) -> *const gchar;
}
unsafe extern "C" {
    #[doc = " Check to see if the given @a log_module is configured to log at the given\n @a log_level.  This implements the \"log.path.hierarchy\" logic."]
    pub fn qof_log_check(log_module: QofLogModule, log_level: QofLogLevel) -> gboolean;
}
unsafe extern "C" {
    #[doc = " Take entity, remove it from whatever collection its currently\n  in, and place it in a new collection.  To be used only for\n  moving entity from one book to another."]
    pub fn qof_collection_insert_entity(arg1: *mut QofCollection, arg2: *mut QofInstance);
}
unsafe extern "C" {
    #[doc = " reset value of dirty flag"]
    pub fn qof_collection_mark_clean(arg1: *mut QofCollection);
}
unsafe extern "C" {
    pub fn qof_collection_mark_dirty(arg1: *mut QofCollection);
}
unsafe extern "C" {
    pub fn qof_collection_print_dirty(col: *const QofCollection, dummy: gpointer);
}
#[doc = " Define the type of events allowed."]
pub type QofEventId = gint;
#[doc = " \\brief Handler invoked when an event is generated.\n\n @param ent:      Entity generating the event\n @param event_type:  The id of the event, including additional identifiers and\nthe older defaults.\n @param handler_data:   data supplied when handler was registered.\n @param event_data:   data to be supplied when handler is invoked."]
pub type QofEventHandler = ::std::option::Option<
    unsafe extern "C" fn(
        ent: *mut QofInstance,
        event_type: QofEventId,
        handler_data: gpointer,
        event_data: gpointer,
    ),
>;
unsafe extern "C" {
    #[doc = " \\brief Register a handler for events.\n\n @param handler:   handler to register\n @param handler_data: data provided when handler is invoked\n\n @return id identifying handler"]
    pub fn qof_event_register_handler(handler: QofEventHandler, handler_data: gpointer) -> gint;
}
unsafe extern "C" {
    #[doc = " \\brief Unregister an event handler.\n\n @param handler_id: the id of the handler to unregister"]
    pub fn qof_event_unregister_handler(handler_id: gint);
}
unsafe extern "C" {
    #[doc = " \\brief Invoke all registered event handlers using the given arguments.\n\nCertain default events are used by QOF:\n\n- QOF_EVENT_DEFAULT_CREATE events should be generated after the object\nhas been created and registered in the engine entity table.\n- QOF_EVENT_DEFAULT_MODIFY events should be generated whenever any data\nmember or submember (i.e., splits) is changed.\n- QOF_EVENT_DEFAULT_DESTROY events should be called before the object\nhas been destroyed or removed from the entity table.\n\nAny other events are entirely the concern of the application.\n\n\\note QofEventHandler routines do \\b NOT support generating\nevents from a GncGUID and QofIdType - you must specify a genuine QofInstance.\n\n@param entity:     the entity generating the event\n@param event_type: the name of the event.\n@param event_data: Data to be passed to the event handler just for\nthis one event. Can be NULL."]
    pub fn qof_event_gen(entity: *mut QofInstance, event_type: QofEventId, event_data: gpointer);
}
unsafe extern "C" {
    #[doc = " \\brief  Suspend all engine events.\n\n    This function may be called multiple times. To resume event generation,\n   an equal number of calls to qof_event_resume\n   must be made."]
    pub fn qof_event_suspend();
}
unsafe extern "C" {
    #[doc = " Resume engine event generation."]
    pub fn qof_event_resume();
}
#[doc = " This is the QofObject Class descriptor"]
pub type QofObject = _QofObject;
pub type QofForeachTypeCB =
    ::std::option::Option<unsafe extern "C" fn(type_: *mut QofObject, user_data: gpointer)>;
#[doc = " This is the QofObject Class descriptor"]
#[repr(C)]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub struct _QofObject {
    pub interface_version: gint,
    pub e_type: QofIdType,
    pub type_label: *const ::std::os::raw::c_char,
    #[doc = " Create a new instance of this object type.  This routine might be\n  NULL if the object type doesn't provide a way of creating new\n  instances."]
    pub create: ::std::option::Option<unsafe extern "C" fn(arg1: *mut QofBook) -> gpointer>,
    #[doc = " book_begin is called from within the Book routines to create\n module-specific hooks in a book whenever a book is created."]
    pub book_begin: ::std::option::Option<unsafe extern "C" fn(arg1: *mut QofBook)>,
    #[doc = " book_end is called when the book is being closed, to clean\n up (and free memory)."]
    pub book_end: ::std::option::Option<unsafe extern "C" fn(arg1: *mut QofBook)>,
    #[doc = " Determine if there are any dirty items in this book"]
    pub is_dirty:
        ::std::option::Option<unsafe extern "C" fn(arg1: *const QofCollection) -> gboolean>,
    #[doc = " Mark this object's book clean (for after a load)"]
    pub mark_clean: ::std::option::Option<unsafe extern "C" fn(arg1: *mut QofCollection)>,
    #[doc = " Traverse over all of the items in the collection, calling\n  the callback on each item.  The third argument can be any\n  arbitrary caller-supplied data, and is passed to the callback.\n  Although (*foreach) may be NULL, almost all objects should\n  provide this routine, as without it, little of interest can\n be done."]
    pub foreach: ::std::option::Option<
        unsafe extern "C" fn(
            arg1: *const QofCollection,
            arg2: QofInstanceForeachCB,
            arg3: gpointer,
        ),
    >,
    #[doc = " Given a particular item of this type, return a printable string."]
    pub printable: ::std::option::Option<
        unsafe extern "C" fn(instance: gpointer) -> *const ::std::os::raw::c_char,
    >,
    #[doc = " Given a pair of items of this type, this routine returns value\n  indicating which item is 'newer'.  This routine is used by storage\n  backends to determine if the local or the remote copy of a\n  particular item is the latest, 'uptodate' version.  Tis routine\n  should return an integer less than, equal to, or greater than zero\n  if 'instance_left' is found to be, respectively, earlier than, equal\n  to or later than than 'instance_right'."]
    pub version_cmp: ::std::option::Option<
        unsafe extern "C" fn(
            instance_left: gpointer,
            instance_right: gpointer,
        ) -> ::std::os::raw::c_int,
    >,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of _QofObject"][::std::mem::size_of::<_QofObject>() - 88usize];
    ["Alignment of _QofObject"][::std::mem::align_of::<_QofObject>() - 8usize];
    ["Offset of field: _QofObject::interface_version"]
        [::std::mem::offset_of!(_QofObject, interface_version) - 0usize];
    ["Offset of field: _QofObject::e_type"][::std::mem::offset_of!(_QofObject, e_type) - 8usize];
    ["Offset of field: _QofObject::type_label"]
        [::std::mem::offset_of!(_QofObject, type_label) - 16usize];
    ["Offset of field: _QofObject::create"][::std::mem::offset_of!(_QofObject, create) - 24usize];
    ["Offset of field: _QofObject::book_begin"]
        [::std::mem::offset_of!(_QofObject, book_begin) - 32usize];
    ["Offset of field: _QofObject::book_end"]
        [::std::mem::offset_of!(_QofObject, book_end) - 40usize];
    ["Offset of field: _QofObject::is_dirty"]
        [::std::mem::offset_of!(_QofObject, is_dirty) - 48usize];
    ["Offset of field: _QofObject::mark_clean"]
        [::std::mem::offset_of!(_QofObject, mark_clean) - 56usize];
    ["Offset of field: _QofObject::foreach"][::std::mem::offset_of!(_QofObject, foreach) - 64usize];
    ["Offset of field: _QofObject::printable"]
        [::std::mem::offset_of!(_QofObject, printable) - 72usize];
    ["Offset of field: _QofObject::version_cmp"]
        [::std::mem::offset_of!(_QofObject, version_cmp) - 80usize];
};
impl Default for _QofObject {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
unsafe extern "C" {
    #[doc = " @name Initialize the object registration subsystem */\n/** @{"]
    pub fn qof_object_initialize();
}
unsafe extern "C" {
    pub fn qof_object_shutdown();
}
unsafe extern "C" {
    #[doc = " Register new types of object objects"]
    pub fn qof_object_register(object: *const QofObject) -> gboolean;
}
unsafe extern "C" {
    #[doc = " Lookup an object definition"]
    pub fn qof_object_lookup(type_name: QofIdTypeConst) -> *const QofObject;
}
unsafe extern "C" {
    #[doc = " Create an instance of the indicated type, returning a pointer to that\n  instance.  This routine just calls the (*new) callback on the object\n  definition."]
    pub fn qof_object_new_instance(type_name: QofIdTypeConst, book: *mut QofBook) -> gpointer;
}
unsafe extern "C" {
    #[doc = " Get the printable label for a type.  This label is *not*\n translated; you must use _() on it if you want a translated version."]
    pub fn qof_object_get_type_label(type_name: QofIdTypeConst) -> *const ::std::os::raw::c_char;
}
unsafe extern "C" {
    #[doc = " @return a Human-readable string name for an instance"]
    pub fn qof_object_printable(
        type_name: QofIdTypeConst,
        instance: gpointer,
    ) -> *const ::std::os::raw::c_char;
}
unsafe extern "C" {
    #[doc = " Invoke the callback 'cb' on every object class definition.\n  The user_data pointer is passed back to the callback."]
    pub fn qof_object_foreach_type(cb: QofForeachTypeCB, user_data: gpointer);
}
unsafe extern "C" {
    #[doc = " Invoke the callback 'cb' on every instance ov a particular\n  object type.  It is presumed that the 'book' stores or somehow\n  identifies a colllection of instances; thus the callback will\n  be invoked only for those instances stored in the book."]
    pub fn qof_object_foreach(
        type_name: QofIdTypeConst,
        book: *mut QofBook,
        cb: QofInstanceForeachCB,
        user_data: gpointer,
    );
}
unsafe extern "C" {
    #[doc = " Invoke callback 'cb' on each instance in guid orted order"]
    pub fn qof_object_foreach_sorted(
        type_name: QofIdTypeConst,
        book: *mut QofBook,
        cb: QofInstanceForeachCB,
        user_data: gpointer,
    );
}
#[doc = " PREDICATE DATA TYPES: All the predicate data types are rolled up into\n the union type PredicateData.  The \"type\" field specifies which type\n the union is."]
pub type QofQueryPredData = _QofQueryPredData;
#[repr(u32)]
#[doc = " Standard Query comparators, for how to compare objects in a predicate.\n  Note that not all core types implement all comparators"]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub enum QofQueryCompare {
    QOF_COMPARE_LT = 1,
    QOF_COMPARE_LTE = 2,
    QOF_COMPARE_EQUAL = 3,
    QOF_COMPARE_GT = 4,
    QOF_COMPARE_GTE = 5,
    QOF_COMPARE_NEQ = 6,
    QOF_COMPARE_CONTAINS = 7,
    QOF_COMPARE_NCONTAINS = 8,
}
#[repr(u32)]
#[doc = " List of known core query data-types...\n  Each core query type defines it's set of optional \"comparator qualifiers\"."]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub enum QofStringMatch {
    QOF_STRING_MATCH_NORMAL = 1,
    QOF_STRING_MATCH_CASEINSENSITIVE = 2,
}
#[repr(u32)]
#[doc = " Comparisons for QOF_TYPE_DATE\n The QOF_DATE_MATCH_DAY comparison rounds the two time\n     values to mid-day and then compares these rounded values.\n The QOF_DATE_MATCH_NORMAL comparison matches the time values,\n     down to the second."]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub enum QofDateMatch {
    QOF_DATE_MATCH_NORMAL = 1,
    QOF_DATE_MATCH_DAY = 2,
}
#[repr(u32)]
#[doc = " Comparisons for QOF_TYPE_NUMERIC, QOF_TYPE_DEBCRED\n\n XXX Should be deprecated, or at least wrapped up as a convenience\n function,  this is based on the old bill gribble code, which assumed\n the amount was always positive, and then specified a funds-flow\n direction (credit, debit, or either).\n\n The point being that 'match credit' is equivalent to the compound\n predicate (amount >= 0) && (amount 'op' value) while the  'match\n debit' predicate is equivalent to (amount <= 0) && (abs(amount) 'op' value)"]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub enum QofNumericMatch {
    QOF_NUMERIC_MATCH_DEBIT = 1,
    QOF_NUMERIC_MATCH_CREDIT = 2,
    QOF_NUMERIC_MATCH_ANY = 3,
}
#[repr(u32)]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub enum QofGuidMatch {
    #[doc = " These expect a single object and expect the\n QofAccessFunc returns GncGUID*"]
    QOF_GUID_MATCH_ANY = 1,
    #[doc = " These expect a single object and expect the\n QofAccessFunc returns GncGUID*"]
    QOF_GUID_MATCH_NONE = 2,
    #[doc = " These expect a single object and expect the\n QofAccessFunc returns GncGUID*"]
    QOF_GUID_MATCH_NULL = 3,
    #[doc = " These expect a GList* of objects and calls the QofAccessFunc routine\n on each item in the list to obtain a GncGUID* for each object"]
    QOF_GUID_MATCH_ALL = 4,
    #[doc = " These expect a single object and expect the QofAccessFunc function\n to return a GList* of GncGUID* (the list is the property of the caller)"]
    QOF_GUID_MATCH_LIST_ANY = 5,
}
#[repr(u32)]
#[doc = " A CHAR type is for a RECNCell, Comparisons for QOF_TYPE_CHAR\n  'ANY' will match any character in the string.\n\n Match 'ANY' is a convenience/performance-enhanced predicate\n for the compound statement (value==char1) || (value==char2) || etc.\n Match 'NONE' is equivalent to\n (value != char1) && (value != char2) && etc."]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub enum QofCharMatch {
    QOF_CHAR_MATCH_ANY = 1,
    QOF_CHAR_MATCH_NONE = 2,
}
#[doc = " Head of Predicate Data structures.  All PData must start like this."]
#[repr(C)]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub struct _QofQueryPredData {
    pub type_name: QofType,
    pub how: QofQueryCompare,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of _QofQueryPredData"][::std::mem::size_of::<_QofQueryPredData>() - 16usize];
    ["Alignment of _QofQueryPredData"][::std::mem::align_of::<_QofQueryPredData>() - 8usize];
    ["Offset of field: _QofQueryPredData::type_name"]
        [::std::mem::offset_of!(_QofQueryPredData, type_name) - 0usize];
    ["Offset of field: _QofQueryPredData::how"]
        [::std::mem::offset_of!(_QofQueryPredData, how) - 8usize];
};
impl Default for _QofQueryPredData {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[doc = " A list of parameters (::QofIdType) used to describe a parameter to\n use in a predicate or when sorting"]
pub type QofQueryParamList = GSList;
unsafe extern "C" {
    #[doc = " @name Core Data Type Predicates\n@{"]
    pub fn qof_query_string_predicate(
        how: QofQueryCompare,
        str_: *const gchar,
        options: QofStringMatch,
        is_regex: gboolean,
    ) -> *mut QofQueryPredData;
}
unsafe extern "C" {
    pub fn qof_query_date_predicate(
        how: QofQueryCompare,
        options: QofDateMatch,
        date: time64,
    ) -> *mut QofQueryPredData;
}
unsafe extern "C" {
    pub fn qof_query_numeric_predicate(
        how: QofQueryCompare,
        options: QofNumericMatch,
        value: gnc_numeric,
    ) -> *mut QofQueryPredData;
}
unsafe extern "C" {
    pub fn qof_query_guid_predicate(
        options: QofGuidMatch,
        guids: *mut GList,
    ) -> *mut QofQueryPredData;
}
unsafe extern "C" {
    pub fn qof_query_int32_predicate(how: QofQueryCompare, val: gint32) -> *mut QofQueryPredData;
}
unsafe extern "C" {
    pub fn qof_query_int64_predicate(how: QofQueryCompare, val: gint64) -> *mut QofQueryPredData;
}
unsafe extern "C" {
    pub fn qof_query_double_predicate(how: QofQueryCompare, val: f64) -> *mut QofQueryPredData;
}
unsafe extern "C" {
    pub fn qof_query_boolean_predicate(
        how: QofQueryCompare,
        val: gboolean,
    ) -> *mut QofQueryPredData;
}
unsafe extern "C" {
    pub fn qof_query_char_predicate(
        options: QofCharMatch,
        chars: *const gchar,
    ) -> *mut QofQueryPredData;
}
unsafe extern "C" {
    pub fn qof_query_collect_predicate(
        options: QofGuidMatch,
        coll: *mut QofCollection,
    ) -> *mut QofQueryPredData;
}
unsafe extern "C" {
    pub fn qof_query_choice_predicate(
        options: QofGuidMatch,
        guids: *mut GList,
    ) -> *mut QofQueryPredData;
}
unsafe extern "C" {
    #[doc = " Copy a predicate."]
    pub fn qof_query_core_predicate_copy(pdata: *const QofQueryPredData) -> *mut QofQueryPredData;
}
unsafe extern "C" {
    #[doc = " Destroy a predicate."]
    pub fn qof_query_core_predicate_free(pdata: *mut QofQueryPredData);
}
unsafe extern "C" {
    #[doc = " Retrieve a predicate."]
    pub fn qof_query_date_predicate_get_date(
        pd: *const QofQueryPredData,
        date: *mut time64,
    ) -> gboolean;
}
unsafe extern "C" {
    pub fn qof_query_char_predicate_get_char(
        pd: *const QofQueryPredData,
        chars: *mut *mut ::std::os::raw::c_char,
    ) -> gboolean;
}
unsafe extern "C" {
    #[doc = " Return a printable string for a core data object.  Caller needs\n  to g_free() the returned string."]
    pub fn qof_query_core_to_string(
        arg1: QofType,
        object: gpointer,
        getter: *mut QofParam,
    ) -> *mut ::std::os::raw::c_char;
}
unsafe extern "C" {
    #[doc = " Compare two parameter(strings) as if they are numbers!\n  the two objects, a and b, are the objects being compared\n  this_param is the QofParam for this parameter in the objects"]
    pub fn qof_string_number_compare_func(
        a: gpointer,
        b: gpointer,
        options: gint,
        this_param: *mut QofParam,
    ) -> ::std::os::raw::c_int;
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _QofQuery {
    _unused: [u8; 0],
}
#[doc = " A Query"]
pub type QofQuery = _QofQuery;
#[repr(u32)]
#[doc = " Query Term Operators, for combining Query Terms"]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub enum QofQueryOp {
    QOF_QUERY_AND = 1,
    QOF_QUERY_OR = 2,
    QOF_QUERY_NAND = 3,
    QOF_QUERY_NOR = 4,
    QOF_QUERY_XOR = 5,
}
unsafe extern "C" {
    #[doc = " Subsystem initialization and shutdown. Call init() once\n  to initialize the query subsystem; call shutdown() to free\n  up any resources associated with the query subsystem.\n  Typically called during application startup, shutdown."]
    pub fn qof_query_init();
}
unsafe extern "C" {
    pub fn qof_query_shutdown();
}
unsafe extern "C" {
    pub fn qof_query_build_param_list(
        param: *const ::std::os::raw::c_char,
        ...
    ) -> *mut QofQueryParamList;
}
unsafe extern "C" {
    #[doc = " Create a new query.\n  Before running the query, a 'search-for' type must be set\n  otherwise nothing will be returned.  The results of the query\n  is a list of the indicated search-for type.\n\n  Allocates and initializes a Query structure which must be\n  freed by the user with qof_query_destroy().  A newly-allocated\n  QofQuery object matches nothing (qof_query_run() will return NULL)."]
    pub fn qof_query_create() -> *mut QofQuery;
}
unsafe extern "C" {
    pub fn qof_query_create_for(obj_type: QofIdTypeConst) -> *mut QofQuery;
}
unsafe extern "C" {
    #[doc = " Frees the resources associate with a Query object."]
    pub fn qof_query_destroy(q: *mut QofQuery);
}
unsafe extern "C" {
    #[doc = " Set the object type to be searched for.  The results of\n  performing the query will be a list of this obj_type."]
    pub fn qof_query_search_for(query: *mut QofQuery, obj_type: QofIdTypeConst);
}
unsafe extern "C" {
    #[doc = " Set the book to be searched.  Books contain/identify collections\n  of objects; the search will be performed over those books\n  specified with this function.  If no books are set, no results\n  will be returned (since there is nothing to search over).\n\n  You can search multiple books.  To specify multiple books, call\n  this function multiple times with different arguments.\n XXX needed qof_query_clear_books() to reset the list ..."]
    pub fn qof_query_set_book(q: *mut QofQuery, book: *mut QofBook);
}
unsafe extern "C" {
    #[doc = " This is the general function that adds a new Query Term to a query.\n It will find the 'obj_type' object of the search item and compare\n the 'param_list' parameter to the predicate data via the comparator.\n\n The param_list is a recursive list of parameters.  For example, you\n can say 'split->memo' by creating a list of one element, \"SPLIT_MEMO\".\n You can say 'split->account->name' by creating a list of two elements,\n \"SPLIT_ACCOUNT\" and \"ACCOUNT_NAME\".  The list becomes the property of\n the Query.\n\n For example:\n\n acct_name_pred_data = make_string_pred_data(QOF_STRING_MATCH_CASEINSENSITIVE,\n                                          account_name);\n param_list = make_list (SPLIT_ACCOUNT, ACCOUNT_NAME, NULL);\n qof_query_add_term (query, param_list, QOF_COMPARE_EQUAL,\n                    acct_name_pred_data, QOF_QUERY_AND);\n\n Please note that QofQuery does not, at this time, support joins.\n That is, one cannot specify a predicate that is a parameter list.\n Put another way, one cannot search for objects where\n   obja->thingy == objb->stuff"]
    pub fn qof_query_add_term(
        query: *mut QofQuery,
        param_list: *mut QofQueryParamList,
        pred_data: *mut QofQueryPredData,
        op: QofQueryOp,
    );
}
unsafe extern "C" {
    #[doc = " DOCUMENT ME !!"]
    pub fn qof_query_add_guid_match(
        q: *mut QofQuery,
        param_list: *mut QofQueryParamList,
        guid: *const GncGUID,
        op: QofQueryOp,
    );
}
unsafe extern "C" {
    #[doc = " DOCUMENT ME !!"]
    pub fn qof_query_add_guid_list_match(
        q: *mut QofQuery,
        param_list: *mut QofQueryParamList,
        guid_list: *mut GList,
        options: QofGuidMatch,
        op: QofQueryOp,
    );
}
unsafe extern "C" {
    #[doc = " Handy-dandy convenience routines, avoids having to create\n a separate predicate for boolean matches.  We might want to\n create handy-dandy sugar routines for the other predicate types\n as well."]
    pub fn qof_query_add_boolean_match(
        q: *mut QofQuery,
        param_list: *mut QofQueryParamList,
        value: gboolean,
        op: QofQueryOp,
    );
}
unsafe extern "C" {
    #[doc = " Perform the query, return the results.\n  The returned list is a list of the 'search-for' type that was\n  previously set with the qof_query_search_for() or the\n  qof_query_create_for() routines.  The returned list will have\n  been sorted using the indicated sort order, and trimmed to the\n  max_results length.\n\n  Do NOT free the resulting list.  This list is managed internally\n  by QofQuery."]
    pub fn qof_query_run(query: *mut QofQuery) -> *mut GList;
}
unsafe extern "C" {
    #[doc = " Return the results of the last query, without causing the query to\n  be re-run.  Do NOT free the resulting list.  This list is managed\n  internally by QofQuery."]
    pub fn qof_query_last_run(query: *mut QofQuery) -> *mut GList;
}
unsafe extern "C" {
    #[doc = " Perform a subquery, return the results.\n  Instead of running over a book, the subquery runs over the results\n  of the primary query.\n\n  Do NOT free the resulting list.  This list is managed internally\n  by QofQuery."]
    pub fn qof_query_run_subquery(
        subquery: *mut QofQuery,
        primary_query: *const QofQuery,
    ) -> *mut GList;
}
unsafe extern "C" {
    #[doc = " Remove all query terms from query.  query matches nothing\n  after qof_query_clear()."]
    pub fn qof_query_clear(query: *mut QofQuery);
}
unsafe extern "C" {
    #[doc = " Remove query terms of a particular type from q.  The \"type\" of a term\n  is determined by the type of data that gets passed to the predicate\n  function.\n XXX ??? Huh? remove anything of that predicate type, or just\n the particular predicate ?"]
    pub fn qof_query_purge_terms(q: *mut QofQuery, param_list: *mut QofQueryParamList);
}
unsafe extern "C" {
    #[doc = " Return boolean FALSE if there are no terms in the query\n  Can be used as a predicate to see if the query has been\n  initialized (return value > 0) or is \"blank\" (return value == 0)."]
    pub fn qof_query_has_terms(q: *mut QofQuery) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    #[doc = " Return the number of terms in the canonical form of the query."]
    pub fn qof_query_num_terms(q: *mut QofQuery) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    #[doc = " DOCUMENT ME !!"]
    pub fn qof_query_has_term_type(
        q: *mut QofQuery,
        term_param: *mut QofQueryParamList,
    ) -> gboolean;
}
unsafe extern "C" {
    pub fn qof_query_get_term_type(
        q: *mut QofQuery,
        term_param: *mut QofQueryParamList,
    ) -> *mut GSList;
}
unsafe extern "C" {
    #[doc = " Make a copy of the indicated query"]
    pub fn qof_query_copy(q: *mut QofQuery) -> *mut QofQuery;
}
unsafe extern "C" {
    #[doc = " Make a copy of the indicated query, inverting the sense\n  of the search.  In other words, if the original query search\n  for all objects with a certain condition, the inverted query\n  will search for all object with NOT that condition.  The union\n  of the results returned by the original and inverted queries\n  equals the set of all searched objects. These to sets are\n  disjoint (share no members in common).\n\n  This will return a newly allocated QofQuery object, or NULL\n  on error. Free it with qof_query_destroy() when no longer needed."]
    pub fn qof_query_invert(q: *mut QofQuery) -> *mut QofQuery;
}
unsafe extern "C" {
    #[doc = " Combine two queries together using the Boolean set (logical)\n  operator 'op'.  For example, if the operator 'op' is set to\n  QUERY_AND, then the set of results returned by the query will\n  will be the Boolean set intersection of the results returned\n  by q1 and q2.  Similarly,  QUERY_OR maps to set union, etc.\n\n  Both queries must have compatible\n  search-types.  If both queries are set, they must search for the\n  same object type.  If only one is set, the resulting query will\n  search for the set type.  If neither query has the search-type set,\n  the result will be unset as well.\n\n  This will return a newly allocated QofQuery object, or NULL on\n  error. Free it with qof_query_destroy() when no longer needed.\n  Note that if either input query is NULL then the returned query is\n  NOT newly allocated -- it will return the non-NULL query.  You\n  only need to call this function when both q1 and q2 are non-NULL."]
    pub fn qof_query_merge(q1: *mut QofQuery, q2: *mut QofQuery, op: QofQueryOp) -> *mut QofQuery;
}
unsafe extern "C" {
    #[doc = " Like qof_query_merge, but this will merge a copy of q2 into q1.\n   q2 remains unchanged."]
    pub fn qof_query_merge_in_place(q1: *mut QofQuery, q2: *mut QofQuery, op: QofQueryOp);
}
unsafe extern "C" {
    #[doc = " When a query is run, the results are sorted before being returned.\n This routine can be used to set the parameters on which the sort will\n be performed.  Two objects in the result list will be compared using\n the 'primary_sort_params', and sorted based on that order.  If the\n comparison shows that they are equal, then the\n 'secondary_sort_params' will be used.  If still equal, then the\n tertiary parameters will be compared.  Any or all of these parameter\n lists may be NULL.  Any of these parameter lists may be set to\n QUERY_DEFAULT_SORT.\n\n Note that if there are more results than the 'max-results' value,\n then only the *last* max-results will be returned.  For example,\n if the sort is set to be increasing date order, then only the\n objects with the most recent dates will be returned.\n\n The input lists become the property of QofQuery and are managed\n by it.   They will be freed when the query is destroyed (or when\n new lists are set)."]
    pub fn qof_query_set_sort_order(
        q: *mut QofQuery,
        primary_sort_params: *mut QofQueryParamList,
        secondary_sort_params: *mut QofQueryParamList,
        tertiary_sort_params: *mut QofQueryParamList,
    );
}
unsafe extern "C" {
    pub fn qof_query_set_sort_options(q: *mut QofQuery, prim_op: gint, sec_op: gint, tert_op: gint);
}
unsafe extern "C" {
    #[doc = " When a query is run, the results are sorted before being returned.\n This routine can be used to control the direction of the ordering.\n A value of TRUE indicates the sort will be in increasing order,\n a value of FALSE will order results in decreasing order.\n\n Note that if there are more results than the 'max-results' value,\n then only the *last* max-results will be returned.  For example,\n if the sort is set to be increasing date order, then only the\n objects with the most recent dates will be returned."]
    pub fn qof_query_set_sort_increasing(
        q: *mut QofQuery,
        prim_inc: gboolean,
        sec_inc: gboolean,
        tert_inc: gboolean,
    );
}
unsafe extern "C" {
    #[doc = " Set the maximum number of results that should be returned.\n If 'max-results' is set to -1, then all of the results are\n returned.  If there are more results than 'max-results',\n then the result list is trimmed.  Note that there is an\n important interplay between 'max-results' and the sort order:\n only the last bit of results are returned.  For example,\n if the sort order is set to be increasing date order, then\n only the objects with the most recent dates will be returned."]
    pub fn qof_query_set_max_results(q: *mut QofQuery, n: ::std::os::raw::c_int);
}
unsafe extern "C" {
    #[doc = " Compare two queries for equality.\n Query terms are compared each to each.\n This is a simplistic\n implementation -- logical equivalences between different\n and/or trees are ignored."]
    pub fn qof_query_equal(q1: *const QofQuery, q2: *const QofQuery) -> gboolean;
}
unsafe extern "C" {
    pub fn qof_query_get_search_for(q: *const QofQuery) -> QofIdType;
}
unsafe extern "C" {
    #[doc = " Return the list of books we're using"]
    pub fn qof_query_get_books(q: *mut QofQuery) -> *mut GList;
}
#[repr(u32)]
#[doc = " Mode for opening sessions."]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub enum SessionOpenMode {
    SESSION_NORMAL_OPEN = 0,
    #[doc = " Open will fail if the URI doesn't exist or is locked."]
    SESSION_NEW_STORE = 2,
    #[doc = " Create a new store at the URI. It will fail if the store already exists and is found to contain data that would be overwritten."]
    SESSION_NEW_OVERWRITE = 3,
    #[doc = " Create a new store at the URI even if a store already exists there."]
    SESSION_READ_ONLY = 4,
    #[doc = " Open the session read-only, ignoring any existing lock and not creating one if the URI isn't locked."]
    SESSION_BREAK_LOCK = 5,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct QofSessionImpl {
    _unused: [u8; 0],
}
pub type QofSession = QofSessionImpl;
unsafe extern "C" {
    pub fn qof_session_new(book: *mut QofBook) -> *mut QofSession;
}
unsafe extern "C" {
    pub fn qof_session_destroy(session: *mut QofSession);
}
unsafe extern "C" {
    #[doc = " The qof_session_swap_data () method swaps the book of\n    the two given sessions. It is useful\n    for 'Save As' type functionality."]
    pub fn qof_session_swap_data(session_1: *mut QofSession, session_2: *mut QofSession);
}
unsafe extern "C" {
    #[doc = " Begins a new session.\n\n @param session Newly-allocated with qof_session_new.\n\n @param uri must be a string in the form of a URI/URL. The access method\n specified depends on the loaded backends. Paths may be relative or\n absolute.  If the path is relative, that is if the argument is\n \"file://somefile.xml\", then the current working directory is\n assumed. Customized backends can choose to search other\n application-specific directories or URI schemes as well.\n\n @param mode The SessionOpenMode.\n\n @par ==== SessionOpenMode ====\n `SESSION_NORMAL_OPEN`: Find an existing file or database at the provided uri and\n open it if it is unlocked. If it is locked post a QOF_BACKEND_LOCKED error.\n @par\n `SESSION_NEW_STORE`: Check for an existing file or database at the provided\n uri and if none is found, create it. If the file or database exists post a\n QOF_BACKED_STORE_EXISTS and return.\n @par\n `SESSION_NEW_OVERWRITE`: Create a new file or database at the provided uri,\n deleting any existing file or database.\n @par\n `SESSION_READ_ONLY`: Find an existing file or database and open it without\n disturbing the lock if it exists or setting one if not. This will also set a\n flag on the book that will prevent many elements from being edited and will\n prevent the backend from saving any edits.\n @par\n `SESSION_BREAK_LOCK`: Find an existing file or database, lock it, and open\n it. If there is already a lock replace it with a new one for this session.\n\n @par ==== Errors ====\n This function signals failure by queuing errors. After it completes use\n qof_session_get_error() and test that the value is `ERROR_BACKEND_NONE` to\n determine that the session began successfully."]
    pub fn qof_session_begin(
        session: *mut QofSession,
        new_uri: *const ::std::os::raw::c_char,
        mode: SessionOpenMode,
    );
}
#[doc = " The qof_session_load() method causes the QofBook to be made ready to\n    to use with this URL/datastore.   When the URL points at a file,\n    then this routine would load the data from the file.  With remote\n    backends, e.g. network or SQL, this would load only enough data\n    to make the book actually usable; it would not cause *all* of the\n    data to be loaded.\n\n XXX the current design tries to accommodate multiple calls to 'load'\n for each session, each time wiping out the old books; this seems\n wrong to me, and should be restricted to allow only one load per\n session."]
pub type QofPercentageFunc = ::std::option::Option<
    unsafe extern "C" fn(message: *const ::std::os::raw::c_char, percent: f64),
>;
unsafe extern "C" {
    pub fn qof_session_load(session: *mut QofSession, percentage_func: QofPercentageFunc);
}
unsafe extern "C" {
    #[doc = " @name Session Errors\n@{ */\n/** The qof_session_get_error() routine can be used to obtain the reason\n    for any failure.  Calling this routine returns the current error."]
    pub fn qof_session_get_error(session: *mut QofSession) -> QofBackendError;
}
unsafe extern "C" {
    pub fn qof_session_get_error_message(
        session: *const QofSession,
    ) -> *const ::std::os::raw::c_char;
}
unsafe extern "C" {
    #[doc = " The qof_session_pop_error() routine can be used to obtain the reason\n    for any failure.  Calling this routine resets the error value.\n\n    This routine allows an implementation of multiple error values,\n    e.g. in a stack, where this routine pops the top value. The current\n    implementation has a stack that is one-deep.\n\n    See qofbackend.h for a listing of returned errors."]
    pub fn qof_session_pop_error(session: *mut QofSession) -> QofBackendError;
}
unsafe extern "C" {
    #[doc = " Returns the QofBook of this session."]
    pub fn qof_session_get_book(session: *const QofSession) -> *mut QofBook;
}
unsafe extern "C" {
    #[doc = "    The qof_session_get_file_path() routine returns the fully-qualified file\n    path for the session. That is, if a relative or partial filename\n    was for the session, then it had to have been fully resolved to\n    open the session. This routine returns the result of this resolution.\n    The path is always guaranteed to reside in the local file system,\n    even if the session itself was opened as a URL.  (currently, the\n    filepath is derived from the url by substituting commas for\n    slashes).\n\n    The qof_session_get_url() routine returns the url that was opened.\n    URL's for local files take the form of\n    file:/some/where/some/file.gml"]
    pub fn qof_session_get_file_path(session: *const QofSession) -> *const ::std::os::raw::c_char;
}
unsafe extern "C" {
    pub fn qof_session_get_url(session: *const QofSession) -> *const ::std::os::raw::c_char;
}
unsafe extern "C" {
    pub fn qof_session_save_in_progress(session: *const QofSession) -> gboolean;
}
unsafe extern "C" {
    #[doc = " Returns the qof session's backend."]
    pub fn qof_session_get_backend(session: *const QofSession) -> *mut QofBackend;
}
unsafe extern "C" {
    #[doc = " The qof_session_save() method will commit all changes that have been\n    made to the session. For the file backend, this is nothing\n    more than a write to the file of the current Accounts & etc.\n    For the SQL backend, this is typically a no-op (since all data\n    has already been written out to the database."]
    pub fn qof_session_save(session: *mut QofSession, percentage_func: QofPercentageFunc);
}
unsafe extern "C" {
    #[doc = " A special version of save used in the sql backend which moves the\n existing tables aside, then saves everything to new tables, then\n deletes the old tables after the save is completed without\n error. If there are errors, it removes the old tables and renames\n the new tables back."]
    pub fn qof_session_safe_save(session: *mut QofSession, percentage_func: QofPercentageFunc);
}
unsafe extern "C" {
    #[doc = " The qof_session_end() method will release the session lock. For the\n    file backend, it will *not* save the data to a file. Thus,\n    this method acts as an \"abort\" or \"rollback\" primitive.  However,\n    for other backends, such as the sql backend, the data would have\n    been written out before this, and so this routines wouldn't\n    roll-back anything; it would just shut the connection."]
    pub fn qof_session_end(session: *mut QofSession);
}
unsafe extern "C" {
    #[doc = " @name Event Handling\n\n@{ */\n/** The qof_session_events_pending() method will return TRUE if the\n  backend has pending events which must be processed to bring\n  the engine up to date with the backend."]
    pub fn qof_session_events_pending(session: *const QofSession) -> gboolean;
}
unsafe extern "C" {
    #[doc = "  The qof_session_process_events() method will process any events\n   indicated by the qof_session_events_pending() method. It returns\n   TRUE if the engine was modified while engine events were suspended."]
    pub fn qof_session_process_events(session: *mut QofSession) -> gboolean;
}
unsafe extern "C" {
    #[doc = " @}"]
    pub fn qof_session_export(
        tmp_session: *mut QofSession,
        real_session: *mut QofSession,
        percentage_func: QofPercentageFunc,
    ) -> gboolean;
}
unsafe extern "C" {
    #[doc = " Return a list of strings for the registered access methods. The owner is\n  responsible for freeing the list but not the strings."]
    pub fn qof_backend_get_registered_access_method_list() -> *mut GList;
}
unsafe extern "C" {
    #[doc = " Ensure all of the data is loaded from the session."]
    pub fn qof_session_ensure_all_data_loaded(session: *mut QofSession);
}
unsafe extern "C" {
    #[doc = " Initialize the string cache"]
    pub fn qof_string_cache_init();
}
unsafe extern "C" {
    #[doc = " Destroy the qof_string_cache"]
    pub fn qof_string_cache_destroy();
}
unsafe extern "C" {
    #[doc = " You can use this function as a destroy notifier for a GHashTable\nthat uses common strings as keys (or values, for that matter.)"]
    pub fn qof_string_cache_remove(key: *const ::std::os::raw::c_char);
}
unsafe extern "C" {
    #[doc = " You can use this function with g_hash_table_insert(), for the key\n(or value), as long as you use the destroy notifier above."]
    pub fn qof_string_cache_insert(
        key: *const ::std::os::raw::c_char,
    ) -> *const ::std::os::raw::c_char;
}
unsafe extern "C" {
    #[doc = " Same as CACHE_REPLACE below, but safe to call from C++."]
    pub fn qof_string_cache_replace(
        dst: *const ::std::os::raw::c_char,
        src: *const ::std::os::raw::c_char,
    ) -> *const ::std::os::raw::c_char;
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct account_s {
    _unused: [u8; 0],
}
#[doc = " @brief Account in Gnucash.\n This is the typename for an account. The actual structure is\n defined in the private header AccountP.hpp, but no one outside the\n engine should include that file. Instead, access that data only\n through the functions in Account.h ."]
pub type Account = account_s;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct split_s {
    _unused: [u8; 0],
}
#[doc = " @brief Split in Gnucash.\n A \"split\" is more commonly referred to as a \"entry\" in a\n \"transaction\". Each split belongs to one Account and one\n Transaction. The split is one out of several parts a Transaction is\n divided into.\n\n This is the typename for a split. The actual structure is defined\n in the private header TransactionP.hpp, but no one outside the engine\n should include that file. Instead, access that data only through\n the functions in Transaction.h ."]
pub type Split = split_s;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct transaction_s {
    _unused: [u8; 0],
}
#[doc = " @brief Transaction in Gnucash.\n A Transaction is a piece of business done; the transfer of money\n from one account to one or more other accounts. Each Transaction is\n divided into one or more Splits (usually two).\n\n This is the typename for a transaction. The actual structure is\n defined in the private header TransactionP.hpp, but no one outside\n the engine should include that file. Instead, access that data only\n through the functions in Transaction.h ."]
pub type Transaction = transaction_s;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct gnc_commodity_s {
    _unused: [u8; 0],
}
#[doc = " @brief An article that is bought and sold.\n A Commodity is the most general term of what an account keeps track\n of. Usually this is a monetary currency, but it can also be a stock\n share or even a precious metal. Every account keeps track of\n exactly one gnc_commodity.\n\n (Up to version 1.6.x, we used to have currencies and\n securities. Now these concepts have been merged into this\n gnc_commodity. See the comments at xaccAccountSetCommodity() for\n more about that.)\n\n This is the typename for a gnc_commodity. The actual structure is\n defined in a private source file. For accessing that data, only use\n the functions in gnc-commodity.h ."]
pub type gnc_commodity = gnc_commodity_s;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct gnc_commodity_namespace_s {
    _unused: [u8; 0],
}
#[doc = " @brief A gnc_commodity_namespace is an collection of commodities."]
pub type gnc_commodity_namespace = gnc_commodity_namespace_s;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct gnc_commodity_table_s {
    _unused: [u8; 0],
}
#[doc = " @brief A gnc_commodity_table is a database of commodity info."]
pub type gnc_commodity_table = gnc_commodity_table_s;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct gnc_lot_s {
    _unused: [u8; 0],
}
#[doc = " @brief Identifies that something sold at one time was bought at another.\n A GNCLot provides a way of tracking physical items as they are\n bought and sold in different transactions.  By identifying\n the individual, underlying physical objects, it provides the\n needed framework for implementing depreciation, capital gains,\n inventory control and invoices.\n\n See the file src/doc/lots.txt for implementation overview."]
pub type GNCLot = gnc_lot_s;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct gnc_price_s {
    _unused: [u8; 0],
}
#[doc = " @brief Price of commodity on a given date.\n A GNCPrice encapsulates price information: the cost of a commodity\n expressed as a currency, on a given date.  It also holds info about\n the provenance of the price: where it came from, its general validity."]
pub type GNCPrice = gnc_price_s;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct gnc_quote_source_s {
    _unused: [u8; 0],
}
pub type gnc_quote_source = gnc_quote_source_s;
#[doc = " GList of GNCLots"]
pub type LotList = GList;
#[doc = " GList of Split"]
pub type SplitList = GList;
pub type EngineCommitErrorCallback =
    ::std::option::Option<unsafe extern "C" fn(data: gpointer, errcode: QofBackendError)>;
pub type TransactionCallback = ::std::option::Option<
    unsafe extern "C" fn(t: *mut Transaction, data: *mut ::std::os::raw::c_void) -> gint,
>;
#[doc = " Function type for init hooks in the engine."]
pub type gnc_engine_init_hook_t = ::std::option::Option<
    unsafe extern "C" fn(arg1: ::std::os::raw::c_int, arg2: *mut *mut ::std::os::raw::c_char),
>;
unsafe extern "C" {
    #[doc = " gnc_engine_init should be called before gnc engine\n functions can be used."]
    pub fn gnc_engine_init(argc: ::std::os::raw::c_int, argv: *mut *mut ::std::os::raw::c_char);
}
unsafe extern "C" {
    #[doc = " This is the statically linked-in version of gnc_engine_init. It is\n identical to that function except that it doesn't load any backend library."]
    pub fn gnc_engine_init_static(
        argc: ::std::os::raw::c_int,
        argv: *mut *mut ::std::os::raw::c_char,
    );
}
unsafe extern "C" {
    #[doc = " Called to shutdown the engine."]
    pub fn gnc_engine_shutdown();
}
unsafe extern "C" {
    #[doc = " check the engine is fully initialized"]
    pub fn gnc_engine_is_initialized() -> gboolean;
}
unsafe extern "C" {
    #[doc = " enable default log modules"]
    pub fn gnc_log_default();
}
unsafe extern "C" {
    #[doc = " Pass a function pointer to gnc_engine_add_init_hook and\n it will be called during the evaluation of gnc_engine_init"]
    pub fn gnc_engine_add_init_hook(hook: gnc_engine_init_hook_t);
}
unsafe extern "C" {
    #[doc = " Set a callback function to be called in case an engine commit\n fails"]
    pub fn gnc_engine_add_commit_error_callback(cb: EngineCommitErrorCallback, data: gpointer);
}
unsafe extern "C" {
    pub fn gnc_engine_signal_commit_error(errcode: QofBackendError);
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct gncpolicy_s {
    _unused: [u8; 0],
}
pub type GNCPolicy = gncpolicy_s;
unsafe extern "C" {
    #[doc = " First-in, First-out Policy\n  This policy will create FIFO Lots.  FIFO Lots have the following\n  properties:\n  -- The lot is started with the earliest posted split that isn't\n     a part of another lot already.\n  -- Splits are added to the lot in date order, with earliest splits\n     added first.\n  -- All splits in the lot share the same transaction currency as\n     the split that opened the lot"]
    pub fn xaccGetFIFOPolicy() -> *mut GNCPolicy;
}
pub type AccountCb = ::std::option::Option<unsafe extern "C" fn(a: *mut Account, data: gpointer)>;
pub type AccountCb2 =
    ::std::option::Option<unsafe extern "C" fn(a: *mut Account, data: gpointer) -> gpointer>;
#[repr(C)]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub struct AccountClass {
    pub parent_class: QofInstanceClass,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of AccountClass"][::std::mem::size_of::<AccountClass>() - 160usize];
    ["Alignment of AccountClass"][::std::mem::align_of::<AccountClass>() - 8usize];
    ["Offset of field: AccountClass::parent_class"]
        [::std::mem::offset_of!(AccountClass, parent_class) - 0usize];
};
impl Default for AccountClass {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
unsafe extern "C" {
    #[doc = " Returns the GType type system description of the Account class.\n\n This must not be confused with the \\ref GNCAccountType as returned\n by xaccAccountGetType()."]
    pub fn gnc_account_get_type() -> GType;
}
impl GNCAccountType {
    pub const ACCT_TYPE_NONE: GNCAccountType = GNCAccountType::ACCT_TYPE_INVALID;
}
impl GNCAccountType {
    pub const ACCT_TYPE_CHECKING: GNCAccountType = GNCAccountType::NUM_ACCOUNT_TYPES;
}
#[repr(i32)]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub enum GNCAccountType {
    #[doc = "< Not a type"]
    ACCT_TYPE_INVALID = -1,
    #[doc = "< The bank account type denotes a savings\n   or checking account held at a bank.\n   Often interest bearing."]
    ACCT_TYPE_BANK = 0,
    #[doc = "< The cash account type is used to denote a\n   shoe-box or pillowcase stuffed with *\n   cash."]
    ACCT_TYPE_CASH = 1,
    #[doc = "< The Credit card account is used to denote\n   credit (e.g. amex) and debit (e.g. visa,\n   mastercard) card accounts"]
    ACCT_TYPE_CREDIT = 3,
    #[doc = "< asset (and liability) accounts indicate\n   generic, generalized accounts that are\n   none of the above."]
    ACCT_TYPE_ASSET = 2,
    #[doc = "< liability (and asset) accounts indicate\n   generic, generalized accounts that are\n   none of the above."]
    ACCT_TYPE_LIABILITY = 4,
    #[doc = "< Stock accounts will typically be shown in\n   registers which show three columns:\n   price, number of shares, and value."]
    ACCT_TYPE_STOCK = 5,
    #[doc = "< Mutual Fund accounts will typically be\n   shown in registers which show three\n   columns: price, number of shares, and\n   value."]
    ACCT_TYPE_MUTUAL = 6,
    #[doc = "< The currency account type indicates that\n   the account is a currency trading\n   account.  In many ways, a currency\n   trading account is like a stock *\n   trading account. It is shown in the\n   register with three columns: price,\n   number of shares, and value. Note:\n   Since version 1.7.0, this account is *\n   no longer needed to exchange currencies\n   between accounts, so this type is\n   DEPRECATED."]
    ACCT_TYPE_CURRENCY = 7,
    #[doc = "< Income accounts are used to denote\n   income"]
    ACCT_TYPE_INCOME = 8,
    #[doc = "< Expense accounts are used to denote\n   expenses."]
    ACCT_TYPE_EXPENSE = 9,
    #[doc = "< Equity account is used to balance the\n   balance sheet."]
    ACCT_TYPE_EQUITY = 10,
    #[doc = "< A/R account type"]
    ACCT_TYPE_RECEIVABLE = 11,
    #[doc = "< A/P account type"]
    ACCT_TYPE_PAYABLE = 12,
    #[doc = "< The hidden root account of an account tree."]
    ACCT_TYPE_ROOT = 13,
    #[doc = "< Account used to record multiple commodity transactions.\n   This is not the same as ACCT_TYPE_CURRENCY above.\n   Multiple commodity transactions have splits in these\n   accounts to make the transaction balance in each\n   commodity as well as in total value."]
    ACCT_TYPE_TRADING = 14,
    #[doc = "< stop here; the following types\n just aren't ready for prime time"]
    NUM_ACCOUNT_TYPES = 15,
    #[doc = "< bank account type -- don't use this for\n   now, see NUM_ACCOUNT_TYPES"]
    ACCT_TYPE_SAVINGS = 16,
    #[doc = "< bank account type -- don't use this\n   for now, see NUM_ACCOUNT_TYPES"]
    ACCT_TYPE_MONEYMRKT = 17,
    #[doc = "< line of credit -- don't use this for\n   now, see NUM_ACCOUNT_TYPES"]
    ACCT_TYPE_CREDITLINE = 18,
    ACCT_TYPE_LAST = 19,
}
unsafe extern "C" {
    #[doc = " Constructor"]
    pub fn xaccMallocAccount(book: *mut QofBook) -> *mut Account;
}
unsafe extern "C" {
    #[doc = " Create a new root level account."]
    pub fn gnc_account_create_root(book: *mut QofBook) -> *mut Account;
}
unsafe extern "C" {
    #[doc = " The xaccCloneAccount() routine makes a simple copy of the\n  indicated account, placing it in the indicated book.  It copies\n  the account type, name, description, and the kvp values;\n  it does not copy splits/transactions.  The book should have\n  a commodity table in it that has commodities with the same\n  unique name as the ones being copied in the account (the\n  commodities in the clone will be those from the book)."]
    pub fn xaccCloneAccount(source: *const Account, book: *mut QofBook) -> *mut Account;
}
unsafe extern "C" {
    #[doc = " The xaccAccountBeginEdit() subroutine is the first phase of\n    a two-phase-commit wrapper for account updates."]
    pub fn xaccAccountBeginEdit(account: *mut Account);
}
unsafe extern "C" {
    #[doc = " ThexaccAccountCommitEdit() subroutine is the second phase of\n    a two-phase-commit wrapper for account updates."]
    pub fn xaccAccountCommitEdit(account: *mut Account);
}
unsafe extern "C" {
    #[doc = " The xaccAccountDestroy() routine can be used to get rid of an\n    account.  The account should have been opened for editing\n    (by calling xaccAccountBeginEdit()) before calling this routine."]
    pub fn xaccAccountDestroy(account: *mut Account);
}
unsafe extern "C" {
    #[doc = " Compare two accounts for equality - this is a deep compare."]
    pub fn xaccAccountEqual(
        a: *const Account,
        b: *const Account,
        check_guids: gboolean,
    ) -> gboolean;
}
unsafe extern "C" {
    #[doc = " The xaccAccountOrder() subroutine defines a sorting order on\n    accounts.  It takes pointers to two accounts, and returns an int < 0 if\n    the first account is \"less than\" the second, returns an int > 0 if the\n    first is \"greater than\" the second, and 0 if they are equal.  To\n    determine the sort order, first the account codes are compared,\n    and if these are equal, then account types, then account\n    names. If still equal, it compares GUID to ensure that there\n    aren't any ties."]
    pub fn xaccAccountOrder(
        account_1: *const Account,
        account_2: *const Account,
    ) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    #[doc = " Returns the account separation character chosen by the user.\n\n  @return The character to use."]
    pub fn gnc_get_account_separator_string() -> *const gchar;
}
unsafe extern "C" {
    pub fn gnc_get_account_separator() -> gunichar;
}
unsafe extern "C" {
    pub fn gnc_set_account_separator(separator: *const gchar);
}
unsafe extern "C" {
    pub fn gnc_book_get_root_account(book: *mut QofBook) -> *mut Account;
}
unsafe extern "C" {
    pub fn gnc_book_set_root_account(book: *mut QofBook, root: *mut Account);
}
unsafe extern "C" {
    pub fn xaccAccountLookup(guid: *const GncGUID, book: *mut QofBook) -> *mut Account;
}
unsafe extern "C" {
    #[doc = " @}"]
    pub fn gnc_account_and_descendants_empty(acc: *mut Account) -> gboolean;
}
unsafe extern "C" {
    #[doc = " Composes a translatable error message showing which account\n  names clash with the current account separator. Can be called\n  after gnc_account_list_name_violations to have a consistent\n  error message in different parts of GnuCash\n\n  @param separator The separator character that was verified against\n  @param invalid_account_names A GList of invalid account names.\n\n  @return An error message that can be displayed to the user or logged.\n          This message string should be freed with g_free when no longer\n          needed."]
    pub fn gnc_account_name_violations_errmsg(
        separator: *const gchar,
        invalid_account_names: *mut GList,
    ) -> *mut gchar;
}
unsafe extern "C" {
    #[doc = " Runs through all the accounts and returns a list of account names\n  that contain the provided separator character. This can be used to\n  check if certain account names are invalid.\n\n  @param book Pointer to the book with accounts to verify\n  @param separator The separator character to verify against\n\n  @return A GList of invalid account names. Should be freed with\n          g_list_free_full (value, g_free) when no longer needed."]
    pub fn gnc_account_list_name_violations(
        book: *mut QofBook,
        separator: *const gchar,
    ) -> *mut GList;
}
unsafe extern "C" {
    #[doc = " @name Account general setters/getters\n@{"]
    pub fn gnc_account_get_book(account: *const Account) -> *mut QofBook;
}
unsafe extern "C" {
    #[doc = " Set the account's type"]
    pub fn xaccAccountSetType(account: *mut Account, arg1: GNCAccountType);
}
unsafe extern "C" {
    #[doc = " Set the account's name"]
    pub fn xaccAccountSetName(account: *mut Account, name: *const ::std::os::raw::c_char);
}
unsafe extern "C" {
    #[doc = " Set the account's accounting code"]
    pub fn xaccAccountSetCode(account: *mut Account, code: *const ::std::os::raw::c_char);
}
unsafe extern "C" {
    #[doc = " Set the account's description"]
    pub fn xaccAccountSetDescription(account: *mut Account, desc: *const ::std::os::raw::c_char);
}
unsafe extern "C" {
    #[doc = " Set the account's Color"]
    pub fn xaccAccountSetColor(account: *mut Account, color: *const ::std::os::raw::c_char);
}
unsafe extern "C" {
    #[doc = " Set the account's Filter"]
    pub fn xaccAccountSetFilter(account: *mut Account, filter: *const ::std::os::raw::c_char);
}
unsafe extern "C" {
    #[doc = " Set the account's Sort Order"]
    pub fn xaccAccountSetSortOrder(account: *mut Account, sortorder: *const ::std::os::raw::c_char);
}
unsafe extern "C" {
    #[doc = " Set the account's Sort Order direction"]
    pub fn xaccAccountSetSortReversed(account: *mut Account, sortreversed: gboolean);
}
unsafe extern "C" {
    #[doc = " Set the account's notes"]
    pub fn xaccAccountSetNotes(account: *mut Account, notes: *const ::std::os::raw::c_char);
}
unsafe extern "C" {
    #[doc = " Set the account's associated account e.g. stock account -> dividend account"]
    pub fn xaccAccountSetAssociatedAccount(
        acc: *mut Account,
        tag: *const ::std::os::raw::c_char,
        assoc_acct: *const Account,
    );
}
unsafe extern "C" {
    #[doc = " Set the last num field of an Account"]
    pub fn xaccAccountSetLastNum(account: *mut Account, num: *const ::std::os::raw::c_char);
}
unsafe extern "C" {
    #[doc = " Set the account's lot order policy"]
    pub fn gnc_account_set_policy(account: *mut Account, policy: *mut GNCPolicy);
}
unsafe extern "C" {
    #[doc = " Returns the account's account type.\n\n This must not be confused with the \\ref GType as returned by\n gnc_account_get_type(), which is related to glib's type system."]
    pub fn xaccAccountGetType(account: *const Account) -> GNCAccountType;
}
unsafe extern "C" {
    #[doc = " Returns true if the account is a stock, mutual fund or currency,\n otherwise false."]
    pub fn xaccAccountIsPriced(acc: *const Account) -> gboolean;
}
unsafe extern "C" {
    #[doc = " This function will set the starting commodity balance for this\n  account.  This routine is intended for use with backends that do\n  not return the complete list of splits for an account, but rather\n  return a partial list.  In such a case, the backend will typically\n  return all of the splits after some certain date, and the\n  'starting balance' will represent the summation of the splits up\n  to that date."]
    pub fn gnc_account_set_start_balance(acc: *mut Account, start_baln: gnc_numeric);
}
unsafe extern "C" {
    #[doc = " This function will set the starting cleared commodity balance for\n  this account.  This routine is intended for use with backends that\n  do not return the complete list of splits for an account, but\n  rather return a partial list.  In such a case, the backend will\n  typically return all of the splits after some certain date, and\n  the 'starting balance' will represent the summation of the splits\n  up to that date."]
    pub fn gnc_account_set_start_cleared_balance(acc: *mut Account, start_baln: gnc_numeric);
}
unsafe extern "C" {
    #[doc = " This function will set the starting reconciled commodity balance\n  for this account.  This routine is intended for use with backends\n  that do not return the complete list of splits for an account, but\n  rather return a partial list.  In such a case, the backend will\n  typically return all of the splits after some certain date, and\n  the 'starting balance' will represent the summation of the splits\n  up to that date."]
    pub fn gnc_account_set_start_reconciled_balance(acc: *mut Account, start_baln: gnc_numeric);
}
unsafe extern "C" {
    #[doc = " Tell the account that the running balances may be incorrect and\n  need to be recomputed.\n\n  @param acc Set the flag on this account."]
    pub fn gnc_account_set_balance_dirty(acc: *mut Account);
}
unsafe extern "C" {
    #[doc = " Tell the account believes that the splits may be incorrectly\n  sorted and need to be resorted.\n\n  @param acc Set the flag on this account."]
    pub fn gnc_account_set_sort_dirty(acc: *mut Account);
}
unsafe extern "C" {
    #[doc = " Set the defer balance flag. If defer is true, the account balance\n is not automatically computed, which can save a lot of time if\n multiple operations have to be done on the same account. If\n defer is false, further operations on account will cause the\n balance to be recomputed as normal.\n\n  @param acc Set the flag on this account.\n\n  @param defer New value for the flag."]
    pub fn gnc_account_set_defer_bal_computation(acc: *mut Account, defer: gboolean);
}
unsafe extern "C" {
    #[doc = " Insert the given split from an account.\n\n  @param acc The account to which the split should be added.\n\n  @param s The split to be added.\n\n  @result TRUE is the split is successfully added to the set of\n  splits in the account.  FALSE if the addition fails for any reason\n  (including that the split is already in the account)."]
    pub fn gnc_account_insert_split(acc: *mut Account, s: *mut Split) -> gboolean;
}
unsafe extern "C" {
    #[doc = " Remove the given split from an account.\n\n  @param acc The account from which the split should be removed.\n\n  @param s The split to be removed.\n\n  @result TRUE is the split is successfully removed from the set of\n  splits in the account.  FALSE if the removal fails for any\n  reason."]
    pub fn gnc_account_remove_split(acc: *mut Account, s: *mut Split) -> gboolean;
}
unsafe extern "C" {
    #[doc = " Get the account's name"]
    pub fn xaccAccountGetName(account: *const Account) -> *const ::std::os::raw::c_char;
}
unsafe extern "C" {
    #[doc = " Get the account's accounting code"]
    pub fn xaccAccountGetCode(account: *const Account) -> *const ::std::os::raw::c_char;
}
unsafe extern "C" {
    #[doc = " Get the account's description"]
    pub fn xaccAccountGetDescription(account: *const Account) -> *const ::std::os::raw::c_char;
}
unsafe extern "C" {
    #[doc = " Get the account's color"]
    pub fn xaccAccountGetColor(account: *const Account) -> *const ::std::os::raw::c_char;
}
unsafe extern "C" {
    #[doc = " Get the account's filter"]
    pub fn xaccAccountGetFilter(account: *const Account) -> *const ::std::os::raw::c_char;
}
unsafe extern "C" {
    #[doc = " Get the account's Sort Order"]
    pub fn xaccAccountGetSortOrder(account: *const Account) -> *const ::std::os::raw::c_char;
}
unsafe extern "C" {
    #[doc = " Get the account's Sort Order direction"]
    pub fn xaccAccountGetSortReversed(account: *const Account) -> gboolean;
}
unsafe extern "C" {
    #[doc = " Get the account's notes"]
    pub fn xaccAccountGetNotes(account: *const Account) -> *const ::std::os::raw::c_char;
}
unsafe extern "C" {
    #[doc = " Get the account's associated account e.g. stock account -> dividend account"]
    pub fn xaccAccountGetAssociatedAccount(
        acc: *const Account,
        tag: *const ::std::os::raw::c_char,
    ) -> *mut Account;
}
unsafe extern "C" {
    #[doc = " Get the last num field of an Account"]
    pub fn xaccAccountGetLastNum(account: *const Account) -> *const ::std::os::raw::c_char;
}
unsafe extern "C" {
    #[doc = " Get the account's lot order policy"]
    pub fn gnc_account_get_policy(account: *mut Account) -> *mut GNCPolicy;
}
unsafe extern "C" {
    #[doc = " Get the account's flag for deferred balance computation"]
    pub fn gnc_account_get_defer_bal_computation(acc: *mut Account) -> gboolean;
}
unsafe extern "C" {
    #[doc = " The following recompute the partial balances (stored with the\n  transaction) and the total balance, for this account"]
    pub fn xaccAccountRecomputeBalance(arg1: *mut Account);
}
unsafe extern "C" {
    #[doc = " The xaccAccountSortSplits() routine will resort the account's\n  splits if the sort is dirty. If 'force' is true, the account\n  is sorted even if the editlevel is not zero."]
    pub fn xaccAccountSortSplits(acc: *mut Account, force: gboolean);
}
unsafe extern "C" {
    #[doc = " The gnc_account_get_full_name routine returns the fully qualified name\n of the account using the given separator char. The name must be\n g_free'd after use. The fully qualified name of an account is the\n concatenation of the names of the account and all its ancestor\n accounts starting with the topmost account and ending with the\n given account. Each name is separated by the given character.\n\n @note: WAKE UP!\n Unlike all other gets, the string returned by gnc_account_get_full_name()\n must be freed by you the user !!!\n hack alert -- since it breaks the rule of string allocation, maybe this\n routine should not be in this library, but some utility library?"]
    pub fn gnc_account_get_full_name(account: *const Account) -> *mut gchar;
}
unsafe extern "C" {
    #[doc = " Retrieve the gains account used by this account for the indicated\n currency, creating and recording a new one if necessary.\n\n FIXME: There is at present no interface to designate an existing\n account, and the new account name is hard coded to\n \"Orphaned Gains -- CUR\"\n\n FIXME: There is no provision for creating separate accounts for\n anything other than currency, e.g. holding period of a security."]
    pub fn xaccAccountGainsAccount(acc: *mut Account, curr: *mut gnc_commodity) -> *mut Account;
}
unsafe extern "C" {
    #[doc = " Set the account's commodity"]
    pub fn xaccAccountSetCommodity(account: *mut Account, comm: *mut gnc_commodity);
}
unsafe extern "C" {
    pub fn xaccAccountGetCommodity(account: *const Account) -> *mut gnc_commodity;
}
unsafe extern "C" {
    #[doc = " Returns a gnc_commodity that is a currency, suitable for being a\nTransaction's currency. The gnc_commodity is taken either from the current\naccount, or from the next parent account that has a gnc_commodity that is a\ncurrency. If neither this account nor any of its parent has such a commodity\nthat is a currency, NULL is returned. In that case, you can use\ngnc_default_currency() but you might want to show a warning dialog first."]
    pub fn gnc_account_get_currency_or_parent(account: *const Account) -> *mut gnc_commodity;
}
unsafe extern "C" {
    #[doc = " Return the SCU for the account.  If a non-standard SCU has been\n   set for the account, that is returned; else the default SCU for\n   the account commodity is returned."]
    pub fn xaccAccountGetCommoditySCU(account: *const Account) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    #[doc = " Return the 'internal' SCU setting.  This returns the over-ride\n   SCU for the account (which might not be set, and might be zero)."]
    pub fn xaccAccountGetCommoditySCUi(account: *const Account) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    #[doc = " Set the SCU for the account. Normally, this routine is not\n   required, as the default SCU for an account is given by its\n   commodity."]
    pub fn xaccAccountSetCommoditySCU(account: *mut Account, frac: ::std::os::raw::c_int);
}
unsafe extern "C" {
    #[doc = " Set the flag indicating that this account uses a non-standard SCU."]
    pub fn xaccAccountSetNonStdSCU(account: *mut Account, flag: gboolean);
}
unsafe extern "C" {
    #[doc = " Return boolean, indicating whether this account uses a\n   non-standard SCU."]
    pub fn xaccAccountGetNonStdSCU(account: *const Account) -> gboolean;
}
unsafe extern "C" {
    #[doc = " @name Account Balance\n@{\n/\n/** Get the current balance of the account, which may include future\nsplits"]
    pub fn xaccAccountGetBalance(account: *const Account) -> gnc_numeric;
}
unsafe extern "C" {
    #[doc = " Get the current balance of the account, only including cleared\ntransactions"]
    pub fn xaccAccountGetClearedBalance(account: *const Account) -> gnc_numeric;
}
unsafe extern "C" {
    #[doc = " Get the current balance of the account, only including reconciled\ntransactions"]
    pub fn xaccAccountGetReconciledBalance(account: *const Account) -> gnc_numeric;
}
unsafe extern "C" {
    pub fn xaccAccountGetPresentBalance(account: *const Account) -> gnc_numeric;
}
unsafe extern "C" {
    pub fn xaccAccountGetProjectedMinimumBalance(account: *const Account) -> gnc_numeric;
}
unsafe extern "C" {
    #[doc = " Get the balance of the account at the end of the day before the date specified."]
    pub fn xaccAccountGetBalanceAsOfDate(account: *mut Account, date: time64) -> gnc_numeric;
}
unsafe extern "C" {
    #[doc = " Get the reconciled balance of the account at the end of the day of the date specified."]
    pub fn xaccAccountGetReconciledBalanceAsOfDate(
        account: *mut Account,
        date: time64,
    ) -> gnc_numeric;
}
unsafe extern "C" {
    pub fn xaccAccountConvertBalanceToCurrency(
        account: *const Account,
        balance: gnc_numeric,
        balance_currency: *const gnc_commodity,
        new_currency: *const gnc_commodity,
    ) -> gnc_numeric;
}
unsafe extern "C" {
    pub fn xaccAccountConvertBalanceToCurrencyAsOfDate(
        account: *const Account,
        balance: gnc_numeric,
        balance_currency: *const gnc_commodity,
        new_currency: *const gnc_commodity,
        date: time64,
    ) -> gnc_numeric;
}
unsafe extern "C" {
    pub fn xaccAccountGetBalanceInCurrency(
        account: *const Account,
        report_commodity: *const gnc_commodity,
        include_children: gboolean,
    ) -> gnc_numeric;
}
unsafe extern "C" {
    pub fn xaccAccountGetClearedBalanceInCurrency(
        account: *const Account,
        report_commodity: *const gnc_commodity,
        include_children: gboolean,
    ) -> gnc_numeric;
}
unsafe extern "C" {
    pub fn xaccAccountGetReconciledBalanceInCurrency(
        account: *const Account,
        report_commodity: *const gnc_commodity,
        include_children: gboolean,
    ) -> gnc_numeric;
}
unsafe extern "C" {
    pub fn xaccAccountGetPresentBalanceInCurrency(
        account: *const Account,
        report_commodity: *const gnc_commodity,
        include_children: gboolean,
    ) -> gnc_numeric;
}
unsafe extern "C" {
    pub fn xaccAccountGetProjectedMinimumBalanceInCurrency(
        account: *const Account,
        report_commodity: *const gnc_commodity,
        include_children: gboolean,
    ) -> gnc_numeric;
}
unsafe extern "C" {
    #[doc = " This function gets the balance at the end of the given date, ignoring\nclosing entries, in the desired commodity."]
    pub fn xaccAccountGetNoclosingBalanceAsOfDateInCurrency(
        acc: *mut Account,
        date: time64,
        report_commodity: *mut gnc_commodity,
        include_children: gboolean,
    ) -> gnc_numeric;
}
unsafe extern "C" {
    #[doc = " This function gets the balance at the end of the given date in the desired\ncommodity."]
    pub fn xaccAccountGetBalanceAsOfDateInCurrency(
        account: *mut Account,
        date: time64,
        report_commodity: *mut gnc_commodity,
        include_children: gboolean,
    ) -> gnc_numeric;
}
unsafe extern "C" {
    pub fn xaccAccountGetNoclosingBalanceChangeForPeriod(
        acc: *mut Account,
        date1: time64,
        date2: time64,
        recurse: gboolean,
    ) -> gnc_numeric;
}
unsafe extern "C" {
    pub fn xaccAccountGetNoclosingBalanceChangeInCurrencyForPeriod(
        acc: *mut Account,
        date1: time64,
        date2: time64,
        recurse: gboolean,
    ) -> gnc_numeric;
}
unsafe extern "C" {
    pub fn xaccAccountGetBalanceChangeForPeriod(
        acc: *mut Account,
        date1: time64,
        date2: time64,
        recurse: gboolean,
    ) -> gnc_numeric;
}
unsafe extern "C" {
    #[doc = " This function will remove from the child account any pre-existing\n  parent relationship, and will then add the account as a child of\n  the new parent.  The exception to this is when the old and new\n  parent accounts are the same, in which case this function does\n  nothing.\n\n  If the child account belongs to a different book than the\n  specified new parent account, the child will be removed from the\n  other book (and thus, the other book's entity tables, generating a\n  destroy event), and will be added to the new book (generating a\n  create event).\n\n  @param new_parent The new parent account to which the child should\n  be attached.\n\n  @param child The account to attach."]
    pub fn gnc_account_append_child(new_parent: *mut Account, child: *mut Account);
}
unsafe extern "C" {
    #[doc = " This function will remove the specified child account from the\n  specified parent account. It will NOT free the associated memory\n  or otherwise alter the account: the account can now be reparented\n  to a new location.  Note, however, that it will mark the old\n  parents as having been modified.\n\n  @param parent The parent account from which the child should be\n  removed.\n\n  @param child The child account to remove."]
    pub fn gnc_account_remove_child(parent: *mut Account, child: *mut Account);
}
unsafe extern "C" {
    pub fn gnc_account_get_parent(account: *const Account) -> *mut Account;
}
unsafe extern "C" {
    #[doc = " This routine returns the root account of the account tree that the\n  specified account belongs to.  It is the equivalent of repeatedly\n  calling the gnc_account_get_parent() routine until that routine\n  returns NULL.\n\n  @param account A pointer to any existing account.\n\n  @return The root node of the account tree to which this account\n  belongs.  NULL if the account is not part of any account tree."]
    pub fn gnc_account_get_root(account: *mut Account) -> *mut Account;
}
unsafe extern "C" {
    #[doc = " This routine indicates whether the specified account is the root\n  node of an account tree.\n\n  @param account A pointer to any account.\n\n  @return TRUE if this account is of type ROOT.  FALSE otherwise."]
    pub fn gnc_account_is_root(account: *const Account) -> gboolean;
}
unsafe extern "C" {
    #[doc = " This routine returns a GList of all children accounts of the specified\n  account.  This function only returns the immediate children of the\n  specified account.  For a list of all descendant accounts, use the\n  gnc_account_get_descendants() function.\n\n  If you are looking for the splits of this account, use\n  xaccAccountGetSplitList() instead. This function here deals with\n  children accounts inside the account tree.\n\n  @param account The account whose children should be returned.\n\n  @return A GList of account pointers, or NULL if there are no\n  children accounts. It is the callers responsibility to free any returned\n  list with the g_list_free() function."]
    pub fn gnc_account_get_children(account: *const Account) -> *mut GList;
}
unsafe extern "C" {
    #[doc = " This routine returns a GList of all children accounts of the specified\n  account, ordered by xaccAccountOrder().  \\sa gnc_account_get_children()"]
    pub fn gnc_account_get_children_sorted(account: *const Account) -> *mut GList;
}
unsafe extern "C" {
    #[doc = " Return the number of children of the specified account.  The\n  returned number does not include the account itself.\n\n  @param account The account to query.\n\n  @return The number of children of the specified account."]
    pub fn gnc_account_n_children(account: *const Account) -> gint;
}
unsafe extern "C" {
    #[doc = " Return the index of the specified child within the list of the\n  parent's children.  The first child index is 0.  This function\n  returns -1 if the parent account is NULL of if the specified child\n  does not belong to the parent account.\n\n  @param parent The parent account to check.\n\n  @param child The child account to find.\n\n  @return The index of the child account within the specified\n  parent, or -1."]
    pub fn gnc_account_child_index(parent: *const Account, child: *const Account) -> gint;
}
unsafe extern "C" {
    #[doc = " Return the n'th child account of the specified parent account.  If\n  the parent account is not specified or the child index number is\n  invalid, this function returns NULL.\n\n  @param parent The parent account to check.\n\n  @param num The index number of the child account that should be\n  returned.\n\n  @return A pointer to the specified child account, or NULL"]
    pub fn gnc_account_nth_child(parent: *const Account, num: gint) -> *mut Account;
}
unsafe extern "C" {
    #[doc = " This routine returns a flat list of all of the accounts that are\n  descendants of the specified account.  This includes not only the\n  the children, but the children of the children, etc. For a list of\n  only the immediate child accounts, use the\n  gnc_account_get_children() function.  Within each set of child\n  accounts, the accounts returned by this function are unordered.\n  For a list of descendants where each set of children is sorted via\n  the standard account sort function, use the\n  gnc_account_get_descendants_sorted() function.\n\n  @param account The account whose descendants should be returned.\n\n  @return A GList of account pointers, or NULL if there are no\n  descendants. It is the callers responsibility to free any returned\n  list with the g_list_free() function."]
    pub fn gnc_account_get_descendants(account: *const Account) -> *mut GList;
}
unsafe extern "C" {
    #[doc = " This function returns a GList containing all the descendants of\n  the specified account, sorted at each level.  This includes not\n  only the the children, but the children of the children, etc.\n  Within each set of child accounts, the accounts returned by this\n  function are ordered via the standard account sort function.  For\n  a list of descendants where each set of children is unordered, use\n  the gnc_account_get_descendants() function.\n\n  Note: Use this function where the results are intended for display\n  to the user.  If the results are internal to GnuCash or will be\n  resorted at some later point in time you should use the\n  gnc_account_get_descendants() function.\n\n  @param account The account whose descendants should be returned.\n\n  @return A GList of account pointers, or NULL if there are no\n  descendants. It is the callers responsibility to free any returned\n  list with the g_list_free() function."]
    pub fn gnc_account_get_descendants_sorted(account: *const Account) -> *mut GList;
}
unsafe extern "C" {
    #[doc = " Return the number of descendants of the specified account.  The\n  returned number does not include the account itself.\n\n  @param account The account to query.\n\n  @return The number of descendants of the specified account."]
    pub fn gnc_account_n_descendants(account: *const Account) -> gint;
}
unsafe extern "C" {
    #[doc = " Return the number of levels of this account below the root\n  account.\n\n  @param account The account to query.\n\n  @return The number of levels below the root."]
    pub fn gnc_account_get_current_depth(account: *const Account) -> gint;
}
unsafe extern "C" {
    #[doc = " Return the number of levels of descendants accounts below the\n  specified account.  The returned number does not include the\n  specified account itself.\n\n  @param account The account to query.\n\n  @return The number of levels of descendants."]
    pub fn gnc_account_get_tree_depth(account: *const Account) -> gint;
}
unsafe extern "C" {
    #[doc = " This method will traverse the immediate children of this accounts,\n  calling 'func' on each account.  This function traverses all\n  children nodes.  To traverse only a subset of the child nodes use\n  the gnc_account_foreach_child_until() function.\n\n  @param account A pointer to the account on whose children the\n  function should be called.\n\n  @param func A function taking two arguments, an Account and a\n  gpointer.\n\n  @param user_data This data will be passed to each call of func."]
    pub fn gnc_account_foreach_child(account: *const Account, func: AccountCb, user_data: gpointer);
}
unsafe extern "C" {
    #[doc = " This method will traverse all children of this accounts and their\n  descendants, calling 'func' on each account.  This function\n  traverses all descendant nodes.  To traverse only a subset of the\n  descendant nodes use the gnc_account_foreach_descendant_until()\n  function.\n\n  @param account A pointer to the account on whose descendants the\n  function should be called.\n\n  @param func A function taking two arguments, an Account and a\n  gpointer.\n\n  @param user_data This data will be passed to each call of func."]
    pub fn gnc_account_foreach_descendant(
        account: *const Account,
        func: AccountCb,
        user_data: gpointer,
    );
}
unsafe extern "C" {
    #[doc = " This method will traverse all children of this accounts and their\n  descendants, calling 'func' on each account.  Traversal will stop\n  when func returns a non-null value, and the routine will return\n  with that value.  Therefore, this function will return null if\n  func returns null for every account.  For a simpler function that\n  always traverses all children nodes, use the\n  gnc_account_foreach_descendant() function.\n\n  @param account A pointer to the account on whose descendants the\n  function should be called.\n\n  @param func A function taking two arguments, an Account and a\n  gpointer.\n\n  @param user_data This data will be passed to each call of func."]
    pub fn gnc_account_foreach_descendant_until(
        account: *const Account,
        func: AccountCb2,
        user_data: gpointer,
    ) -> gpointer;
}
unsafe extern "C" {
    #[doc = " The gnc_account_join_children() subroutine will move (reparent)\n  all child accounts from the from_parent account to the to_parent\n  account, preserving the account hierarchy.  It will also take care\n  that the moved accounts will have the to_parent's book parent\n  as well."]
    pub fn gnc_account_join_children(to_parent: *mut Account, from_parent: *mut Account);
}
unsafe extern "C" {
    #[doc = " The gnc_account_merge_children() subroutine will go through an\n  account, merging all child accounts that have the same name and\n  description.  This function is useful when importing Quicken(TM)\n  files."]
    pub fn gnc_account_merge_children(parent: *mut Account);
}
unsafe extern "C" {
    #[doc = " DOCUMENT ME!"]
    pub fn xaccAccountSetReconcileChildrenStatus(account: *mut Account, status: gboolean);
}
unsafe extern "C" {
    #[doc = " DOCUMENT ME!"]
    pub fn xaccAccountGetReconcileChildrenStatus(account: *const Account) -> gboolean;
}
unsafe extern "C" {
    #[doc = " Returns true if the account is 'ancestor' or has 'ancestor' as an\n  ancestor.  An ancestor account may be the accounts parent, its\n  parent's parent, its parent's parent's parent, etc.  Returns false\n  if either one is NULL."]
    pub fn xaccAccountHasAncestor(acc: *const Account, ancestor: *const Account) -> gboolean;
}
unsafe extern "C" {
    #[doc = " @name Lookup Accounts and Subaccounts by name or code\n@{\n/\n/** The gnc_account_lookup_by_name() subroutine fetches the account by\n  name from the descendants of the specified account.  The immediate\n  children are searched first.  If there is no match, then a\n  recursive search of all descendants is performed looking for a\n  match.\n\n  @return A pointer to the account with the specified name, or NULL\n  if the account was not found."]
    pub fn gnc_account_lookup_by_name(
        parent: *const Account,
        name: *const ::std::os::raw::c_char,
    ) -> *mut Account;
}
unsafe extern "C" {
    #[doc = " The gnc_account_lookup_full_name() subroutine works like\n  gnc_account_lookup_by_name, but uses fully-qualified names using the\n  given separator."]
    pub fn gnc_account_lookup_by_full_name(
        any_account: *const Account,
        name: *const gchar,
    ) -> *mut Account;
}
unsafe extern "C" {
    #[doc = " The gnc_account_lookup_by_code() subroutine works like\n  gnc_account_lookup_by_name, but uses the account code."]
    pub fn gnc_account_lookup_by_code(
        parent: *const Account,
        code: *const ::std::os::raw::c_char,
    ) -> *mut Account;
}
unsafe extern "C" {
    #[doc = " Find the opening balance account for the currency.\n\n  @param account The account of which the sought-for account is a descendant.\n  @param commodity The commodity in which the account should be denominated\n  @return The descendant account of EQUITY_TYPE_OPENING_BALANCE or NULL if one doesn't exist."]
    pub fn gnc_account_lookup_by_opening_balance(
        account: *mut Account,
        commodity: *mut gnc_commodity,
    ) -> *mut Account;
}
unsafe extern "C" {
    #[doc = " Find a direct child account matching name, GNCAccountType, and/or commodity.\n\n Name and commodity may be nullptr in which case the accounts in the\n list may have any value for those properties.  Note that commodity\n matching is by equivalence: If the mnemonic/symbol and namespace\n are the same, it matches.\n\n  @param root The account among whose children one expects to find\n  the account.\n  @param name The name of the account to look for or nullptr.\n  @param acctype The GNCAccountType to match.\n  @param commodity The commodity in which the account should be denominated or nullptr.\n  @return A GList of children matching the supplied parameters."]
    pub fn gnc_account_lookup_by_type_and_commodity(
        root: *mut Account,
        name: *const ::std::os::raw::c_char,
        acctype: GNCAccountType,
        commodity: *mut gnc_commodity,
    ) -> *mut GList;
}
unsafe extern "C" {
    #[doc = " @name GNCAccountType conversion/checking\n@{\n/\n/**\n Conversion routines for the account types to/from strings\n that are used in persistent storage, communications.  These\n strings should *not* be translated to the local language.\n Typical conversion is ACCT_TYPE_INCOME -> \"INCOME\"."]
    pub fn xaccAccountTypeEnumAsString(type_: GNCAccountType) -> *const ::std::os::raw::c_char;
}
unsafe extern "C" {
    #[doc = " Conversion routines for the account types to/from strings\n that are used in persistent storage, communications.  These\n strings should *not* be translated to the local language.\n Typical conversion is \"INCOME\" -> ACCT_TYPE_INCOME."]
    pub fn xaccAccountStringToType(
        str_: *const ::std::os::raw::c_char,
        type_: *mut GNCAccountType,
    ) -> gboolean;
}
unsafe extern "C" {
    #[doc = " Conversion routines for the account types to/from strings\n that are used in persistent storage, communications.  These\n strings should *not* be translated to the local language.\n Typical conversion is \"INCOME\" -> ACCT_TYPE_INCOME."]
    pub fn xaccAccountStringToEnum(str_: *const ::std::os::raw::c_char) -> GNCAccountType;
}
unsafe extern "C" {
    #[doc = " The xaccAccountGetTypeStr() routine returns a string suitable for\n  use in the GUI/Interface.  These strings should be translated\n  to the local language."]
    pub fn xaccAccountGetTypeStr(type_: GNCAccountType) -> *const ::std::os::raw::c_char;
}
unsafe extern "C" {
    #[doc = " Return the bitmask of account types compatible with a given type.\n  That is, you could switch to any of the account types in the compatible\n  list without unwanted side-effects."]
    pub fn xaccAccountTypesCompatibleWith(type_: GNCAccountType) -> guint32;
}
unsafe extern "C" {
    #[doc = " Return the bitmask of parent account types compatible with a given type."]
    pub fn xaccParentAccountTypesCompatibleWith(type_: GNCAccountType) -> guint32;
}
unsafe extern "C" {
    #[doc = " Return TRUE if accounts of type parent_type can have accounts\n of type child_type as children."]
    pub fn xaccAccountTypesCompatible(
        parent_type: GNCAccountType,
        child_type: GNCAccountType,
    ) -> gboolean;
}
unsafe extern "C" {
    #[doc = " Returns the bitmask of the account type enums that are valid.  Deprecated and\n  root account types are stripped."]
    pub fn xaccAccountTypesValid() -> guint32;
}
unsafe extern "C" {
    #[doc = " Convenience function to check if the account is a valid\n  Asset or Liability type, but not a business account type\n  (meaning not an Accounts Payable/Accounts Receivable)."]
    pub fn xaccAccountIsAssetLiabType(t: GNCAccountType) -> gboolean;
}
unsafe extern "C" {
    #[doc = " Convenience function to return the fundamental type\n asset/liability/income/expense/equity given an account type."]
    pub fn xaccAccountTypeGetFundamental(t: GNCAccountType) -> GNCAccountType;
}
unsafe extern "C" {
    #[doc = " Convenience function to check if the account is a valid\n  business account type\n  (meaning an Accounts Payable/Accounts Receivable)."]
    pub fn xaccAccountIsAPARType(t: GNCAccountType) -> gboolean;
}
unsafe extern "C" {
    #[doc = " Convenience function to check if the account is a valid\n  Equity type."]
    pub fn xaccAccountIsEquityType(t: GNCAccountType) -> gboolean;
}
unsafe extern "C" {
    #[doc = " The xaccAccountGetSplitList() routine returns a pointer to a GList of\n    the splits in the account.\n @note This GList is the account's internal\n    data structure: do not delete it when done; treat it as a read-only\n    structure.  Note that some routines (such as xaccAccountRemoveSplit())\n    modify this list directly, and could leave you with a corrupted\n    pointer.\n @note This should be changed so that the returned value is a copy\n of the list. No other part of the code should have access to the\n internal data structure used by this object."]
    pub fn xaccAccountGetSplitList(account: *const Account) -> *mut SplitList;
}
unsafe extern "C" {
    pub fn xaccAccountGetSplitsSize(account: *const Account) -> usize;
}
unsafe extern "C" {
    #[doc = " The xaccAccountMoveAllSplits() routine reassigns each of the splits\n  in accfrom to accto."]
    pub fn xaccAccountMoveAllSplits(accfrom: *mut Account, accto: *mut Account);
}
unsafe extern "C" {
    #[doc = " The xaccAccountForEachTransaction() routine will traverse all of\n the transactions in @a account and call the callback\n function @a proc on each transaction.  Processing will continue\n if-and-only-if @a proc returns 0. The user data pointer\n @a data will be passed on to the callback function @a proc.\n\n This function does not descend recursively to traverse transactions\n in child accounts.\n\n @a proc will be called exactly once for each transaction that is\n pointed to by at least one split in the given account.\n\n The result of this function will be 0 <em>if and only if</em>\n every relevant transaction was traversed exactly once.\n Else the return value is the last non-zero value returned by proc.\n\n \\warning For performance reasons, the transaction callback @a proc\n must never destroy any of the transaction's splits, nor assign any\n of them to a different account. <b>To do so risks a crash.</b>\n\n \\warning The traversal occurs only over the transactions that\n are locally cached in the local gnucash engine.  If the gnucash\n engine is attached to a remote database, the database may contain\n (many) transactions that are not mirrored in the local cache.\n This routine will not cause an SQL database query to be performed;\n it will not traverse transactions present only in the remote\n database."]
    pub fn xaccAccountForEachTransaction(
        account: *const Account,
        proc_: TransactionCallback,
        data: *mut ::std::os::raw::c_void,
    ) -> gint;
}
unsafe extern "C" {
    #[doc = " Returns a pointer to the transaction, not a copy."]
    pub fn xaccAccountFindTransByDesc(
        account: *const Account,
        description: *const ::std::os::raw::c_char,
    ) -> *mut Transaction;
}
unsafe extern "C" {
    #[doc = " Returns a pointer to the split, not a copy."]
    pub fn xaccAccountFindSplitByDesc(
        account: *const Account,
        description: *const ::std::os::raw::c_char,
    ) -> *mut Split;
}
unsafe extern "C" {
    #[doc = " @name Account lots\n@{\n/\n/** The xaccAccountInsertLot() method will register the indicated lot\n    with this account.   Any splits later inserted into this lot must\n    belong to this account.  If the lot is already in another account,\n    the lot, and all of the splits in it, will be moved from that\n    account to this account."]
    pub fn xaccAccountInsertLot(arg1: *mut Account, arg2: *mut GNCLot);
}
unsafe extern "C" {
    pub fn xaccAccountRemoveLot(arg1: *mut Account, arg2: *mut GNCLot);
}
unsafe extern "C" {
    #[doc = " The xaccAccountGetLotList() routine returns a list of all lots in\n  this account.\n\n  @param account The account whose lots should be returned.\n\n  @return A GList of lot pointers, or NULL if there are no lots in\n  this account children. It is the callers responsibility to free\n  any returned list with the g_list_free() function."]
    pub fn xaccAccountGetLotList(account: *const Account) -> *mut LotList;
}
unsafe extern "C" {
    #[doc = " The xaccAccountForEachLot() method will apply the function 'proc'\n    to each lot in the account.  If 'proc' returns a non-NULL value,\n    further application will be stopped, and the resulting value\n    will be returned.  There is no guaranteed order over which\n    the Lots will be traversed."]
    pub fn xaccAccountForEachLot(
        acc: *const Account,
        proc_: ::std::option::Option<
            unsafe extern "C" fn(lot: *mut GNCLot, user_data: gpointer) -> gpointer,
        >,
        user_data: gpointer,
    ) -> gpointer;
}
unsafe extern "C" {
    #[doc = " Find a list of open lots that match the match_func.  Sort according\n to sort_func.  If match_func is NULL, then all open lots are returned.\n If sort_func is NULL, then the returned list has no particular order.\n The caller must free to returned list."]
    pub fn xaccAccountFindOpenLots(
        acc: *const Account,
        match_func: ::std::option::Option<
            unsafe extern "C" fn(lot: *mut GNCLot, user_data: gpointer) -> gboolean,
        >,
        user_data: gpointer,
        sort_func: GCompareFunc,
    ) -> *mut LotList;
}
unsafe extern "C" {
    #[doc = " @name Account Reconciliation information getters/setters\n@{\n/\n/** DOCUMENT ME!"]
    pub fn xaccAccountGetReconcileLastDate(
        account: *const Account,
        last_date: *mut time64,
    ) -> gboolean;
}
unsafe extern "C" {
    #[doc = " DOCUMENT ME!"]
    pub fn xaccAccountSetReconcileLastDate(account: *mut Account, last_date: time64);
}
unsafe extern "C" {
    #[doc = " DOCUMENT ME!"]
    pub fn xaccAccountGetReconcileLastInterval(
        account: *const Account,
        months: *mut ::std::os::raw::c_int,
        days: *mut ::std::os::raw::c_int,
    ) -> gboolean;
}
unsafe extern "C" {
    #[doc = " DOCUMENT ME!"]
    pub fn xaccAccountSetReconcileLastInterval(
        account: *mut Account,
        months: ::std::os::raw::c_int,
        days: ::std::os::raw::c_int,
    );
}
unsafe extern "C" {
    #[doc = " DOCUMENT ME!"]
    pub fn xaccAccountGetReconcilePostponeDate(
        account: *const Account,
        postpone_date: *mut time64,
    ) -> gboolean;
}
unsafe extern "C" {
    #[doc = " DOCUMENT ME!"]
    pub fn xaccAccountSetReconcilePostponeDate(account: *mut Account, postpone_date: time64);
}
unsafe extern "C" {
    #[doc = " DOCUMENT ME!"]
    pub fn xaccAccountGetReconcilePostponeBalance(
        account: *const Account,
        balance: *mut gnc_numeric,
    ) -> gboolean;
}
unsafe extern "C" {
    #[doc = " DOCUMENT ME!"]
    pub fn xaccAccountSetReconcilePostponeBalance(account: *mut Account, balance: gnc_numeric);
}
unsafe extern "C" {
    #[doc = " DOCUMENT ME!"]
    pub fn xaccAccountClearReconcilePostpone(account: *mut Account);
}
unsafe extern "C" {
    #[doc = " Get the higher balance limit for the account.\n\n  @param account The account whose higher limit is to be retrieved\n\n  @param balance The placeholder to store the retrieved balance\n\n  @return True if the limit is valid."]
    pub fn xaccAccountGetHigherBalanceLimit(
        account: *const Account,
        balance: *mut gnc_numeric,
    ) -> gboolean;
}
unsafe extern "C" {
    #[doc = " Set the higher balance limit for the account.\n\n  @param account The account whose higher limit is to be saved\n\n  @param balance The balance to be saved"]
    pub fn xaccAccountSetHigherBalanceLimit(account: *mut Account, balance: gnc_numeric);
}
unsafe extern "C" {
    #[doc = " Clear the higher balance limit for the account.\n\n  @param account The account to clear the limit on"]
    pub fn xaccAccountClearHigherBalanceLimit(account: *mut Account);
}
unsafe extern "C" {
    #[doc = " Get the lower balance limit for the account.\n\n  @param account The account whose lower limit is to be retrieved\n\n  @param balance The placeholder to store the retrieved balance\n\n  @return True if the limit is valid."]
    pub fn xaccAccountGetLowerBalanceLimit(
        account: *const Account,
        balance: *mut gnc_numeric,
    ) -> gboolean;
}
unsafe extern "C" {
    #[doc = " Set the lower balance limit for the account.\n\n  @param account The account whose lower limit is to be saved\n\n  @param balance The balance to be saved"]
    pub fn xaccAccountSetLowerBalanceLimit(account: *mut Account, balance: gnc_numeric);
}
unsafe extern "C" {
    #[doc = " Clear the lower balance limit for the account.\n\n  @param account The account to clear the limit on"]
    pub fn xaccAccountClearLowerBalanceLimit(account: *mut Account);
}
unsafe extern "C" {
    #[doc = " Get whether to include balances of sub accounts.\n\n  @param account The account to get setting on\n\n  @return TRUE to include, default is FALSE"]
    pub fn xaccAccountGetIncludeSubAccountBalances(account: *const Account) -> gboolean;
}
unsafe extern "C" {
    #[doc = " Set whether to include balances of sub accounts.\n\n  @param account The account to set the setting on\n\n  @param include Set to TRUE for including sub account balances"]
    pub fn xaccAccountSetIncludeSubAccountBalances(account: *mut Account, include: gboolean);
}
#[repr(u32)]
#[doc = " DOCUMENT ME!"]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub enum GNCPlaceholderType {
    PLACEHOLDER_NONE = 0,
    PLACEHOLDER_THIS = 1,
    PLACEHOLDER_CHILD = 2,
}
unsafe extern "C" {
    #[doc = " Get the \"placeholder\" flag for an account.  If this flag is set\n  then the account may not be modified by the user.\n\n  @param account The account whose flag should be retrieved.\n\n  @return The current state of the account's \"placeholder\" flag."]
    pub fn xaccAccountGetPlaceholder(account: *const Account) -> gboolean;
}
unsafe extern "C" {
    #[doc = " Set the \"placeholder\" flag for an account.  If this flag is set\n  then the account may not be modified by the user.\n\n  @param account The account whose flag should be retrieved.\n\n  @param val The new state for the account's \"placeholder\" flag."]
    pub fn xaccAccountSetPlaceholder(account: *mut Account, val: gboolean);
}
unsafe extern "C" {
    #[doc = " Get the \"import-append-text\" flag for an account.  This is the saved\n  state of the Append checkbox in the \"Generic import transaction matcher\"\n  used to set the initial state of the Append checkbox next time this\n  account is imported.\n\n  @param account The account whose flag should be retrieved.\n\n  @return The current state of the account's \"import-append-text\" flag."]
    pub fn xaccAccountGetAppendText(account: *const Account) -> gboolean;
}
unsafe extern "C" {
    #[doc = " Set the \"import-append-text\" flag for an account.  This is the saved\n  state of the Append checkbox in the \"Generic import transaction matcher\"\n  used to set the initial state of the Append checkbox next time this\n  account is imported.\n\n  @param account The account whose flag should be retrieved.\n\n  @param val The new state for the account's \"import-append-text\" flag."]
    pub fn xaccAccountSetAppendText(account: *mut Account, val: gboolean);
}
unsafe extern "C" {
    #[doc = " Get the \"opening-balance\" flag for an account.  If this flag is set\n  then the account is used for opening balance transactions.\n\n  @param account The account whose flag should be retrieved.\n\n  @return The current state of the account's \"opening-balance\" flag."]
    pub fn xaccAccountGetIsOpeningBalance(account: *const Account) -> gboolean;
}
unsafe extern "C" {
    #[doc = " Set the \"opening-balance\" flag for an account. If this flag is set\n  then the account is used for opening balance transactions.\n\n  @param account The account whose flag should be set.\n\n  @param val The new state for the account's \"opening-balance\" flag."]
    pub fn xaccAccountSetIsOpeningBalance(account: *mut Account, val: gboolean);
}
unsafe extern "C" {
    #[doc = " Returns PLACEHOLDER_NONE if account is NULL or neither account nor\n  any descendant of account is a placeholder.  If account is a\n  placeholder, returns PLACEHOLDER_THIS.  Otherwise, if any\n  descendant of account is a placeholder, return PLACEHOLDER_CHILD."]
    pub fn xaccAccountGetDescendantPlaceholder(account: *const Account) -> GNCPlaceholderType;
}
unsafe extern "C" {
    #[doc = " Get the \"hidden\" flag for an account.  If this flag is set then\n  the account (and any children) will be hidden from the user unless\n  they explicitly ask to see them.\n\n  @param acc The account whose flag should be retrieved.\n\n  @return The current state of the account's \"hidden\" flag."]
    pub fn xaccAccountGetHidden(acc: *const Account) -> gboolean;
}
unsafe extern "C" {
    #[doc = " Set the \"hidden\" flag for an account.  If this flag is set then\n  the account (and any children) will be hidden from the user unless\n  they explicitly ask to see them.\n\n  @param acc The account whose flag should be retrieved.\n\n  @param val The new state for the account's \"hidden\" flag."]
    pub fn xaccAccountSetHidden(acc: *mut Account, val: gboolean);
}
unsafe extern "C" {
    #[doc = " Should this account be \"hidden\".  If this flag is set for this\n  account (or any parent account) then the account should be hidden\n  from the user unless they explicitly ask to see it.  This function\n  is different from the xaccAccountGetHidden() function because it\n  checks the flag in parent accounts in addition to this account.\n\n  @param acc The account whose flag should be retrieved.\n\n  @return Whether or not this account should be \"hidden\"."]
    pub fn xaccAccountIsHidden(acc: *const Account) -> gboolean;
}
unsafe extern "C" {
    #[doc = " Get the \"auto interest\" flag for an account.  If this flag is set then\n  the account (and any children) will trigger an interest transfer after reconciling.\n\n  @param acc The account whose flag should be retrieved.\n\n  @return The current state of the account's \"auto interest\" flag."]
    pub fn xaccAccountGetAutoInterest(acc: *const Account) -> gboolean;
}
unsafe extern "C" {
    #[doc = " Set the \"auto interest\" flag for an account.  If this flag is set then\n  the account (and any children) will trigger an interest transfer after reconciling.\n\n  @param acc The account whose flag should be retrieved.\n\n  @param val The new state for the account's \"auto interest\" flag."]
    pub fn xaccAccountSetAutoInterest(acc: *mut Account, val: gboolean);
}
unsafe extern "C" {
    #[doc = " DOCUMENT ME!"]
    pub fn xaccAccountGetTaxRelated(account: *const Account) -> gboolean;
}
unsafe extern "C" {
    #[doc = " DOCUMENT ME!"]
    pub fn xaccAccountSetTaxRelated(account: *mut Account, tax_related: gboolean);
}
unsafe extern "C" {
    #[doc = " DOCUMENT ME!"]
    pub fn xaccAccountGetTaxUSCode(account: *const Account) -> *const ::std::os::raw::c_char;
}
unsafe extern "C" {
    #[doc = " DOCUMENT ME!"]
    pub fn xaccAccountSetTaxUSCode(account: *mut Account, code: *const ::std::os::raw::c_char);
}
unsafe extern "C" {
    #[doc = " DOCUMENT ME!"]
    pub fn xaccAccountGetTaxUSPayerNameSource(
        account: *const Account,
    ) -> *const ::std::os::raw::c_char;
}
unsafe extern "C" {
    #[doc = " DOCUMENT ME!"]
    pub fn xaccAccountSetTaxUSPayerNameSource(
        account: *mut Account,
        source: *const ::std::os::raw::c_char,
    );
}
unsafe extern "C" {
    #[doc = " DOCUMENT ME!"]
    pub fn xaccAccountGetTaxUSCopyNumber(account: *const Account) -> gint64;
}
unsafe extern "C" {
    #[doc = " DOCUMENT ME!"]
    pub fn xaccAccountSetTaxUSCopyNumber(account: *mut Account, copy_number: gint64);
}
unsafe extern "C" {
    #[doc = " Get the debit string associated with this account type"]
    pub fn gnc_account_get_debit_string(acct_type: GNCAccountType)
    -> *const ::std::os::raw::c_char;
}
unsafe extern "C" {
    #[doc = " Get the credit string associated with this account type"]
    pub fn gnc_account_get_credit_string(
        acct_type: GNCAccountType,
    ) -> *const ::std::os::raw::c_char;
}
unsafe extern "C" {
    #[doc = " @name Account marking\n@{\n/\n/** Set a mark on the account.  The meaning of this mark is\n completely undefined. Its presented here as a utility for the\n programmer, to use as desired.  Handy for performing customer traversals\n over the account tree.  The mark is *not* stored in the database/file\n format.  When accounts are newly created, the mark is set to zero."]
    pub fn xaccAccountSetMark(account: *mut Account, mark: ::std::os::raw::c_short);
}
unsafe extern "C" {
    #[doc = " Get the mark set by xaccAccountSetMark\nshort xaccAccountGetMark (const Account *account);\n/\n/** The xaccClearMark will find the root account, and clear the mark in\n the entire account tree."]
    pub fn xaccClearMark(account: *mut Account, val: ::std::os::raw::c_short);
}
unsafe extern "C" {
    #[doc = " The xaccClearMarkDown will clear the mark only in this and in\n sub-accounts."]
    pub fn xaccClearMarkDown(account: *mut Account, val: ::std::os::raw::c_short);
}
unsafe extern "C" {
    #[doc = " @name Staged Traversal\n\n The following functions provide support for \"staged traversals\"\n over all of the transactions in an account or group.  The idea\n is to be able to perform a sequence of traversals (\"stages\"),\n and perform an operation on each transaction exactly once\n for that stage.\n\n Only transactions whose current \"stage\" is less than the\n stage of the current traversal will be affected, and they will\n be \"brought up\" to the current stage when they are processed.\n\n For example, you could perform a stage 1 traversal of all the\n transactions in an account, and then perform a stage 1 traversal of\n the transactions in a second account.  Presuming the traversal of\n the first account didn't abort prematurely, any transactions shared\n by both accounts would be ignored during the traversal of the\n second account since they had been processed while traversing the\n first account.\n\n However, if you had traversed the second account using a stage\n of 2, then all the transactions in the second account would have\n been processed.\n\n Traversal can be aborted by having the callback function return\n a non-zero value.  The traversal is aborted immediately, and the\n non-zero value is returned.  Note that an aborted traversal can\n be restarted; no information is lost due to an abort.\n\n The initial impetus for this particular approach came from\n generalizing a mark/sweep practice that was already being\n used in FileIO.c.\n\n Note that currently, there is a hard limit of 256 stages, which\n can be changed by enlarging \"marker\" in the transaction struct.\n\n@{\n/\n/** gnc_account_tree_begin_staged_transaction_traversals()\n  resets the traversal marker inside every transactions of every\n  account in the account tree originating with the specified node.\n  This is done so that a new sequence of staged traversals can\n  begin."]
    pub fn gnc_account_tree_begin_staged_transaction_traversals(acc: *mut Account);
}
unsafe extern "C" {
    #[doc = " xaccAccountBeginStagedTransactionTraversals() resets the traversal\n    marker for each transaction which is a parent of one of the\n    splits in the account."]
    pub fn xaccAccountBeginStagedTransactionTraversals(account: *const Account);
}
unsafe extern "C" {
    #[doc = " xaccTransactionTraverse() checks the stage of the given transaction.\n    If the transaction hasn't reached the given stage, the transaction\n    is updated to that stage and the function returns TRUE. Otherwise\n    no change is made and the function returns FALSE."]
    pub fn xaccTransactionTraverse(
        trans: *mut Transaction,
        stage: ::std::os::raw::c_int,
    ) -> gboolean;
}
unsafe extern "C" {
    #[doc = " xaccAccountStagedTransactionTraversal() calls @a thunk on each\n    transaction in account @a a whose current marker is less than the\n    given @a stage and updates each transaction's marker to be @a stage.\n    The traversal will stop if @a thunk returns a non-zero value.\n    xaccAccountStagedTransactionTraversal() function will return zero\n    or the non-zero value returned by @a thunk.\n    This API does not handle handle recursive traversals.\n\n    \\warning For performance reasons, the transaction callback @a thunk\n    must never destroy any of the transaction's splits, nor assign any\n    of them to a different account. <b>To do so risks a crash.</b>"]
    pub fn xaccAccountStagedTransactionTraversal(
        a: *const Account,
        stage: ::std::os::raw::c_uint,
        thunk: TransactionCallback,
        data: *mut ::std::os::raw::c_void,
    ) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    #[doc = " gnc_account_tree_staged_transaction_traversal() calls @a thunk on each\n    transaction in the group whose current marker is less than the\n    given @a stage and updates each transaction's marker to be @a stage.\n    The traversal will stop if @a thunk returns a non-zero value.\n    gnc_account_tree_staged_transaction_traversal() function will return zero\n    or the non-zero value returned by @a thunk.  This\n    API does not handle handle recursive traversals.\n\n    \\warning For performance reasons, the transaction callback @a thunk\n    must never destroy any of the transaction's splits, nor assign any\n    of them to a different account. <b>To do so risks a crash.</b>"]
    pub fn gnc_account_tree_staged_transaction_traversal(
        account: *const Account,
        stage: ::std::os::raw::c_uint,
        thunk: TransactionCallback,
        data: *mut ::std::os::raw::c_void,
    ) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    #[doc = " Traverse all of the transactions in the given account group.\n Continue processing IF @a proc returns 0. This function\n will descend recursively to traverse transactions in the\n children of the accounts in the group.\n\n @a Proc will be called exactly once for each transaction that is\n pointed to by at least one split in any account in the hierarchy\n topped by the root Account @a acc.\n\n The result of this function will be 0 IF every relevant\n transaction was traversed exactly once; otherwise, the return\n value is the last non-zero value returned by the callback.\n\n \\warning For performance reasons, the transaction callback @a proc\n must never destroy any of the transaction's splits, nor assign any\n of them to a different account. <b>To do so risks a crash.</b>\n\n \\warning The traversal occurs only over the transactions that\n are locally cached in the local gnucash engine.  If the gnucash\n engine is attached to a remote database, the database may contain\n (many) transactions that are not mirrored in the local cache.\n This routine will not cause an SQL database query to be performed;\n it will not traverse transactions present only in the remote\n database.\n\n Note that this routine is just a trivial wrapper for\n\n gnc_account_tree_begin_staged_transaction_traversals(g);\n gnc_account_tree_staged_transaction_traversal(g, 42, proc, data);"]
    pub fn xaccAccountTreeForEachTransaction(
        acc: *mut Account,
        proc_: TransactionCallback,
        data: *mut ::std::os::raw::c_void,
    ) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn gnc_account_imap_find_account(
        acc: *mut Account,
        category: *const ::std::os::raw::c_char,
        key: *const ::std::os::raw::c_char,
    ) -> *mut Account;
}
unsafe extern "C" {
    pub fn gnc_account_imap_find_any(
        book: *mut QofBook,
        category: *const ::std::os::raw::c_char,
        key: *const ::std::os::raw::c_char,
    ) -> *mut Account;
}
unsafe extern "C" {
    pub fn gnc_account_imap_add_account(
        acc: *mut Account,
        category: *const ::std::os::raw::c_char,
        key: *const ::std::os::raw::c_char,
        added_acc: *mut Account,
    );
}
unsafe extern "C" {
    pub fn gnc_account_imap_delete_account(
        acc: *mut Account,
        category: *const ::std::os::raw::c_char,
        key: *const ::std::os::raw::c_char,
    );
}
unsafe extern "C" {
    #[doc = " Look up an Account in the map using Baysian"]
    pub fn gnc_account_imap_find_account_bayes(
        acc: *mut Account,
        tokens: *mut GList,
    ) -> *mut Account;
}
unsafe extern "C" {
    #[doc = " Updates the imap for a given account using a list of tokens"]
    pub fn gnc_account_imap_add_account_bayes(
        acc: *mut Account,
        tokens: *mut GList,
        added_acc: *mut Account,
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub struct imap_info {
    pub source_account: *mut Account,
    pub map_account: *mut Account,
    pub list: *mut GList,
    pub head: *mut ::std::os::raw::c_char,
    pub category: *mut ::std::os::raw::c_char,
    pub match_string: *mut ::std::os::raw::c_char,
    pub count: *mut ::std::os::raw::c_char,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of imap_info"][::std::mem::size_of::<imap_info>() - 56usize];
    ["Alignment of imap_info"][::std::mem::align_of::<imap_info>() - 8usize];
    ["Offset of field: imap_info::source_account"]
        [::std::mem::offset_of!(imap_info, source_account) - 0usize];
    ["Offset of field: imap_info::map_account"]
        [::std::mem::offset_of!(imap_info, map_account) - 8usize];
    ["Offset of field: imap_info::list"][::std::mem::offset_of!(imap_info, list) - 16usize];
    ["Offset of field: imap_info::head"][::std::mem::offset_of!(imap_info, head) - 24usize];
    ["Offset of field: imap_info::category"][::std::mem::offset_of!(imap_info, category) - 32usize];
    ["Offset of field: imap_info::match_string"]
        [::std::mem::offset_of!(imap_info, match_string) - 40usize];
    ["Offset of field: imap_info::count"][::std::mem::offset_of!(imap_info, count) - 48usize];
};
impl Default for imap_info {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
pub type GncImapInfo = imap_info;
unsafe extern "C" {
    #[doc = " Clean destructor for the imap_info structure of Bayesian\n  mappings"]
    pub fn gnc_account_imap_info_destroy(arg1: *mut GncImapInfo);
}
unsafe extern "C" {
    #[doc = " Returns a GList of structure imap_info of all Bayesian mappings for\n  required Account"]
    pub fn gnc_account_imap_get_info_bayes(acc: *mut Account) -> *mut GList;
}
unsafe extern "C" {
    #[doc = " Returns a GList of structure imap_info of all Non Bayesian mappings for\n  required Account"]
    pub fn gnc_account_imap_get_info(
        acc: *mut Account,
        category: *const ::std::os::raw::c_char,
    ) -> *mut GList;
}
unsafe extern "C" {
    #[doc = " Returns the text string pointed to by head and category for the Account, free\n  the returned text"]
    pub fn gnc_account_get_map_entry(
        acc: *mut Account,
        head: *const ::std::os::raw::c_char,
        category: *const ::std::os::raw::c_char,
    ) -> *mut gchar;
}
unsafe extern "C" {
    #[doc = " Delete the entry for Account pointed to by head,category and match_string,\n  if empty is TRUE then use delete if empty"]
    pub fn gnc_account_delete_map_entry(
        acc: *mut Account,
        head: *mut ::std::os::raw::c_char,
        category: *mut ::std::os::raw::c_char,
        match_string: *mut ::std::os::raw::c_char,
        empty: gboolean,
    );
}
unsafe extern "C" {
    #[doc = " Delete all bayes entries for Account"]
    pub fn gnc_account_delete_all_bayes_maps(acc: *mut Account);
}
unsafe extern "C" {
    #[doc = " Reset the flag that indicates the function imap_convert_bayes_to_flat\n  has been run"]
    pub fn gnc_account_reset_convert_bayes_to_flat();
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _TransactionClass {
    _unused: [u8; 0],
}
pub type TransactionClass = _TransactionClass;
unsafe extern "C" {
    pub fn gnc_commodity_get_type() -> GType;
}
unsafe extern "C" {
    pub fn gnc_commodity_namespace_get_type() -> GType;
}
pub type CommodityList = GList;
#[doc = "< This quote source pulls from a single\n   specific web site.  For example, the\n   yahoo_australia source only pulls from\n   the yahoo web site."]
pub const QuoteSourceType_SOURCE_SINGLE: QuoteSourceType = 0;
#[doc = "< This quote source may pull from multiple\n   web sites.  For example, the australia\n   source may pull from ASX, yahoo, etc."]
pub const QuoteSourceType_SOURCE_MULTI: QuoteSourceType = 1;
#[doc = "< This is a locally installed quote source\n   that gnucash knows nothing about. May\n   pull from single or multiple\n   locations."]
pub const QuoteSourceType_SOURCE_UNKNOWN: QuoteSourceType = 2;
pub const QuoteSourceType_SOURCE_MAX: QuoteSourceType = 3;
#[doc = "< The special currency quote source."]
pub const QuoteSourceType_SOURCE_CURRENCY: QuoteSourceType = 3;
#[doc = " The quote source type enum account types are used to determine how\n  the transaction data in the account is displayed.  These values\n  can be safely changed from one release to the next."]
pub type QuoteSourceType = ::std::os::raw::c_uint;
unsafe extern "C" {
    #[doc = " This function indicates whether or not the Finance::Quote module\n  is installed on a user's computer.  This includes any other related\n  modules that gnucash need to process F::Q information.\n\n  @return TRUE is F::Q is installed properly."]
    pub fn gnc_quote_source_fq_installed() -> gboolean;
}
unsafe extern "C" {
    #[doc = " This function returns the version of the Finance::Quote module\n  installed on a user's computer. If no proper installation is found\n  it will return NULL.\n\n  @return a version string or NULL"]
    pub fn gnc_quote_source_fq_version() -> *const ::std::os::raw::c_char;
}
unsafe extern "C" {
    #[doc = " Return the number of entries for a given type of quote source.\n\n  @param type The quote source type whose count should be returned.\n\n  @return The number of entries for this type of quote source."]
    pub fn gnc_quote_source_num_entries(type_: QuoteSourceType) -> gint;
}
unsafe extern "C" {
    #[doc = " Create a new quote source. This is called by the F::Q startup code\n  or the XML parsing code to add new entries to the list of\n  available quote sources.\n\n  @param name The internal name for this new quote source.\n\n  @param supported TRUE if this quote source is supported by F::Q.\n  Should only be set by the F::Q startup routine.\n\n  @return A pointer to the newly created quote source."]
    pub fn gnc_quote_source_add_new(
        name: *const ::std::os::raw::c_char,
        supported: gboolean,
    ) -> *mut gnc_quote_source;
}
unsafe extern "C" {
    pub fn gnc_quote_source_lookup_by_internal(
        internal_name: *const ::std::os::raw::c_char,
    ) -> *mut gnc_quote_source;
}
unsafe extern "C" {
    #[doc = " Given the type/index of a quote source, find the data structure\n  identified by this pair.\n\n  @param type The type of this quote source.\n\n  @param index The index of this quote source within its type.\n\n  @return A pointer to the price quote source that has the specified\n  type/index."]
    pub fn gnc_quote_source_lookup_by_ti(
        type_: QuoteSourceType,
        index: gint,
    ) -> *mut gnc_quote_source;
}
unsafe extern "C" {
    #[doc = " Given a gnc_quote_source data structure, return the flag that\n  indicates whether this particular quote source is supported by\n  the user's F::Q installation.\n\n  @param source The quote source in question.\n\n  @return TRUE if the user's computer supports this quote source."]
    pub fn gnc_quote_source_get_supported(source: *const gnc_quote_source) -> gboolean;
}
unsafe extern "C" {
    #[doc = " Given a gnc_quote_source data structure, return the type of this\n  particular quote source. (SINGLE, MULTI, UNKNOWN)\n\n  @param source The quote source in question.\n\n  @return The type of this quote source."]
    pub fn gnc_quote_source_get_type(source: *const gnc_quote_source) -> QuoteSourceType;
}
unsafe extern "C" {
    #[doc = " Given a gnc_quote_source data structure, return the index of this\n  particular quote source within its type.\n\n  @param source The quote source in question.\n\n  @return The index of this quote source in its type."]
    pub fn gnc_quote_source_get_index(source: *const gnc_quote_source) -> gint;
}
unsafe extern "C" {
    pub fn gnc_quote_source_get_user_name(
        source: *const gnc_quote_source,
    ) -> *const ::std::os::raw::c_char;
}
unsafe extern "C" {
    pub fn gnc_quote_source_get_internal_name(
        source: *const gnc_quote_source,
    ) -> *const ::std::os::raw::c_char;
}
unsafe extern "C" {
    pub fn gnc_commodity_new(
        book: *mut QofBook,
        fullname: *const ::std::os::raw::c_char,
        commodity_namespace: *const ::std::os::raw::c_char,
        mnemonic: *const ::std::os::raw::c_char,
        cusip: *const ::std::os::raw::c_char,
        fraction: ::std::os::raw::c_int,
    ) -> *mut gnc_commodity;
}
unsafe extern "C" {
    #[doc = " Destroy a commodity.  Release all memory attached to this data structure.\n  @note This function does not (can not) check to see if the\n  commodity is referenced anywhere.\n  @param cm The commodity to destroy."]
    pub fn gnc_commodity_destroy(cm: *mut gnc_commodity);
}
unsafe extern "C" {
    #[doc = " Copy src into dest"]
    pub fn gnc_commodity_copy(dest: *mut gnc_commodity, src: *const gnc_commodity);
}
unsafe extern "C" {
    #[doc = " allocate and copy"]
    pub fn gnc_commodity_clone(
        src: *const gnc_commodity,
        dest_book: *mut QofBook,
    ) -> *mut gnc_commodity;
}
unsafe extern "C" {
    #[doc = " Retrieve the mnemonic for the specified commodity.  This will be a\n  pointer to a null terminated string of the form \"ACME\", \"QWER\",\n  etc.\n\n  @param cm A pointer to a commodity data structure.\n\n  @return A pointer to the mnemonic for this commodity.  This string\n  is owned by the engine and should not be freed by the caller."]
    pub fn gnc_commodity_get_mnemonic(cm: *const gnc_commodity) -> *const ::std::os::raw::c_char;
}
unsafe extern "C" {
    #[doc = " Retrieve the namespace for the specified commodity.  This will be\n  a pointer to a null terminated string of the form \"AMEX\",\n  \"NASDAQ\", etc.\n\n  @param cm A pointer to a commodity data structure.\n\n  @return A pointer to the namespace for this commodity.  This string\n  is owned by the engine and should not be freed by the caller."]
    pub fn gnc_commodity_get_namespace(cm: *const gnc_commodity) -> *const ::std::os::raw::c_char;
}
unsafe extern "C" {
    #[doc = " Retrieve the namespace data structure for the specified commodity.\n  This will be a pointer to another data structure.\n\n  @param cm A pointer to a commodity data structure.\n\n  @return A pointer to the namespace data structure for this\n  commodity."]
    pub fn gnc_commodity_get_namespace_ds(cm: *const gnc_commodity)
    -> *mut gnc_commodity_namespace;
}
unsafe extern "C" {
    #[doc = " Retrieve the full name for the specified commodity.  This will be\n  a pointer to a null terminated string of the form \"Acme Systems,\n  Inc.\", etc.\n\n  @param cm A pointer to a commodity data structure.\n\n  @return A pointer to the full name for this commodity.  This string\n  is owned by the engine and should not be freed by the caller."]
    pub fn gnc_commodity_get_fullname(cm: *const gnc_commodity) -> *const ::std::os::raw::c_char;
}
unsafe extern "C" {
    #[doc = " Retrieve the 'print' name for the specified commodity.  This will\n  be a pointer to a null terminated string of the form \"Acme\n  Systems, Inc. (ACME)\", etc.\n\n  @param cm A pointer to a commodity data structure.\n\n  @return A pointer to the print name for this commodity.  This\n  string is owned by the engine and should not be freed by the\n  caller."]
    pub fn gnc_commodity_get_printname(cm: *const gnc_commodity) -> *const ::std::os::raw::c_char;
}
unsafe extern "C" {
    #[doc = " Retrieve the 'exchange code' for the specified commodity.  This\n  will be a pointer to a null terminated string of the form\n  \"AXQ14728\", etc.  This field is often used when presenting\n  information to the user.\n\n  @note This is a unique code that specifies a particular item or\n  set of shares of a commodity, not a code that specifies a stock\n  exchange.  That is the namespace field.\n\n  @param cm A pointer to a commodity data structure.\n\n  @return A pointer to the exchange code for this commodity.  This\n  string is owned by the engine and should not be freed by the\n  caller."]
    pub fn gnc_commodity_get_cusip(cm: *const gnc_commodity) -> *const ::std::os::raw::c_char;
}
unsafe extern "C" {
    #[doc = " Retrieve the 'unique' name for the specified commodity.  This will\n  be a pointer to a null terminated string of the form \"AMEX::ACME\",\n  etc.  This field is often used when performing comparisons or\n  other functions invisible to the user.\n\n  @param cm A pointer to a commodity data structure.\n\n  @return A pointer to the 'unique' name for this commodity.  This\n  string is owned by the engine and should not be freed by the\n  caller."]
    pub fn gnc_commodity_get_unique_name(cm: *const gnc_commodity)
    -> *const ::std::os::raw::c_char;
}
unsafe extern "C" {
    #[doc = " Retrieve the fraction for the specified commodity.  This will be\n  an integer value specifying the number of fractional units that\n  one of these commodities can be divided into.  Should always be a\n  power of 10.\n\n  @param cm A pointer to a commodity data structure.\n\n  @return The number of fractional units that one of these\n  commodities can be divided into."]
    pub fn gnc_commodity_get_fraction(cm: *const gnc_commodity) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    #[doc = " Retrieve the automatic price quote flag for the specified\n  commodity.  This flag indicates whether stock quotes should be\n  retrieved for the specified stock.\n\n  @param cm A pointer to a commodity data structure.\n\n  @return TRUE if quotes should be pulled for this commodity, FALSE\n  otherwise."]
    pub fn gnc_commodity_get_quote_flag(cm: *const gnc_commodity) -> gboolean;
}
unsafe extern "C" {
    pub fn gnc_commodity_get_quote_source(cm: *const gnc_commodity) -> *mut gnc_quote_source;
}
unsafe extern "C" {
    pub fn gnc_commodity_get_default_quote_source(
        cm: *const gnc_commodity,
    ) -> *mut gnc_quote_source;
}
unsafe extern "C" {
    #[doc = " Retrieve the automatic price quote timezone for the specified\n  commodity.  This will be a pointer to a null terminated string of\n  the form \"America/New_York\", etc.\n\n  @param cm A pointer to a commodity data structure.\n\n  @return A pointer to the price quote timezone for this commodity.\n  This string is owned by the engine and should not be freed by the\n  caller."]
    pub fn gnc_commodity_get_quote_tz(cm: *const gnc_commodity) -> *const ::std::os::raw::c_char;
}
unsafe extern "C" {
    #[doc = " Retrieve the user-defined symbol for the specified commodity. This\n  will be a pointer to a nul terminated string like \"\", \"US$\", etc.\n\n  @param cm A pointer to a commodity data structure.\n\n  @return A pointer to the user-defined symbol for this commodity.\n  NULL means that the user didn't define any symbol, and that fallback to\n  e.g. the mnemonic is in order. This string is owned by the engine and\n  should not be freed by the caller."]
    pub fn gnc_commodity_get_user_symbol(cm: *const gnc_commodity)
    -> *const ::std::os::raw::c_char;
}
unsafe extern "C" {
    #[doc = " Retrieve the default symbol for the specified commodity. This will\n  be a pointer to a nul terminated string like \"\", \"US$\", etc. Note\n  that for the locale currency, you probably want to look at the\n  system-provided symbol first. See gnc_commodity_get_nice_symbol.\n\n @param cm A pointer to a commodity data structure.\n\n @return A pointer to the default symbol for this commodity."]
    pub fn gnc_commodity_get_default_symbol(
        cm: *const gnc_commodity,
    ) -> *const ::std::os::raw::c_char;
}
unsafe extern "C" {
    #[doc = " Retrieve a symbol for the specified commodity, suitable for\n  display to the user. This will be a pointer to a nul terminated\n  string like \"\", \"US$\", etc. That function is locale-aware and\n  will base its choice of symbol on the user-configured symbol,\n  the locale a\n\n @param cm A pointer to a commodity data structure.\n\n @return A pointer to the symbol for this commodity."]
    pub fn gnc_commodity_get_nice_symbol(cm: *const gnc_commodity)
    -> *const ::std::os::raw::c_char;
}
unsafe extern "C" {
    #[doc = " Set the mnemonic for the specified commodity.  This should be a\n  pointer to a null terminated string of the form \"ACME\", \"QWER\",\n  etc.\n\n  @param cm A pointer to a commodity data structure.\n\n  @param mnemonic A pointer to the mnemonic for this commodity.\n  This string belongs to the caller and will be duplicated by the\n  engine."]
    pub fn gnc_commodity_set_mnemonic(
        cm: *mut gnc_commodity,
        mnemonic: *const ::std::os::raw::c_char,
    );
}
unsafe extern "C" {
    #[doc = " Set the namespace for the specified commodity.  This should be a\n  pointer to a null terminated string of the form \"AMEX\", \"NASDAQ\",\n  etc.\n\n  @param cm A pointer to a commodity data structure.\n\n  @param new_namespace A pointer to the namespace for this commodity.\n  This string belongs to the caller and will be duplicated by the\n  engine."]
    pub fn gnc_commodity_set_namespace(
        cm: *mut gnc_commodity,
        new_namespace: *const ::std::os::raw::c_char,
    );
}
unsafe extern "C" {
    #[doc = " Set the full name for the specified commodity.  This should be\n  a pointer to a null terminated string of the form \"Acme Systems,\n  Inc.\", etc.\n\n  @param cm A pointer to a commodity data structure.\n\n  @param fullname A pointer to the full name for this commodity.\n  This string belongs to the caller and will be duplicated by the\n  engine."]
    pub fn gnc_commodity_set_fullname(
        cm: *mut gnc_commodity,
        fullname: *const ::std::os::raw::c_char,
    );
}
unsafe extern "C" {
    #[doc = " Set the 'exchange code' for the specified commodity.  This should\n  be a pointer to a null terminated string of the form \"AXQ14728\",\n  etc.\n\n  @note This is a unique code that specifies a particular item or\n  set of shares of a commodity, not a code that specifies a stock\n  exchange.  That is the namespace field.\n\n  @param cm A pointer to a commodity data structure.\n\n  @param cusip A pointer to the cusip or other exchange specific\n  data for this commodity.  This string belongs to the caller and\n  will be duplicated by the engine."]
    pub fn gnc_commodity_set_cusip(cm: *mut gnc_commodity, cusip: *const ::std::os::raw::c_char);
}
unsafe extern "C" {
    #[doc = " Set the fraction for the specified commodity.  This should be\n  an integer value specifying the number of fractional units that\n  one of these commodities can be divided into.  Should always be a\n  power of 10.\n\n  @param cm A pointer to a commodity data structure.\n\n  @param smallest_fraction The number of fractional units that one of\n  these commodities can be divided into."]
    pub fn gnc_commodity_set_fraction(
        cm: *mut gnc_commodity,
        smallest_fraction: ::std::os::raw::c_int,
    );
}
unsafe extern "C" {
    #[doc = " Set the automatic price quote flag for the specified commodity,\n  based on user input. This flag indicates whether stock quotes\n  should be retrieved for the specified stock.\n\n  It is necessary to have a separate function to distinguish when\n  this setting is being modified by a user so that the\n  auto-enabling/auto-disabling of currencies can be handled\n  properly.\n\n  @param cm A pointer to a commodity data structure.\n\n  @param flag TRUE if quotes should be pulled for this commodity, FALSE\n  otherwise."]
    pub fn gnc_commodity_user_set_quote_flag(cm: *mut gnc_commodity, flag: gboolean);
}
unsafe extern "C" {
    #[doc = " Set the automatic price quote flag for the specified commodity.\n  This flag indicates whether stock quotes should be retrieved for\n  the specified stock.\n\n  @param cm A pointer to a commodity data structure.\n\n  @param flag TRUE if quotes should be pulled for this commodity, FALSE\n  otherwise."]
    pub fn gnc_commodity_set_quote_flag(cm: *mut gnc_commodity, flag: gboolean);
}
unsafe extern "C" {
    #[doc = " Set the automatic price quote source for the specified commodity.\n  This should be a pointer to a null terminated string of the form\n  \"Yahoo (Asia)\", etc.  Legal values can be found in the\n  quote_sources array in the file gnc-ui-util.c.\n\n  @param cm A pointer to a commodity data structure.\n\n  @param src A pointer to the price quote source for this commodity."]
    pub fn gnc_commodity_set_quote_source(cm: *mut gnc_commodity, src: *mut gnc_quote_source);
}
unsafe extern "C" {
    #[doc = " Set the automatic price quote timezone for the specified\n  commodity.  This should be a pointer to a null terminated string\n  of the form \"America/New_York\", etc.  Legal values can be found in\n  the known_timezones array in the file src/gnome-utils/dialog-commodity.c.\n\n  @param cm A pointer to a commodity data structure.\n\n  @param tz A pointer to the price quote timezone for this commodity.\n  This string belongs to the caller and will be duplicated by the\n  engine."]
    pub fn gnc_commodity_set_quote_tz(cm: *mut gnc_commodity, tz: *const ::std::os::raw::c_char);
}
unsafe extern "C" {
    #[doc = " Set a user-defined symbol for the specified commodity. This should\n  be a pointer to a nul terminated string like \"\", \"US$\", etc.\n\n  @param cm A pointer to a commodity data structure.\n\n  @param tz A pointer to the symbol for this commodity. This string\n  belongs to the caller and will be duplicated by the engine."]
    pub fn gnc_commodity_set_user_symbol(
        cm: *mut gnc_commodity,
        user_symbol: *const ::std::os::raw::c_char,
    );
}
unsafe extern "C" {
    #[doc = " Increment a commodity's internal counter that tracks how many\n  accounts are using that commodity.  For currencies, this may have\n  the side effect of enabling the commodity's quote flag.\n\n  @param cm A pointer to a commodity data structure."]
    pub fn gnc_commodity_increment_usage_count(cm: *mut gnc_commodity);
}
unsafe extern "C" {
    #[doc = " Decrement a commodity's internal counter that tracks how many\n  accounts are using that commodity.  For currencies, this may have\n  the side effect of disabling the commodity's quote flag.\n\n  @param cm A pointer to a commodity data structure."]
    pub fn gnc_commodity_decrement_usage_count(cm: *mut gnc_commodity);
}
unsafe extern "C" {
    #[doc = " This routine returns TRUE if the two commodities are equivalent.\n  Commodities are equivalent if they have the same namespace and\n  mnemonic.  Equivalent commodities may belong to different\n  exchanges, may have different fullnames, and may have different\n  fractions."]
    pub fn gnc_commodity_equiv(a: *const gnc_commodity, b: *const gnc_commodity) -> gboolean;
}
unsafe extern "C" {
    #[doc = " This routine returns TRUE if the two commodities are equal.\n  Commodities are equal if they have the same namespace, mnemonic,\n  fullname, exchange private code and fraction."]
    pub fn gnc_commodity_equal(a: *const gnc_commodity, b: *const gnc_commodity) -> gboolean;
}
unsafe extern "C" {
    #[doc = " This routine returns 0 if the two commodities are equal, 1 otherwise.\n  Commodities are equal if they have the same namespace, mnemonic,\n  fullname, exchange private code and fraction.\n  This function is useful for list-traversal comparison purposes where\n  The semantics are 0, <0, or >0 (equal, greater than, less than) rather\n   than \"true or false\""]
    pub fn gnc_commodity_compare(
        a: *const gnc_commodity,
        b: *const gnc_commodity,
    ) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    #[doc = " A wrapper around gnc_commodity_compare() which offers the function\n declaration that is needed for g_list_find_custom(), which needs\n void pointers instead of gnc_commodity ones."]
    pub fn gnc_commodity_compare_void(
        a: *const ::std::os::raw::c_void,
        b: *const ::std::os::raw::c_void,
    ) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    #[doc = " Checks to see if the specified commodity namespace is the\n  namespace for ISO 4217 currencies.\n\n  @param commodity_namespace The string to check.\n\n  @return TRUE if the string indicates an ISO currency, FALSE otherwise."]
    pub fn gnc_commodity_namespace_is_iso(
        commodity_namespace: *const ::std::os::raw::c_char,
    ) -> gboolean;
}
unsafe extern "C" {
    #[doc = " Checks to see if the specified commodity is an ISO 4217 recognized currency.\n\n  @param cm The commodity to check.\n\n  @return TRUE if the commodity represents a currency, FALSE otherwise."]
    pub fn gnc_commodity_is_iso(cm: *const gnc_commodity) -> gboolean;
}
unsafe extern "C" {
    #[doc = " Checks to see if the specified commodity is an ISO 4217 recognized\n currency or a legacy currency.\n\n  @param cm The commodity to check.\n\n  @return TRUE if the commodity represents a currency, FALSE otherwise."]
    pub fn gnc_commodity_is_currency(cm: *const gnc_commodity) -> gboolean;
}
unsafe extern "C" {
    pub fn gnc_commodity_table_get_table(book: *mut QofBook) -> *mut gnc_commodity_table;
}
unsafe extern "C" {
    #[doc = " @name Commodity Table Lookup functions\n@{"]
    pub fn gnc_commodity_table_lookup(
        table: *const gnc_commodity_table,
        commodity_namespace: *const ::std::os::raw::c_char,
        mnemonic: *const ::std::os::raw::c_char,
    ) -> *mut gnc_commodity;
}
unsafe extern "C" {
    pub fn gnc_commodity_table_lookup_unique(
        table: *const gnc_commodity_table,
        unique_name: *const ::std::os::raw::c_char,
    ) -> *mut gnc_commodity;
}
unsafe extern "C" {
    pub fn gnc_commodity_table_find_full(
        t: *const gnc_commodity_table,
        commodity_namespace: *const ::std::os::raw::c_char,
        fullname: *const ::std::os::raw::c_char,
    ) -> *mut gnc_commodity;
}
unsafe extern "C" {
    pub fn gnc_commodity_find_commodity_by_guid(
        guid: *const GncGUID,
        book: *mut QofBook,
    ) -> *mut gnc_commodity;
}
unsafe extern "C" {
    pub fn gnc_commodity_table_insert(
        table: *mut gnc_commodity_table,
        comm: *mut gnc_commodity,
    ) -> *mut gnc_commodity;
}
unsafe extern "C" {
    #[doc = " Remove a commodity from the commodity table. If the commodity to\n  remove doesn't exist, nothing happens.\n\n  @param table A pointer to the commodity table\n\n  @param comm A pointer to the commodity to remove."]
    pub fn gnc_commodity_table_remove(table: *mut gnc_commodity_table, comm: *mut gnc_commodity);
}
unsafe extern "C" {
    #[doc = " Add all the standard namespaces and currencies to the commodity\n  table.  This routine creates the namespaces for the NYSE, NASDAQ,\n  etc.  It also adds all of the ISO 4217 currencies to the commodity\n  table.\n\n  @param table A pointer to the commodity table.\n\n  @param book Unused."]
    pub fn gnc_commodity_table_add_default_data(
        table: *mut gnc_commodity_table,
        book: *mut QofBook,
    ) -> gboolean;
}
unsafe extern "C" {
    #[doc = " Return the textual name of a namespace data structure.\n\n  @param ns A pointer to the namespace data structure.\n\n  @return A pointer to the name of the namespace.  This string is\n  owned by the engine and should not be freed by the caller."]
    pub fn gnc_commodity_namespace_get_name(
        ns: *const gnc_commodity_namespace,
    ) -> *const ::std::os::raw::c_char;
}
unsafe extern "C" {
    #[doc = " Return the textual name of a namespace data structure in a form suitable to\n present to the user.\n\n  @param ns A pointer to the namespace data structure.\n\n  @return A pointer to the gui friendly name of the namespace.  This string is\n  owned by the engine and should not be freed by the caller.\n\n  @notes The returned string is marked for translation, but not translated yet.\n  If you want it translated pass the return value on to gettext."]
    pub fn gnc_commodity_namespace_get_gui_name(
        ns: *const gnc_commodity_namespace,
    ) -> *const ::std::os::raw::c_char;
}
unsafe extern "C" {
    #[doc = " Return a list of all commodity data structures in the specified namespace.\n\n  @return A pointer to the list of structures.  NULL if an invalid\n  argument was supplied.\n\n  @note This list is owned by the caller who must free the list."]
    pub fn gnc_commodity_namespace_get_commodity_list(
        ns: *const gnc_commodity_namespace,
    ) -> *mut GList;
}
unsafe extern "C" {
    #[doc = " Test to see if the indicated namespace exits in the commodity table.\n\n  @param table A pointer to the commodity table\n\n  @param commodity_namespace The new namespace to check.\n\n  @return 1 if the namespace exists. 0 if it doesn't exist, or the\n  routine was passed a bad argument."]
    pub fn gnc_commodity_table_has_namespace(
        table: *const gnc_commodity_table,
        commodity_namespace: *const ::std::os::raw::c_char,
    ) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    #[doc = " Return a list of all namespaces in the commodity table.  This\n  returns both system and user defined namespaces.\n\n  @return A pointer to the list of names.  NULL if an invalid\n  argument was supplied.\n\n  @note It is the callers responsibility to free the list."]
    pub fn gnc_commodity_table_get_namespaces(t: *const gnc_commodity_table) -> *mut GList;
}
unsafe extern "C" {
    #[doc = " Return a list of all namespace data structures in the commodity table.  This\n  returns both system and user defined namespace structures.\n\n  @return A pointer to the list of structures.  NULL if an invalid\n  argument was supplied.\n\n  @note This list is owned by the caller who must free the list."]
    pub fn gnc_commodity_table_get_namespaces_list(t: *const gnc_commodity_table) -> *mut GList;
}
unsafe extern "C" {
    #[doc = " This function adds a new string to the list of commodity namespaces.\n  If the new namespace already exists, nothing happens.\n\n  @param table A pointer to the commodity table\n\n  @param commodity_namespace The new namespace to be added.\n\n  @param book The book that the new namespace will belong to.\n\n  @return A pointer to the newly created namespace."]
    pub fn gnc_commodity_table_add_namespace(
        table: *mut gnc_commodity_table,
        commodity_namespace: *const ::std::os::raw::c_char,
        book: *mut QofBook,
    ) -> *mut gnc_commodity_namespace;
}
unsafe extern "C" {
    #[doc = " This function finds a commodity namespace in the set of existing commodity namespaces.\n\n  @param table A pointer to the commodity table\n\n  @param commodity_namespace The new namespace to be added.\n\n  @return The a pointer to the namespace found, or NULL if the\n  namespace doesn't exist."]
    pub fn gnc_commodity_table_find_namespace(
        table: *const gnc_commodity_table,
        commodity_namespace: *const ::std::os::raw::c_char,
    ) -> *mut gnc_commodity_namespace;
}
unsafe extern "C" {
    #[doc = " This function deletes a string from the list of commodity namespaces.\n  If the namespace does not exist, nothing happens.\n\n  @param table A pointer to the commodity table\n\n  @param commodity_namespace The namespace to be deleted.\n\n  @note This routine will destroy any commodities that exist as part\n  of this namespace.  Use it carefully."]
    pub fn gnc_commodity_table_delete_namespace(
        table: *mut gnc_commodity_table,
        commodity_namespace: *const ::std::os::raw::c_char,
    );
}
unsafe extern "C" {
    #[doc = " Returns the number of commodities in the commodity table.\n\n  @param tbl A pointer to the commodity table\n\n  @return The number of commodities in the table. 0 if there are no\n  commodities, or the routine was passed a bad argument."]
    pub fn gnc_commodity_table_get_size(tbl: *const gnc_commodity_table) -> guint;
}
unsafe extern "C" {
    #[doc = " Return a list of all commodities in the commodity table that are\n  in the given namespace.\n\n  @param table A pointer to the commodity table\n\n  @param commodity_namespace A string indicating which commodities should be\n  returned. It is a required argument.\n\n  @return A pointer to the list of commodities.  NULL if an invalid\n  argument was supplied, or the namespace could not be found.\n\n  @note It is the callers responsibility to free the list."]
    pub fn gnc_commodity_table_get_commodities(
        table: *const gnc_commodity_table,
        commodity_namespace: *const ::std::os::raw::c_char,
    ) -> *mut CommodityList;
}
unsafe extern "C" {
    #[doc = " This function returns a list of commodities for which price quotes\n  should be retrieved.  It will scan the entire commodity table (or\n  a subset) and check each commodity to see if the price_quote_flag\n  field has been set.  All matching commodities are queued onto a\n  list, and the head of that list is returned.  Use the command-line\n  given expression as a filter on the commodities to be returned. If\n  non-null, only commodities in namespace that match the specified\n  regular expression are checked.  If none was given, all\n  commodities are checked.\n\n  @param table A pointer to the commodity table\n\n  @return A pointer to a list of commodities.  NULL if invalid\n  arguments were supplied or if there no commodities are flagged for\n  quote retrieval.\n\n  @note It is the callers responsibility to free the list."]
    pub fn gnc_commodity_table_get_quotable_commodities(
        table: *const gnc_commodity_table,
    ) -> *mut CommodityList;
}
unsafe extern "C" {
    #[doc = " Call a function once for each commodity in the commodity table.\n  This table walk returns whenever the end of the table is reached,\n  or the function returns FALSE.\n\n  @param table A pointer to the commodity table\n\n  @param f The function to call for each commodity.\n\n  @param user_data A pointer that is passed into the function\n  unchanged by the table walk routine."]
    pub fn gnc_commodity_table_foreach_commodity(
        table: *const gnc_commodity_table,
        f: ::std::option::Option<
            unsafe extern "C" fn(cm: *mut gnc_commodity, user_data: gpointer) -> gboolean,
        >,
        user_data: gpointer,
    ) -> gboolean;
}
unsafe extern "C" {
    #[doc = " You probably shouldn't be using gnc_commodity_table_new() directly,\n it's for internal use only. You should probably be using\n gnc_commodity_table_get_table()"]
    pub fn gnc_commodity_table_new() -> *mut gnc_commodity_table;
}
unsafe extern "C" {
    pub fn gnc_commodity_table_destroy(table: *mut gnc_commodity_table);
}
unsafe extern "C" {
    #[doc = " Given the commodity 'findlike', this routine will find and return the\n   equivalent commodity (commodity with the same 'unique name') in\n   the indicated book.  This routine is primarily useful for setting\n   up clones of things across multiple books."]
    pub fn gnc_commodity_obtain_twin(
        findlike: *const gnc_commodity,
        book: *mut QofBook,
    ) -> *mut gnc_commodity;
}
unsafe extern "C" {
    #[doc = " You should probably not be using gnc_commodity_table_register()\n It is an internal routine for registering the gncObject for the\n commodity table."]
    pub fn gnc_commodity_table_register() -> gboolean;
}
unsafe extern "C" {
    pub fn gnc_commodity_begin_edit(cm: *mut gnc_commodity);
}
unsafe extern "C" {
    pub fn gnc_commodity_commit_edit(cm: *mut gnc_commodity);
}
#[doc = " @name Monetary value, commodity identity and numeric value\n@{"]
#[repr(C)]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub struct _gnc_monetary {
    pub commodity: *mut gnc_commodity,
    pub value: gnc_numeric,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of _gnc_monetary"][::std::mem::size_of::<_gnc_monetary>() - 24usize];
    ["Alignment of _gnc_monetary"][::std::mem::align_of::<_gnc_monetary>() - 8usize];
    ["Offset of field: _gnc_monetary::commodity"]
        [::std::mem::offset_of!(_gnc_monetary, commodity) - 0usize];
    ["Offset of field: _gnc_monetary::value"]
        [::std::mem::offset_of!(_gnc_monetary, value) - 8usize];
};
impl Default for _gnc_monetary {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[doc = " @name Monetary value, commodity identity and numeric value\n@{"]
pub type gnc_monetary = _gnc_monetary;
pub type MonetaryList = GList;
unsafe extern "C" {
    #[doc = " Add a gnc_monetary to the list"]
    pub fn gnc_monetary_list_add_monetary(
        list: *mut MonetaryList,
        mon: gnc_monetary,
    ) -> *mut MonetaryList;
}
unsafe extern "C" {
    #[doc = " Delete all the zero-value entries from a list"]
    pub fn gnc_monetary_list_delete_zeros(list: *mut MonetaryList) -> *mut MonetaryList;
}
unsafe extern "C" {
    #[doc = " Free a monetary list and all the items it points to"]
    pub fn gnc_monetary_list_free(list: *mut MonetaryList);
}
unsafe extern "C" {
    pub fn gnc_price_get_type() -> GType;
}
unsafe extern "C" {
    pub fn gnc_pricedb_get_type() -> GType;
}
pub type PriceList = GList;
#[repr(u32)]
#[doc = " Price source enum. Be sure to keep in sync with the source_name array in\n gnc-pricedb.c. These are in preference order, so for example a quote with\n PRICE_SOURCE_EDIT_DLG will overwrite one with PRICE_SOURCE_FQ but not the\n other way around."]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub enum PriceSource {
    PRICE_SOURCE_EDIT_DLG = 0,
    PRICE_SOURCE_FQ = 1,
    PRICE_SOURCE_USER_PRICE = 2,
    PRICE_SOURCE_XFER_DLG_VAL = 3,
    PRICE_SOURCE_SPLIT_REG = 4,
    PRICE_SOURCE_SPLIT_IMPORT = 5,
    PRICE_SOURCE_STOCK_SPLIT = 6,
    PRICE_SOURCE_STOCK_TRANSACTION = 7,
    PRICE_SOURCE_INVOICE = 8,
    PRICE_SOURCE_TEMP = 9,
    PRICE_SOURCE_INVALID = 10,
}
unsafe extern "C" {
    pub fn gnc_price_create(book: *mut QofBook) -> *mut GNCPrice;
}
unsafe extern "C" {
    #[doc = " gnc_price_clone - returns a newly allocated price that's a\ncontent-wise duplicate of the given price, p.  The returned clone\nwill have a reference count of 1."]
    pub fn gnc_price_clone(p: *mut GNCPrice, book: *mut QofBook) -> *mut GNCPrice;
}
unsafe extern "C" {
    #[doc = " Return a newly-allocated price that's the inverse of the given price, p.\n\n Inverse means that the commodity and currency are swapped and the value is\n the numeric inverse of the original's. The source is set to PRICE_SOURCE_TEMP\n to prevent it being saved in the pricedb.\n @param p The price to invert\n @return a new price, with a ref-count of 1. Don't forget to unref it!"]
    pub fn gnc_price_invert(p: *mut GNCPrice) -> *mut GNCPrice;
}
unsafe extern "C" {
    #[doc = " gnc_price_ref - indicate your need for a given price to stick\naround (i.e. increase its reference count by 1)."]
    pub fn gnc_price_ref(p: *mut GNCPrice);
}
unsafe extern "C" {
    #[doc = " gnc_price_unref - indicate you're finished with a price\n(i.e. decrease its reference count by 1)."]
    pub fn gnc_price_unref(p: *mut GNCPrice);
}
unsafe extern "C" {
    #[doc = " @name  Setters\n All of the setters store copies of the data\n given, with the exception of the commodity field which just stores\n the pointer given.  It is assumed that commodities are a global\n resource and are pointer unique.\n\n Invocations of the setters should be wrapped with calls to\n gnc_price_begin_edit() and commit_edit().  The begin/commit\n calls help ensure that the local price db is synchronized with\n the backend.\n@{"]
    pub fn gnc_price_begin_edit(p: *mut GNCPrice);
}
unsafe extern "C" {
    pub fn gnc_price_commit_edit(p: *mut GNCPrice);
}
unsafe extern "C" {
    pub fn gnc_price_set_commodity(p: *mut GNCPrice, c: *mut gnc_commodity);
}
unsafe extern "C" {
    pub fn gnc_price_set_currency(p: *mut GNCPrice, c: *mut gnc_commodity);
}
unsafe extern "C" {
    pub fn gnc_price_set_time64(p: *mut GNCPrice, t: time64);
}
unsafe extern "C" {
    pub fn gnc_price_set_source(p: *mut GNCPrice, source: PriceSource);
}
unsafe extern "C" {
    pub fn gnc_price_set_source_string(p: *mut GNCPrice, s: *const ::std::os::raw::c_char);
}
unsafe extern "C" {
    pub fn gnc_price_set_typestr(p: *mut GNCPrice, type_: *const ::std::os::raw::c_char);
}
unsafe extern "C" {
    pub fn gnc_price_set_value(p: *mut GNCPrice, value: gnc_numeric);
}
unsafe extern "C" {
    #[doc = " @name  Getters\nAll of the getters return data that's internal\nto the GNCPrice, not copies, so don't free these values.\n@{"]
    pub fn gnc_price_lookup(guid: *const GncGUID, book: *mut QofBook) -> *mut GNCPrice;
}
unsafe extern "C" {
    pub fn gnc_price_get_commodity(p: *const GNCPrice) -> *mut gnc_commodity;
}
unsafe extern "C" {
    pub fn gnc_price_get_currency(p: *const GNCPrice) -> *mut gnc_commodity;
}
unsafe extern "C" {
    pub fn gnc_price_get_time64(p: *const GNCPrice) -> time64;
}
unsafe extern "C" {
    pub fn gnc_price_get_source(p: *const GNCPrice) -> PriceSource;
}
unsafe extern "C" {
    pub fn gnc_price_get_source_string(p: *const GNCPrice) -> *const ::std::os::raw::c_char;
}
unsafe extern "C" {
    pub fn gnc_price_get_typestr(p: *const GNCPrice) -> *const ::std::os::raw::c_char;
}
unsafe extern "C" {
    pub fn gnc_price_get_value(p: *const GNCPrice) -> gnc_numeric;
}
unsafe extern "C" {
    pub fn gnc_price_equal(p1: *const GNCPrice, p2: *const GNCPrice) -> gboolean;
}
unsafe extern "C" {
    #[doc = " @name Internal/Debugging\n@{ */\n/** This simple function can be useful for debugging the price code"]
    pub fn gnc_price_print(db: *mut GNCPrice, f: *mut FILE, indent: ::std::os::raw::c_int);
}
unsafe extern "C" {
    #[doc = " gnc_price_list_insert - insert a price into the given list, calling\ngnc_price_ref on it during the process."]
    pub fn gnc_price_list_insert(
        prices: *mut *mut PriceList,
        p: *mut GNCPrice,
        check_dupl: gboolean,
    ) -> gboolean;
}
unsafe extern "C" {
    #[doc = " gnc_price_list_remove - remove the price, p, from the given list,\ncalling gnc_price_unref on it during the process."]
    pub fn gnc_price_list_remove(prices: *mut *mut PriceList, p: *mut GNCPrice) -> gboolean;
}
unsafe extern "C" {
    #[doc = " gnc_price_list_destroy - destroy the given price list, calling\ngnc_price_unref on all the prices included in the list."]
    pub fn gnc_price_list_destroy(prices: *mut PriceList);
}
unsafe extern "C" {
    pub fn gnc_price_list_equal(prices1: *mut PriceList, prices2: *mut PriceList) -> gboolean;
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct gnc_price_db_s {
    _unused: [u8; 0],
}
#[doc = " @addtogroup PriceDB\nWhenever a you store a price in the pricedb, the pricedb adds its\nown reference to the price, so you can safely unref that price after\ninserting it into the DB if you're finished with it otherwise.\n\nSimilarly, when the pricedb returns a price to you, either singly,\nor in a price list, the price will have had a ref added for you, so\nyou only need to unref the price(s) when you're finished with\nit/them.\n@{\n/\n/** Data type"]
pub type GNCPriceDB = gnc_price_db_s;
unsafe extern "C" {
    #[doc = " @brief Return the pricedb associated with the book\n @param book The QofBook holding the pricedb\n @return The GNCPriceDB associated with the book."]
    pub fn gnc_pricedb_get_db(book: *mut QofBook) -> *mut GNCPriceDB;
}
unsafe extern "C" {
    #[doc = " @brief Return the pricedb via the Book's collection.\n @param col The QofCollection holding the pricedb\n @return The GNCPriceDB in the QofCollection"]
    pub fn gnc_collection_get_pricedb(col: *mut QofCollection) -> *mut GNCPriceDB;
}
unsafe extern "C" {
    #[doc = " @brief Destroy the given pricedb and unref all of the prices it contains.\n\n This may not deallocate all of those prices.  Other code may still be holding\n references to them.\n @param db The pricedb to destroy."]
    pub fn gnc_pricedb_destroy(db: *mut GNCPriceDB);
}
unsafe extern "C" {
    #[doc = " @brief Begin an edit."]
    pub fn gnc_pricedb_begin_edit(arg1: *mut GNCPriceDB);
}
unsafe extern "C" {
    #[doc = " @brief Commit an edit."]
    pub fn gnc_pricedb_commit_edit(arg1: *mut GNCPriceDB);
}
unsafe extern "C" {
    #[doc = " @brief Set flag to indicate whether duplication checks should be performed.\n\n Normally used at load time to speed up loading the pricedb.\n @param db The pricedb\n @param bulk_update TRUE to disable duplication checks, FALSE to enable them."]
    pub fn gnc_pricedb_set_bulk_update(db: *mut GNCPriceDB, bulk_update: gboolean);
}
unsafe extern "C" {
    #[doc = " @brief Add a price to the pricedb.\n\n You may drop your reference to the price (i.e. call unref) after this\n succeeds, whenever you're finished with the price.\n @param db The pricedb\n @param p The GNCPrice to add.\n @return TRUE if the price was added, FALSE otherwise."]
    pub fn gnc_pricedb_add_price(db: *mut GNCPriceDB, p: *mut GNCPrice) -> gboolean;
}
unsafe extern "C" {
    #[doc = " @brief Remove a price from the pricedb and unref the price.\n @param db The Pricedb\n @param p The price to remove."]
    pub fn gnc_pricedb_remove_price(db: *mut GNCPriceDB, p: *mut GNCPrice) -> gboolean;
}
pub const PriceRemoveSourceFlags_PRICE_REMOVE_SOURCE_FQ: PriceRemoveSourceFlags = 1;
pub const PriceRemoveSourceFlags_PRICE_REMOVE_SOURCE_USER: PriceRemoveSourceFlags = 2;
pub const PriceRemoveSourceFlags_PRICE_REMOVE_SOURCE_APP: PriceRemoveSourceFlags = 4;
pub const PriceRemoveSourceFlags_PRICE_REMOVE_SOURCE_COMM: PriceRemoveSourceFlags = 8;
pub type PriceRemoveSourceFlags = ::std::os::raw::c_uint;
pub const PriceRemoveKeepOptions_PRICE_REMOVE_KEEP_NONE: PriceRemoveKeepOptions = 0;
pub const PriceRemoveKeepOptions_PRICE_REMOVE_KEEP_LAST_WEEKLY: PriceRemoveKeepOptions = 1;
pub const PriceRemoveKeepOptions_PRICE_REMOVE_KEEP_LAST_MONTHLY: PriceRemoveKeepOptions = 2;
pub const PriceRemoveKeepOptions_PRICE_REMOVE_KEEP_LAST_QUARTERLY: PriceRemoveKeepOptions = 3;
pub const PriceRemoveKeepOptions_PRICE_REMOVE_KEEP_LAST_PERIOD: PriceRemoveKeepOptions = 4;
pub const PriceRemoveKeepOptions_PRICE_REMOVE_KEEP_SCALED: PriceRemoveKeepOptions = 5;
pub type PriceRemoveKeepOptions = ::std::os::raw::c_uint;
unsafe extern "C" {
    #[doc = " @brief Remove and unref prices older than a certain time.\n @param db The pricedb\n @param comm_list A list of commodities\n @param fiscal_end_date the end date of the current accounting period\n @param cutoff The time before which prices should be deleted.\n @param source Whether Finance::Quote, user or all prices should be deleted.\n @param keep Whether scaled, monthly, weekly or no prices should be left.\n @return True if there were prices to process, False if not."]
    pub fn gnc_pricedb_remove_old_prices(
        db: *mut GNCPriceDB,
        comm_list: *mut GList,
        fiscal_end_date: *mut GDate,
        cutoff: time64,
        source: PriceRemoveSourceFlags,
        keep: PriceRemoveKeepOptions,
    ) -> gboolean;
}
unsafe extern "C" {
    #[doc = " @brief Find the most recent price between the two commodities.\n\n The returned GNCPrice may be in either direction so check to ensure that its\n value is correctly applied.\n @param db The pricedb\n @param commodity The first commodity\n @param currency The second commodity\n @return A GNCPrice or NULL if no price exists."]
    pub fn gnc_pricedb_lookup_latest(
        db: *mut GNCPriceDB,
        commodity: *const gnc_commodity,
        currency: *const gnc_commodity,
    ) -> *mut GNCPrice;
}
unsafe extern "C" {
    #[doc = " @brief Find the most recent price between a commodity and all other\n commodities\n\n The returned GNCPrices may be in either direction so check to ensure that\n their values are correctly applied.\n @param db The pricedb\n @param commodity The commodity for which to obtain prices\n @return A PriceList of prices found, or NULL if none found."]
    pub fn gnc_pricedb_lookup_latest_any_currency(
        db: *mut GNCPriceDB,
        commodity: *const gnc_commodity,
    ) -> *mut PriceList;
}
unsafe extern "C" {
    #[doc = " @brief Report whether the pricedb contains prices for one commodity in\n another.\n\n Does *not* check the reverse direction.\n @param db The pricedb to check\n @param commodity The commodity to check for the existence of prices\n @param currency The commodity in which prices are sought. If NULL reports all\n commodities.\n @return TRUE if matching prices are found, FALSE otherwise."]
    pub fn gnc_pricedb_has_prices(
        db: *mut GNCPriceDB,
        commodity: *const gnc_commodity,
        currency: *const gnc_commodity,
    ) -> gboolean;
}
unsafe extern "C" {
    #[doc = " @brief Return all the prices for a given commodity in another.\n\n Does *not* retrieve reverse prices, i.e. prices of the second commodity in\n the first.\n @param db The pricedb from which to retrieve prices.\n @param commodity The commodity for which prices should be retrieved.\n @param currency The commodity in which prices should be quoted. If NULL, all\n prices in any commodity are included.\n @return A PriceList of matching prices or NULL if none were found."]
    pub fn gnc_pricedb_get_prices(
        db: *mut GNCPriceDB,
        commodity: *const gnc_commodity,
        currency: *const gnc_commodity,
    ) -> *mut PriceList;
}
unsafe extern "C" {
    #[doc = " @brief Return the price between the two commodities on the indicated\n day. Note that the notion of day might be distorted by changes in timezone.\n\n The returned GNCPrice may be in either direction so check to ensure that its\n value is correctly applied.\n @param db The pricedb\n @param commodity The first commodity\n @param currency The second commodity\n @param t A time. The price returned will be in the same day as this time\n according to the local timezone.\n @return A GNCPrice or NULL on failure."]
    pub fn gnc_pricedb_lookup_day_t64(
        db: *mut GNCPriceDB,
        commodity: *const gnc_commodity,
        currency: *const gnc_commodity,
        t: time64,
    ) -> *mut GNCPrice;
}
unsafe extern "C" {
    #[doc = " @brief Return the price between the two commoditiesz nearest to the given\n time.\n\n The returned GNCPrice may be in either direction so check to ensure that its\n value is correctly applied.\n @param db The pricedb\n @param c The first commodity\n @param currency The second commodity\n @param t The time nearest to which the returned price should be.\n @return A GNCPrice or NULL if no prices exist between the two commodities."]
    pub fn gnc_pricedb_lookup_nearest_in_time64(
        db: *mut GNCPriceDB,
        c: *const gnc_commodity,
        currency: *const gnc_commodity,
        t: time64,
    ) -> *mut GNCPrice;
}
unsafe extern "C" {
    #[doc = " @brief Return the price nearest in time to that given between the given\n commodity and every other.\n\n The returned GNCPrices may be in either direction so check to ensure that\n their values are correctly applied.\n\n @param db, The pricedb\n @param c, The commodity for which prices should be obtained.\n @param t, The time nearest to which the prices should be obtained.\n @return A PriceList of prices for each commodity pair found or NULL if none\n are."]
    pub fn gnc_pricedb_lookup_nearest_in_time_any_currency_t64(
        db: *mut GNCPriceDB,
        c: *const gnc_commodity,
        t: time64,
    ) -> *mut PriceList;
}
unsafe extern "C" {
    #[doc = " @brief Return the nearest price between the given commodities before the\n given time.\n\n The returned GNCPrice may be in either direction so check to ensure that its\n value is correctly applied.\n @param db The pricedb\n @param c The first commodity\n @param currency The second commodity\n @param t The time before which to find the price\n @return A GNCPrice or NULL if no prices are found before t."]
    pub fn gnc_pricedb_lookup_nearest_before_t64(
        db: *mut GNCPriceDB,
        c: *const gnc_commodity,
        currency: *const gnc_commodity,
        t: time64,
    ) -> *mut GNCPrice;
}
unsafe extern "C" {
    #[doc = " @brief Return the nearest price between the given commodity and any other\n before the given time.\n\n The returned GNCPrice may be in either direction so check to ensure that its\n value is correctly applied.\n @param db The pricedb\n @param c The commodity\n @param t The time before which to find prices\n @return A PriceList of prices for each commodity found or NULL if none are."]
    pub fn gnc_pricedb_lookup_nearest_before_any_currency_t64(
        db: *mut GNCPriceDB,
        c: *const gnc_commodity,
        t: time64,
    ) -> *mut PriceList;
}
unsafe extern "C" {
    #[doc = " @brief Retrieve the price one currency to another using the price\n nearest to before the given time.\n @param pdb The pricedb\n @param orig_currency The commodity in which the balance is currently\n expressed\n @param new_currency The commodity to which the balance should be converted\n @param t The time to be used for for comparison\n @return A price, or gnc_numeric_zero if no price is available."]
    pub fn gnc_pricedb_get_nearest_before_price(
        pdb: *mut GNCPriceDB,
        orig_currency: *const gnc_commodity,
        new_currency: *const gnc_commodity,
        t: time64,
    ) -> gnc_numeric;
}
unsafe extern "C" {
    #[doc = " @brief Retrieve the price one currency to another using the price\n nearest to the given time\n @param pdb The pricedb\n @param orig_currency The commodity in which the balance is currently\n expressed\n @param new_currency The commodity to which the balance should be converted\n @param t The time in which the nearest price should be used.\n @return A price, or gnc_numeric_zero if no price is available."]
    pub fn gnc_pricedb_get_nearest_price(
        pdb: *mut GNCPriceDB,
        orig_currency: *const gnc_commodity,
        new_currency: *const gnc_commodity,
        t: time64,
    ) -> gnc_numeric;
}
unsafe extern "C" {
    #[doc = " @brief Retrieve the price one currency to another using the latest price\n @param pdb The pricedb\n @param orig_currency The commodity in which the balance is currently\n expressed\n @param new_currency The commodity to which the balance should be converted\n @return A price, or gnc_numeric_zero if no price is available."]
    pub fn gnc_pricedb_get_latest_price(
        pdb: *mut GNCPriceDB,
        orig_currency: *const gnc_commodity,
        new_currency: *const gnc_commodity,
    ) -> gnc_numeric;
}
unsafe extern "C" {
    #[doc = " @brief Convert a balance from one currency to another using the most recent\n price between the two.\n @param pdb The pricedb\n @param balance The balance to be converted\n @param balance_currency The commodity in which the balance is currently\n expressed\n @param new_currency The commodity to which the balance should be converted\n @return A new balance or gnc_numeric_zero if no price is available."]
    pub fn gnc_pricedb_convert_balance_latest_price(
        pdb: *mut GNCPriceDB,
        balance: gnc_numeric,
        balance_currency: *const gnc_commodity,
        new_currency: *const gnc_commodity,
    ) -> gnc_numeric;
}
unsafe extern "C" {
    #[doc = " @brief Convert a balance from one currency to another using the price\n nearest to the given time.\n @param pdb The pricedb\n @param balance The balance to be converted\n @param balance_currency The commodity in which the balance is currently\n expressed\n @param new_currency The commodity to which the balance should be converted\n @param t The time nearest to which price should be used.\n @return A new balance or gnc_numeric_zero if no price is available."]
    pub fn gnc_pricedb_convert_balance_nearest_price_t64(
        pdb: *mut GNCPriceDB,
        balance: gnc_numeric,
        balance_currency: *const gnc_commodity,
        new_currency: *const gnc_commodity,
        t: time64,
    ) -> gnc_numeric;
}
unsafe extern "C" {
    #[doc = " @brief Convert a balance from one currency to another using the price\n nearest to before the given time.\n @param pdb The pricedb\n @param balance The balance to be converted\n @param balance_currency The commodity in which the balance is currently\n expressed\n @param new_currency The commodity to which the balance should be converted\n @param t The time in which the last price before it should be used.\n @return A new balance or gnc_numeric_zero if no price is available."]
    pub fn gnc_pricedb_convert_balance_nearest_before_price_t64(
        pdb: *mut GNCPriceDB,
        balance: gnc_numeric,
        balance_currency: *const gnc_commodity,
        new_currency: *const gnc_commodity,
        t: time64,
    ) -> gnc_numeric;
}
pub type GncPriceForeachFunc =
    ::std::option::Option<unsafe extern "C" fn(p: *mut GNCPrice, user_data: gpointer) -> gboolean>;
unsafe extern "C" {
    #[doc = " @brief Call a GncPriceForeachFunction once for each price in db, until the\n function returns FALSE.\n\n If stable_order is not FALSE, make sure the ordering of the traversal is\n stable (i.e. the same order every time given the same db contents -- stable\n traversals may be less efficient).\n @param db The pricedb\n @param f The function to call\n @param user_data A data to pass to each invocation of f\n @param stable_order Ensure that the traversal is performed in the same order\n each time.\n @return TRUE if all calls to f succeeded (unstable) or if the order of\n processing was the same as the previous invocation (stable), FALSE otherwise."]
    pub fn gnc_pricedb_foreach_price(
        db: *mut GNCPriceDB,
        f: GncPriceForeachFunc,
        user_data: gpointer,
        stable_order: gboolean,
    ) -> gboolean;
}
unsafe extern "C" {
    #[doc = " @brief Get the number of prices, in any currency, for a given commodity.\n @param db The pricedb\n @param c The commodity\n @return The number of prices in the database for this commody, zero if none"]
    pub fn gnc_pricedb_num_prices(
        db: *mut GNCPriceDB,
        c: *const gnc_commodity,
    ) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    #[doc = " @brief Get the nth price for the given commodity in  reverse date order\n @param db The pricedb\n @param c The commodity whose nth price is needed\n @param n Zero based index of the price wanted\n @return The nth price for this commodity in reverse chronological order, without\n regard for what currency the price is in"]
    pub fn gnc_pricedb_nth_price(
        db: *mut GNCPriceDB,
        c: *const gnc_commodity,
        n: ::std::os::raw::c_int,
    ) -> *mut GNCPrice;
}
unsafe extern "C" {
    pub fn gnc_pricedb_nth_price_reset_cache(db: *mut GNCPriceDB);
}
unsafe extern "C" {
    #[doc = " @brief Return the number of prices in the database.\n\n For XML Backend Testing"]
    pub fn gnc_pricedb_get_num_prices(db: *mut GNCPriceDB) -> guint;
}
unsafe extern "C" {
    #[doc = " @brief Test equality of two pricedbs\n\n For XML Backend Testing"]
    pub fn gnc_pricedb_equal(db1: *mut GNCPriceDB, db2: *mut GNCPriceDB) -> gboolean;
}
unsafe extern "C" {
    #[doc = " @name Internal/Debugging\n@{ */\n/** This simple function can be useful for debugging the pricedb code"]
    pub fn gnc_pricedb_print_contents(db: *mut GNCPriceDB, f: *mut FILE);
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _SplitClass {
    _unused: [u8; 0],
}
pub type SplitClass = _SplitClass;
unsafe extern "C" {
    pub fn gnc_split_get_type() -> GType;
}
unsafe extern "C" {
    #[doc = " @}"]
    pub fn xaccSplitConvertAmount(split: *const Split, account: *const Account) -> gnc_numeric;
}
unsafe extern "C" {
    #[doc = " Constructor."]
    pub fn xaccMallocSplit(book: *mut QofBook) -> *mut Split;
}
unsafe extern "C" {
    pub fn xaccSplitReinit(split: *mut Split);
}
unsafe extern "C" {
    #[doc = " Destructor.\n\n The xaccSplitDestroy() method will update its parent account and\n transaction in a consistent manner, resulting in the complete\n unlinking of the split, and the freeing of its associated memory.\n The goal of this routine is to perform the removal and destruction\n of the split in an atomic fashion, with no chance of accidentally\n leaving the accounting structure out-of-balance or otherwise\n inconsistent.\n\n It begins and commits an edit on the transaction, so if after the\n split is removed the transaction has no more splits and if is not\n open it too will be destroyed, as it will if the outer edits are\n committed without adding transactions.\n\n @return TRUE upon successful deletion of the split. FALSE when\n the parenting Transaction is a read-only one."]
    pub fn xaccSplitDestroy(split: *mut Split) -> gboolean;
}
unsafe extern "C" {
    #[doc = " This is really a helper for xaccTransCopyOnto. It doesn't reparent\n   the 'to' split to from's transaction, because xaccTransCopyOnto is\n   responsible for parenting the split to the correct transaction.\n   Also, from's parent transaction may not even be a valid\n   transaction, so this function may not modify anything about 'from'\n   or from's transaction."]
    pub fn xaccSplitCopyOnto(from_split: *const Split, to_split: *mut Split);
}
unsafe extern "C" {
    #[doc = " Returns the book of this split, i.e. the entity where this split\n is stored."]
    pub fn xaccSplitGetBook(split: *const Split) -> *mut QofBook;
}
unsafe extern "C" {
    #[doc = " Returns the account of this split, which was set through\n xaccAccountInsertSplit()."]
    pub fn xaccSplitGetAccount(split: *const Split) -> *mut Account;
}
unsafe extern "C" {
    pub fn xaccSplitSetAccount(s: *mut Split, acc: *mut Account);
}
unsafe extern "C" {
    #[doc = " Returns the parent transaction of the split."]
    pub fn xaccSplitGetParent(split: *const Split) -> *mut Transaction;
}
unsafe extern "C" {
    pub fn xaccSplitSetParent(split: *mut Split, trans: *mut Transaction);
}
unsafe extern "C" {
    #[doc = " Returns the pointer to the debited/credited Lot where this split\n belongs to, or NULL if it doesn't belong to any."]
    pub fn xaccSplitGetLot(split: *const Split) -> *mut GNCLot;
}
unsafe extern "C" {
    #[doc = " Assigns the split to a specific Lot"]
    pub fn xaccSplitSetLot(split: *mut Split, lot: *mut GNCLot);
}
unsafe extern "C" {
    #[doc = " The memo is an arbitrary string associated with a split.  It is\n intended to hold a short (zero to forty character) string that is\n displayed by the GUI along with this split.  Users typically type\n in free form text from the GUI."]
    pub fn xaccSplitSetMemo(split: *mut Split, memo: *const ::std::os::raw::c_char);
}
unsafe extern "C" {
    #[doc = " Returns the memo string."]
    pub fn xaccSplitGetMemo(split: *const Split) -> *const ::std::os::raw::c_char;
}
unsafe extern "C" {
    #[doc = " The Action is an arbitrary user-assigned string.\n The action field is an arbitrary user-assigned value.\n It is meant to be a very short (one to ten character) string that\n signifies the \"type\" of this split, such as e.g. Buy, Sell, Div,\n Withdraw, Deposit, ATM, Check, etc. The idea is that this field\n can be used to create custom reports or graphs of data. Note that the\n business features auto-fill this value, but doesn't depend on it. Rather than use\n this function directly, see 'gnc_set_num_action' in\n engine/engine-helpers.c & .h which takes a user-set book option for selecting\n the source for the num-cell (the transaction-number or the split-action field)\n in registers/reports into account automatically"]
    pub fn xaccSplitSetAction(split: *mut Split, action: *const ::std::os::raw::c_char);
}
unsafe extern "C" {
    #[doc = " Returns the action string. Rather than use this function directly, see\n 'gnc_get_num_action' and 'gnc_get_action_num'in\n engine/engine-helpers.c & .h which takes a user-set book option for selecting\n the source for the num-cell (the transaction-number or the split-action field)\n in registers/reports into account automatically"]
    pub fn xaccSplitGetAction(split: *const Split) -> *const ::std::os::raw::c_char;
}
unsafe extern "C" {
    #[doc = " @name Split Date getters/setters\n@{\n/\n/** Set the reconcile flag. The Reconcile flag is a single char, whose\n values are typically are 'n', 'y', 'c'.  In Transaction.h, macros\n are defined for typical values (e.g. CREC, YREC)."]
    pub fn xaccSplitSetReconcile(split: *mut Split, reconciled_flag: ::std::os::raw::c_char);
}
unsafe extern "C" {
    #[doc = " Returns the value of the reconcile flag."]
    pub fn xaccSplitGetReconcile(split: *const Split) -> ::std::os::raw::c_char;
}
unsafe extern "C" {
    #[doc = " Set the date on which this split was reconciled by specifying the\n time as time64."]
    pub fn xaccSplitSetDateReconciledSecs(split: *mut Split, time: time64);
}
unsafe extern "C" {
    #[doc = " Retrieve the date when the Split was reconciled."]
    pub fn xaccSplitGetDateReconciled(split: *const Split) -> time64;
}
unsafe extern "C" {
    #[doc = " The xaccSplitSetAmount() method sets the amount in the account's\n commodity that the split should have.\n\n The following four setter functions set the prices and amounts.\n All of the routines always maintain balance: that is, invoking any\n of them will cause other splits in the transaction to be modified\n so that the net value of the transaction is zero.\n\n IMPORTANT: The split should be parented by an account before\n any of these routines are invoked!  This is because the actual\n setting of amounts/values requires SCU settings from the account.\n If these are not available, then amounts/values will be set to\n -1/0, which is an invalid value.  I believe this order dependency\n is a bug, but I'm too lazy to find, fix & test at the moment ...\n\n @note If you use this on a newly created transaction, make sure\n that the 'value' is also set so that it doesn't remain zero."]
    pub fn xaccSplitSetAmount(split: *mut Split, amount: gnc_numeric);
}
unsafe extern "C" {
    #[doc = " Returns the amount of the split in the account's commodity.\n   Note that for cap-gains splits, this is slaved to the transaction\n   that is causing the gains to occur."]
    pub fn xaccSplitGetAmount(split: *const Split) -> gnc_numeric;
}
unsafe extern "C" {
    #[doc = " The xaccSplitSetValue() method sets the value of this split in the\n transaction's commodity.\n\n @note If you use this on a newly created transaction, make sure\n that the 'amount' is also set so that it doesn't remain zero."]
    pub fn xaccSplitSetValue(split: *mut Split, value: gnc_numeric);
}
unsafe extern "C" {
    #[doc = " Returns the value of this split in the transaction's commodity.\n   Note that for cap-gains splits, this is slaved to the transaction\n   that is causing the gains to occur."]
    pub fn xaccSplitGetValue(split: *const Split) -> gnc_numeric;
}
unsafe extern "C" {
    #[doc = " The xaccSplitSetSharePriceAndAmount() method will simultaneously\n update the share price and the number of shares. This is a utility\n routine that is equivalent to a xaccSplitSetSharePrice() followed\n by and xaccSplitSetAmount(), except that it incurs the processing\n overhead of balancing only once, instead of twice."]
    pub fn xaccSplitSetSharePriceAndAmount(
        split: *mut Split,
        price: gnc_numeric,
        amount: gnc_numeric,
    );
}
unsafe extern "C" {
    #[doc = " Returns the price of the split, that is, the value divided by the\n amount. If the amount is zero, returns a gnc_numeric of value\n one."]
    pub fn xaccSplitGetSharePrice(split: *const Split) -> gnc_numeric;
}
unsafe extern "C" {
    #[doc = " Depending on the base_currency, set either the value or the amount\n of this split or both: If the base_currency is the transaction's\n commodity, set the value.  If it is the account's commodity, set the\n amount. If both, set both.\n\n @note <b>WATCH OUT:</b> When using this function and the\n transaction's and account's commodities are different, the amount\n or the value will be left as zero. This might screw up the\n multi-currency handling code in the register. So please think twice\n whether you need this function -- using xaccSplitSetValue()\n together with xaccSplitSetAmount() is definitely the better and\n safer solution!"]
    pub fn xaccSplitSetBaseValue(
        split: *mut Split,
        value: gnc_numeric,
        base_currency: *const gnc_commodity,
    );
}
unsafe extern "C" {
    #[doc = " Depending on the base_currency, return either the value or the\n amount of this split: If the base_curreny is the transaction's\n commodity, return the value. If it is the account's commodity,\n return the amount. If it is neither print a warning message and\n return gnc_numeric_zero()."]
    pub fn xaccSplitGetBaseValue(
        split: *const Split,
        base_currency: *const gnc_commodity,
    ) -> gnc_numeric;
}
unsafe extern "C" {
    #[doc = " Returns the running balance up to and including the indicated split.\n The balance is the currency-denominated balance.  For accounts\n with non-unit share prices, it is correctly adjusted for\n share prices.\n\n Returns the running balance up to & including the indicated split."]
    pub fn xaccSplitGetBalance(split: *const Split) -> gnc_numeric;
}
unsafe extern "C" {
    #[doc = " The noclosing-balance is the currency-denominated balance of all\n transactions except 'closing' transactions. It is correctly\n adjusted for price fluctuations.\n\n Returns the running balance up to & including the indicated split."]
    pub fn xaccSplitGetNoclosingBalance(split: *const Split) -> gnc_numeric;
}
unsafe extern "C" {
    #[doc = " The cleared-balance is the currency-denominated balance\n of all transactions that have been marked as cleared or reconciled.\n It is correctly adjusted for price fluctuations.\n\n Returns the running balance up to & including the indicated split."]
    pub fn xaccSplitGetClearedBalance(split: *const Split) -> gnc_numeric;
}
unsafe extern "C" {
    #[doc = " Returns the reconciled-balance of this split. The\n reconciled-balance is the currency-denominated balance of all\n transactions that have been marked as reconciled.\n\n Returns the running balance up to & including the indicated split."]
    pub fn xaccSplitGetReconciledBalance(split: *const Split) -> gnc_numeric;
}
unsafe extern "C" {
    #[doc = " Equality.\n\n @param sa First split to compare\n @param sb Second split to compare\n\n @param check_guids If TRUE, try a guid_equal() on the GUIDs of both\n splits if their pointers are not equal in the first place.\n\n @param check_balances If TRUE, compare balances between the two\n splits.  Balances are recalculated whenever a split is added or\n removed from an account, so YMMV on whether this should be set.\n\n @param check_txn_splits If the pointers are not equal, but\n everything else so far is equal (including memo, amount, value,\n kvp), then, when comparing the parenting transactions with\n xaccTransEqual(), set its argument check_splits to be TRUE."]
    pub fn xaccSplitEqual(
        sa: *const Split,
        sb: *const Split,
        check_guids: gboolean,
        check_balances: gboolean,
        check_txn_splits: gboolean,
    ) -> gboolean;
}
unsafe extern "C" {
    #[doc = " The xaccSplitLookup() subroutine will return the\n    split associated with the given id, or NULL\n    if there is no such split."]
    pub fn xaccSplitLookup(guid: *const GncGUID, book: *mut QofBook) -> *mut Split;
}
unsafe extern "C" {
    #[doc = " Add a peer split to this split's lot-split list.\n @param other_split: The split whose guid to add\n @param timestamp: The time to be recorded for the split."]
    pub fn xaccSplitAddPeerSplit(split: *mut Split, other_split: *const Split, timestamp: time64);
}
unsafe extern "C" {
    #[doc = " Does this split have peers?"]
    pub fn xaccSplitHasPeers(split: *const Split) -> gboolean;
}
unsafe extern "C" {
    #[doc = " Report if a split is a peer of this one.\n @param other_split: The split to test for being a peer of this one.\n @return: True if other_split is registered as a peer of this one."]
    pub fn xaccSplitIsPeerSplit(split: *const Split, other_split: *const Split) -> gboolean;
}
unsafe extern "C" {
    #[doc = " Remove a peer split from this split's lot-split list.\n @param other_split: The split whose guid to remove"]
    pub fn xaccSplitRemovePeerSplit(split: *mut Split, other_split: *const Split);
}
unsafe extern "C" {
    #[doc = " Merge the other_split's peer splits into split's peers.\n @param other_split: The split donating the peer splits."]
    pub fn xaccSplitMergePeerSplits(split: *mut Split, other_split: *const Split);
}
unsafe extern "C" {
    #[doc = " The xaccSplitGetOtherSplit() is a convenience routine that returns\n    the other of a pair of splits.  If there are more than two\n    splits, it returns NULL."]
    pub fn xaccSplitGetOtherSplit(split: *const Split) -> *mut Split;
}
unsafe extern "C" {
    #[doc = " The xaccIsPeerSplit() is a convenience routine that returns TRUE\n (a non-zero value) if the two splits share a common parent\n transaction, else it returns FALSE (zero).\n\ngboolean xaccIsPeerSplit (const Split *split_1, const Split *split_2);\n/\n/** Returns the split type, which is either the string \"normal\", or\n \"stock-split\" for a split from a stock split (pun intended? :-)."]
    pub fn xaccSplitGetType(s: *const Split) -> *const ::std::os::raw::c_char;
}
unsafe extern "C" {
    #[doc = " Mark a split to be of type stock split - after this, you shouldn't\nmodify the value anymore, just the amount."]
    pub fn xaccSplitMakeStockSplit(s: *mut Split);
}
unsafe extern "C" {
    #[doc = " The xaccSplitOrder(sa,sb) method is useful for sorting.\n    if sa and sb have different transactions, return their xaccTransOrder\n    return a negative value if split sa has a smaller currency-value than sb,\n    return a positive value if split sa has a larger currency-value than sb,\n    return a negative value if split sa has a smaller share-price than sb,\n    return a positive value if split sa has a larger share-price than sb,\n    then compares memo and action using the strcmp()\n    c-library routine, returning  what strcmp would return.\n    Then it compares the reconciled flags, then the reconciled dates,\n    Finally, it returns zero if all of the above match."]
    pub fn xaccSplitOrder(sa: *const Split, sb: *const Split) -> gint;
}
unsafe extern "C" {
    pub fn xaccSplitOrderDateOnly(sa: *const Split, sb: *const Split) -> gint;
}
unsafe extern "C" {
    #[doc = " Compare two splits by full name of account. Returns similar to\n strcmp."]
    pub fn xaccSplitCompareAccountFullNames(
        sa: *const Split,
        sb: *const Split,
    ) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    #[doc = " Compare two splits by code of account. Returns similar to\n strcmp."]
    pub fn xaccSplitCompareAccountCodes(
        sa: *const Split,
        sb: *const Split,
    ) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    #[doc = " Compare two splits by full name of the other account. Returns\n similar to strcmp. This function attempts to find the split on the\n other side of a transaction and compare on it."]
    pub fn xaccSplitCompareOtherAccountFullNames(
        sa: *const Split,
        sb: *const Split,
    ) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    #[doc = " Compare two splits by code of the other account. Returns similar\n to strcmp. This function attempts to find the split on the\n other side of a transaction and compare on it."]
    pub fn xaccSplitCompareOtherAccountCodes(
        sa: *const Split,
        sb: *const Split,
    ) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    #[doc = " These functions take a split, get the corresponding split on the\n \"other side\" of the transaction, and extract either the name or code\n of that split, reverting to returning a constant \"Split\" if the\n transaction has more than one split on the \"other side\".  These\n were added for the transaction report, and is in C because the code\n was already written in C for the above functions and duplication\n is silly.\n\n Note that this will only return a real value in case of a\n two-split transaction as that is the only situation in which\n a reliable value can be returned. In other situations\n \"-- Split Transaction --\" will be returned as Account Name\n or \"Split\" for Account Code."]
    pub fn xaccSplitGetCorrAccountFullName(sa: *const Split) -> *mut ::std::os::raw::c_char;
}
unsafe extern "C" {
    #[doc = " document me"]
    pub fn xaccSplitGetCorrAccountName(sa: *const Split) -> *const ::std::os::raw::c_char;
}
unsafe extern "C" {
    #[doc = " document me"]
    pub fn xaccSplitGetCorrAccountCode(sa: *const Split) -> *const ::std::os::raw::c_char;
}
unsafe extern "C" {
    #[doc = " @deprecated The xaccSplitSetSharePrice() method sets the price of the\n split. DEPRECATED - set the value and amount instead."]
    pub fn xaccSplitSetSharePrice(split: *mut Split, price: gnc_numeric);
}
unsafe extern "C" {
    #[doc = " Returns the original pre-void amount of a split.\n\n  @param split The split in question.\n\n  @return A gnc_numeric containing the original value of this split.\n  Returns a gnc_numeric of zero upon error."]
    pub fn xaccSplitVoidFormerAmount(split: *const Split) -> gnc_numeric;
}
unsafe extern "C" {
    #[doc = " Returns the original pre-void value of a split.\n\n  @param split The split in question.\n\n  @return A gnc_numeric containing the original amount of this split.\n  Returns a gnc_numeric of zero upon error."]
    pub fn xaccSplitVoidFormerValue(split: *const Split) -> gnc_numeric;
}
unsafe extern "C" {
    pub fn gnc_transaction_get_type() -> GType;
}
unsafe extern "C" {
    #[doc = " @name Transaction creation and editing\n@{\n/\n/**\nThe xaccMallocTransaction() will malloc memory and initialize it.\nOnce created, it is usually unsafe to merely \"free\" this memory;\nthe xaccTransDestroy() method should be called."]
    pub fn xaccMallocTransaction(book: *mut QofBook) -> *mut Transaction;
}
unsafe extern "C" {
    #[doc = " Destroys a transaction.\n  Each split in transaction @a trans is removed from its\n  account and destroyed as well.\n\n  If the transaction has not already been opened for editing with\n  ::xaccTransBeginEdit() then the changes are committed immediately.\n  Otherwise, the caller must follow up with either\n  ::xaccTransCommitEdit(), in which case the transaction and\n  split memory will be freed, or xaccTransRollbackEdit(), in which\n  case nothing at all is freed, and everything is put back into\n  original order.\n\n  @param trans the transaction to destroy"]
    pub fn xaccTransDestroy(trans: *mut Transaction);
}
unsafe extern "C" {
    #[doc = "The xaccTransClone() method will create a complete copy of an\nexisting transaction."]
    pub fn xaccTransClone(t: *const Transaction) -> *mut Transaction;
}
unsafe extern "C" {
    #[doc = "The xaccTransCloneNoKvp() method will create a complete copy of an\nexisting transaction except that the KVP slots will be empty."]
    pub fn xaccTransCloneNoKvp(t: *const Transaction) -> *mut Transaction;
}
unsafe extern "C" {
    #[doc = " Equality.\n\n @param ta First transaction to compare\n @param tb Second transaction to compare\n\n @param check_guids If TRUE, try a guid_equal() on the GUIDs of both\n transactions if their pointers are not equal in the first place.\n Also passed to subsidiary calls to xaccSplitEqual.\n\n @param check_splits If TRUE, after checking the transaction data\n structures for equality, also check all splits attached to the\n transaction for equality.\n\n @param check_balances If TRUE, when checking splits also compare\n balances between the two splits.  Balances are recalculated\n whenever a split is added or removed from an account, so YMMV on\n whether this should be set.\n\n @param assume_ordered If TRUE, assume that the splits in each\n transaction appear in the same order.  This saves some time looking\n up splits by GncGUID, and is required for checking duplicated\n transactions because all the splits have new GUIDs."]
    pub fn xaccTransEqual(
        ta: *const Transaction,
        tb: *const Transaction,
        check_guids: gboolean,
        check_splits: gboolean,
        check_balances: gboolean,
        assume_ordered: gboolean,
    ) -> gboolean;
}
unsafe extern "C" {
    #[doc = " The xaccTransBeginEdit() method must be called before any changes\nare made to a transaction or any of its component splits.  If\nthis is not done, errors will result."]
    pub fn xaccTransBeginEdit(trans: *mut Transaction);
}
unsafe extern "C" {
    #[doc = " The xaccTransCommitEdit() method indicates that the changes to the\ntransaction and its splits are complete and should be made\npermanent. Note this routine may result in the deletion of the\ntransaction, if the transaction is \"empty\" (has no splits), or\nof xaccTransDestroy() was called on the transaction."]
    pub fn xaccTransCommitEdit(trans: *mut Transaction);
}
unsafe extern "C" {
    #[doc = " The xaccTransRollbackEdit() routine rejects all edits made, and\nsets the transaction back to where it was before the editing\nstarted.  This includes restoring any deleted splits, removing\nany added splits, and undoing the effects of xaccTransDestroy,\nas well as restoring share quantities, memos, descriptions, etc."]
    pub fn xaccTransRollbackEdit(trans: *mut Transaction);
}
unsafe extern "C" {
    #[doc = " The xaccTransIsOpen() method returns TRUE if the transaction\nis open for editing. Otherwise, it returns false.\nXXX this routine should probably be deprecated.  its, umm,\nhard to imagine legitimate uses (but it is used by\nthe import/export code for reasons I can't understand.)"]
    pub fn xaccTransIsOpen(trans: *const Transaction) -> gboolean;
}
unsafe extern "C" {
    pub fn xaccTransLookup(guid: *const GncGUID, book: *mut QofBook) -> *mut Transaction;
}
unsafe extern "C" {
    #[doc = " Copy a transaction to the 'clipboard' transaction using\n  dupe_transaction. The 'clipboard' transaction must never\n  be dereferenced."]
    pub fn xaccTransCopyToClipBoard(from_trans: *const Transaction) -> *mut Transaction;
}
unsafe extern "C" {
    #[doc = " Copy a transaction to another using the function below without\n  changing any account information."]
    pub fn xaccTransCopyOnto(from_trans: *const Transaction, to_trans: *mut Transaction);
}
unsafe extern "C" {
    #[doc = " This function explicitly must robustly handle some unusual input.\n\n  'from_trans' may be a duped trans (see xaccDupeTransaction), so its\n   splits may not really belong to the accounts that they say they do.\n\n  'from_acc' need not be a valid account. It may be an already freed\n   Account. Therefore, it must not be dereferenced at all.\n\n   Neither 'from_trans', nor 'from_acc', nor any of 'from's splits may be modified\n   in any way.\n\n   'no_date' if TRUE will not copy the date posted.\n\n   The 'to_trans' transaction will end up with valid copies of from's\n   splits.  In addition, the copies of any of from's splits that were\n   in from_acc (or at least claimed to be) will end up in to_acc."]
    pub fn xaccTransCopyFromClipBoard(
        from_trans: *const Transaction,
        to_trans: *mut Transaction,
        from_acc: *const Account,
        to_acc: *mut Account,
        no_date: gboolean,
    );
}
unsafe extern "C" {
    pub fn xaccTransFindSplitByAccount(
        trans: *const Transaction,
        acc: *const Account,
    ) -> *mut Split;
}
unsafe extern "C" {
    #[doc = " The xaccTransScrubGains() routine performs a number of cleanup\n  functions on the indicated transaction, with the end-goal of\n  setting up a consistent set of gains/losses for all the splits\n  in the transaction.  This includes making sure that the lot\n  assignments of all the splits are good, and that the lots\n  balance appropriately."]
    pub fn xaccTransScrubGains(trans: *mut Transaction, gain_acc: *mut Account);
}
unsafe extern "C" {
    #[doc = " \\warning XXX FIXME\n gnc_book_count_transactions is a utility function,\n probably needs to be moved to a utility file somewhere."]
    pub fn gnc_book_count_transactions(book: *mut QofBook) -> guint;
}
unsafe extern "C" {
    #[doc = " Determine whether this transaction should use commodity trading accounts"]
    pub fn xaccTransUseTradingAccounts(trans: *const Transaction) -> gboolean;
}
unsafe extern "C" {
    #[doc = " Sorts the splits in a transaction, putting the debits first,\n  followed by the credits."]
    pub fn xaccTransSortSplits(trans: *mut Transaction);
}
unsafe extern "C" {
    #[doc = " Set the Transaction Type: note the type will be saved into the\n  Transaction kvp property as a backward compatibility measure, for\n  previous GnuCash versions whose xaccTransGetTxnType reads from the\n  kvp slots.\n\n See #TXN_TYPE_NONE, #TXN_TYPE_INVOICE and #TXN_TYPE_PAYMENT"]
    pub fn xaccTransSetTxnType(trans: *mut Transaction, type_: ::std::os::raw::c_char);
}
unsafe extern "C" {
    #[doc = " Returns the Transaction Type: note this type will be derived from\n the transaction splits, returning #TXN_TYPE_NONE,\n #TXN_TYPE_INVOICE, #TXN_TYPE_LINK, or #TXN_TYPE_PAYMENT according\n to heuristics. It does not query the transaction kvp slots.\n\n See #TXN_TYPE_NONE, #TXN_TYPE_INVOICE and #TXN_TYPE_PAYMENT"]
    pub fn xaccTransGetTxnType(trans: *mut Transaction) -> ::std::os::raw::c_char;
}
unsafe extern "C" {
    #[doc = " Sets the transaction Number (or ID) field; rather than use this function\n  directly, see 'gnc_set_num_action' in engine/engine-helpers.c & .h which\n  takes a user-set book option for selecting the source for the num-cell (the\n  transaction-number or the split-action field) in registers/reports into\n  account automatically"]
    pub fn xaccTransSetNum(trans: *mut Transaction, num: *const ::std::os::raw::c_char);
}
unsafe extern "C" {
    #[doc = " Sets the transaction Description"]
    pub fn xaccTransSetDescription(trans: *mut Transaction, desc: *const ::std::os::raw::c_char);
}
unsafe extern "C" {
    #[doc = " Sets the transaction Document Link"]
    pub fn xaccTransSetDocLink(trans: *mut Transaction, doclink: *const ::std::os::raw::c_char);
}
unsafe extern "C" {
    #[doc = " Sets the transaction Notes\n\nThe Notes field is only visible in the register in double-line mode"]
    pub fn xaccTransSetNotes(trans: *mut Transaction, notes: *const ::std::os::raw::c_char);
}
unsafe extern "C" {
    #[doc = " Gets the transaction Number (or ID) field; rather than use this function\n  directly, see 'gnc_get_num_action' and 'gnc_get_action_num' in\n  engine/engine-helpers.c & .h which takes a user-set book option for\n  selecting the source for the num-cell (the transaction-number or the\n  split-action field) in registers/reports into account automatically"]
    pub fn xaccTransGetNum(trans: *const Transaction) -> *const ::std::os::raw::c_char;
}
unsafe extern "C" {
    #[doc = " Gets the transaction Description"]
    pub fn xaccTransGetDescription(trans: *const Transaction) -> *const ::std::os::raw::c_char;
}
unsafe extern "C" {
    #[doc = " Gets the transaction Document Link"]
    pub fn xaccTransGetDocLink(trans: *const Transaction) -> *const ::std::os::raw::c_char;
}
unsafe extern "C" {
    #[doc = " Gets the transaction Notes\n\nThe Notes field is only visible in the register in double-line mode"]
    pub fn xaccTransGetNotes(trans: *const Transaction) -> *const ::std::os::raw::c_char;
}
unsafe extern "C" {
    #[doc = " Sets whether or not this transaction is a \"closing transaction\""]
    pub fn xaccTransSetIsClosingTxn(trans: *mut Transaction, is_closing: gboolean);
}
unsafe extern "C" {
    #[doc = " Returns whether this transaction is a \"closing transaction\""]
    pub fn xaccTransGetIsClosingTxn(trans: *const Transaction) -> gboolean;
}
unsafe extern "C" {
    #[doc = " Remove all splits from the transaction\n\n Clears the split list of the transaction. All splits that the\n transaction still owns will be destroyed, and others will be\n unlinked.\n\n Opens and commits an edit on the transaction, so this will destroy\n the transaction if it isn't already open, as will committing the\n outer edits if new splits are not added before hand."]
    pub fn xaccTransClearSplits(trans: *mut Transaction);
}
unsafe extern "C" {
    #[doc = " Return a pointer to the indexed split in this transaction's split list.\n\nNote that the split list is a linked list and that indexed access is\nO(N). Do not use this method for iteration.\n@param trans The transaction\n@param i The split number.  Valid values for i are zero to\n(number_of__splits-1).\n@return A Split* or NULL if i is out of range."]
    pub fn xaccTransGetSplit(trans: *const Transaction, i: ::std::os::raw::c_int) -> *mut Split;
}
unsafe extern "C" {
    #[doc = " Inverse of xaccTransGetSplit()"]
    pub fn xaccTransGetSplitIndex(
        trans: *const Transaction,
        split: *const Split,
    ) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn xaccTransGetSplitList(trans: *const Transaction) -> *mut SplitList;
}
unsafe extern "C" {
    #[doc = " The xaccTransGetPaymentAcctSplitList() method returns a GList of the splits\nin a transaction that belong to an account which is considered a\nvalid account for business payments.\n@param trans The transaction\n@return The list of splits. This list must be freed when you are done with it."]
    pub fn xaccTransGetPaymentAcctSplitList(trans: *const Transaction) -> *mut SplitList;
}
unsafe extern "C" {
    #[doc = " The xaccTransGetAPARSplitList() method returns a GList of the splits\nin a transaction that belong to an AR or AP account.\n@param trans The transaction\n@param strict This slightly modifies the test to only consider splits in an AR or AP account and the split is part of a business lot\n@return The list of splits. This list must be freed when you are done with it."]
    pub fn xaccTransGetAPARAcctSplitList(
        trans: *const Transaction,
        strict: gboolean,
    ) -> *mut SplitList;
}
unsafe extern "C" {
    pub fn xaccTransStillHasSplit(trans: *const Transaction, s: *const Split) -> gboolean;
}
unsafe extern "C" {
    #[doc = " The xaccTransGetFirstPaymentAcctSplit() method returns a pointer to the first\nsplit in this transaction that belongs to an account which is considered a\nvalid account for business payments.\n@param trans The transaction\n\nIf there is no such split in the transaction NULL will be returned."]
    pub fn xaccTransGetFirstPaymentAcctSplit(trans: *const Transaction) -> *mut Split;
}
unsafe extern "C" {
    #[doc = " The xaccTransGetFirstPaymentAcctSplit() method returns a pointer to the first\nsplit in this transaction that belongs to an AR or AP account.\n@param trans The transaction\n@param strict This slightly modifies the test to only consider splits in an AR or AP account and the split is part of a business lot\n\nIf there is no such split in the transaction NULL will be returned."]
    pub fn xaccTransGetFirstAPARAcctSplit(
        trans: *const Transaction,
        strict: gboolean,
    ) -> *mut Split;
}
unsafe extern "C" {
    #[doc = " Set the transaction to be ReadOnly by setting a non-NULL value as \"reason\".\n\n FIXME: If \"reason\" is NULL, this function does nothing, instead of removing the\n readonly flag; the actual removal is possible only through\n xaccTransClearReadOnly()."]
    pub fn xaccTransSetReadOnly(trans: *mut Transaction, reason: *const ::std::os::raw::c_char);
}
unsafe extern "C" {
    pub fn xaccTransClearReadOnly(trans: *mut Transaction);
}
unsafe extern "C" {
    #[doc = " Returns a non-NULL value if this Transaction was marked as read-only with\n some specific \"reason\" text."]
    pub fn xaccTransGetReadOnly(trans: *mut Transaction) -> *const ::std::os::raw::c_char;
}
unsafe extern "C" {
    #[doc = " Returns TRUE if this Transaction is read-only because its posted-date is\n older than the \"auto-readonly\" threshold of this book. See\n qof_book_uses_autofreeze() and qof_book_get_autofreeze_gdate()."]
    pub fn xaccTransIsReadonlyByPostedDate(trans: *const Transaction) -> gboolean;
}
unsafe extern "C" {
    #[doc = " Returns the number of splits in this transaction."]
    pub fn xaccTransCountSplits(trans: *const Transaction) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    #[doc = " FIXME: document me"]
    pub fn xaccTransHasReconciledSplits(trans: *const Transaction) -> gboolean;
}
unsafe extern "C" {
    #[doc = " FIXME: document me"]
    pub fn xaccTransHasReconciledSplitsByAccount(
        trans: *const Transaction,
        account: *const Account,
    ) -> gboolean;
}
unsafe extern "C" {
    #[doc = " FIXME: document me"]
    pub fn xaccTransHasSplitsInState(
        trans: *const Transaction,
        state: ::std::os::raw::c_char,
    ) -> gboolean;
}
unsafe extern "C" {
    #[doc = " FIXME: document me"]
    pub fn xaccTransHasSplitsInStateByAccount(
        trans: *const Transaction,
        state: ::std::os::raw::c_char,
        account: *const Account,
    ) -> gboolean;
}
unsafe extern "C" {
    pub fn xaccTransGetCurrency(trans: *const Transaction) -> *mut gnc_commodity;
}
unsafe extern "C" {
    #[doc = " Set the commodity of this transaction."]
    pub fn xaccTransSetCurrency(trans: *mut Transaction, curr: *mut gnc_commodity);
}
unsafe extern "C" {
    #[doc = " The xaccTransGetImbalanceValue() method returns the total value of the\n transaction.  In a pure double-entry system, this imbalance\n should be exactly zero, and if it is not, something is broken.\n However, when double-entry semantics are not enforced, unbalanced\n transactions can sneak in, and this routine can be used to find\n out how much things are off by.  The value returned is denominated\n in the currency that is returned by the xaccTransFindCommonCurrency()\n method.\n\n If the use of currency exchange accounts is enabled then the a\n a transaction must be balanced in each currency it uses to be considered\n to be balanced.  The method xaccTransGetImbalance is used by most\n code to take this into consideration.  This method is only used in a few\n places that want the transaction value even if currency exchange accounts\n are enabled."]
    pub fn xaccTransGetImbalanceValue(trans: *const Transaction) -> gnc_numeric;
}
unsafe extern "C" {
    #[doc = " The xaccTransGetImbalance method returns a list giving the value of\n the transaction in each currency for which the balance is not zero.\n If the use of currency accounts is disabled, then this will be only\n the common currency for the transaction and xaccTransGetImbalance\n becomes equivalent to xaccTransGetImbalanceValue.  Otherwise it will\n return a list containing the imbalance in each currency."]
    pub fn xaccTransGetImbalance(trans: *const Transaction) -> *mut MonetaryList;
}
unsafe extern "C" {
    #[doc = " Returns true if the transaction is balanced according to the rules\n currently in effect."]
    pub fn xaccTransIsBalanced(trans: *const Transaction) -> gboolean;
}
unsafe extern "C" {
    #[doc = " The xaccTransGetAccountValue() method returns the total value applied\n  to a particular account.  In some cases there may be multiple Splits\n  in a single Transaction applied to one account (in particular when\n  trying to balance Lots) -- this function is just a convenience to\n  view everything at once."]
    pub fn xaccTransGetAccountValue(
        trans: *const Transaction,
        account: *const Account,
    ) -> gnc_numeric;
}
unsafe extern "C" {
    #[doc = " Same as xaccTransGetAccountValue, but uses the Account's commodity."]
    pub fn xaccTransGetAccountAmount(
        trans: *const Transaction,
        account: *const Account,
    ) -> gnc_numeric;
}
unsafe extern "C" {
    pub fn xaccTransGetAccountConvRate(txn: *const Transaction, acc: *const Account)
    -> gnc_numeric;
}
unsafe extern "C" {
    #[doc = " Get the account balance for the specified account after the last\nsplit in the specified transaction."]
    pub fn xaccTransGetAccountBalance(
        trans: *const Transaction,
        account: *const Account,
    ) -> gnc_numeric;
}
unsafe extern "C" {
    #[doc = " The xaccTransOrder(ta,tb) method is useful for sorting.\n    Orders ta and tb\n      return <0 if ta sorts before tb\n      return >0 if ta sorts after tb\n      return 0 if they are absolutely equal\n\n    The comparrison uses the following fields, in order:\n      date posted  (compare as a date)\n      num field (compare as an integer)\n      date entered (compare as a date)\n      description field (comcpare as a string using strcmp())\n      GncGUID (compare as a guid)\n    Finally, it returns zero if all of the above match.\n    Note that it does *NOT* compare its member splits.\n    Note also that it calls xaccTransOrder_num_action with actna and actnb\n    set as NULL."]
    pub fn xaccTransOrder(ta: *const Transaction, tb: *const Transaction) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    #[doc = " The xaccTransOrder_num_action(ta,actna,tb,actnb) method is useful for sorting.\n    Orders ta and tb\n      return <0 if ta sorts before tb\n      return >0 if ta sorts after tb\n      return 0 if they are absolutely equal\n\n    The comparrison uses the following fields, in order:\n      date posted  (compare as a date)\n      if actna and actnb are NULL,\n          num field (compare as an integer)\n      else actna and actnb  (compare as an integer)\n      date entered (compare as a date)\n      description field (comcpare as a string using strcmp())\n      GncGUID (compare as a guid)\n    Finally, it returns zero if all of the above match.\n    Note that it does *NOT* compare its member splits (except action as\n    specified above)."]
    pub fn xaccTransOrder_num_action(
        ta: *const Transaction,
        actna: *const ::std::os::raw::c_char,
        tb: *const Transaction,
        actnb: *const ::std::os::raw::c_char,
    ) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    #[doc = " The xaccTransSetDate() method does the same thing as\nxaccTransSetDate[Posted]Secs(), but takes a convenient\nday-month-year format.\n\n(Footnote: this shouldn't matter to a user, but anyone modifying\nthe engine should understand that when xaccTransCommitEdit() is\ncalled, the date order of each of the component splits will be\nchecked, and will be restored in ascending date order.)"]
    pub fn xaccTransSetDate(
        trans: *mut Transaction,
        day: ::std::os::raw::c_int,
        mon: ::std::os::raw::c_int,
        year: ::std::os::raw::c_int,
    );
}
unsafe extern "C" {
    #[doc = " This method modifies <i>posted</i> date of the transaction,\n specified by a GDate. The posted date is the date when this\n transaction was posted at the bank.\n\n This is identical to xaccTransSetDate(), but different from\n xaccTransSetDatePostedSecs which artificially introduces the\n time-of-day part, which needs to be ignored."]
    pub fn xaccTransSetDatePostedGDate(trans: *mut Transaction, date: GDate);
}
unsafe extern "C" {
    #[doc = " The xaccTransSetDatePostedSecs() method will modify the <i>posted</i>\n  date of the transaction, specified by a time64 (see ctime(3)). The\n  posted date is the date when this transaction was posted at the\n  bank.\n\n Please do not use this function, as the extra time-of-day part messes up a\n lot of places. Rather, please use xaccTransSetDatePostedGDate() or\n xaccTransSetDatePostedSecsNormalized()."]
    pub fn xaccTransSetDatePostedSecs(trans: *mut Transaction, time: time64);
}
unsafe extern "C" {
    #[doc = " This function sets the <i>posted</i> date of the transaction, specified by\n a time64 (see ctime(3)). Contrary to xaccTransSetDatePostedSecs(), the time\n will be normalized to only the date part, and the time-of-day will be\n ignored. The resulting date is the same as if it had been set as a GDate\n through xaccTransSetDatePostedGDate().\n\n Please prefer this function over xaccTransSetDatePostedSecs().\n\n The posted date is the date when this transaction was posted at the bank."]
    pub fn xaccTransSetDatePostedSecsNormalized(trans: *mut Transaction, time: time64);
}
unsafe extern "C" {
    #[doc = " Modify the date of when the transaction was entered. The entered\n date is the date when the register entry was made."]
    pub fn xaccTransSetDateEnteredSecs(trans: *mut Transaction, time: time64);
}
unsafe extern "C" {
    #[doc = " Dates and txn-type for A/R and A/P \"invoice\" postings"]
    pub fn xaccTransSetDateDue(trans: *mut Transaction, time: time64);
}
unsafe extern "C" {
    #[doc = " Retrieve the posted date of the transaction. The posted date is\nthe date when this transaction was posted at the bank. (Although\nhaving different function names, GetDate and GetDatePosted refer\nto the same single date.)"]
    pub fn xaccTransGetDate(trans: *const Transaction) -> time64;
}
unsafe extern "C" {
    #[doc = " Retrieve the posted date of the transaction. The posted date is\nthe date when this transaction was posted at the bank. (Although\nhaving different function names, GetDate and GetDatePosted refer\nto the same single date.)"]
    pub fn xaccTransRetDatePosted(trans: *const Transaction) -> time64;
}
unsafe extern "C" {
    #[doc = " Retrieve the posted date of the transaction. The posted date is\nthe date when this transaction was posted at the bank."]
    pub fn xaccTransGetDatePostedGDate(trans: *const Transaction) -> GDate;
}
unsafe extern "C" {
    #[doc = " Retrieve the date of when the transaction was entered. The entered\n date is the date when the register entry was made."]
    pub fn xaccTransGetDateEntered(trans: *const Transaction) -> time64;
}
unsafe extern "C" {
    #[doc = " Retrieve the date of when the transaction was entered. The entered\n date is the date when the register entry was made."]
    pub fn xaccTransRetDateEntered(trans: *const Transaction) -> time64;
}
unsafe extern "C" {
    #[doc = " Dates and txn-type for A/R and A/P \"invoice\" postings"]
    pub fn xaccTransRetDateDue(trans: *const Transaction) -> time64;
}
unsafe extern "C" {
    #[doc = " @name Transaction voiding\n@{\n/\n/** xaccTransVoid voids a transaction.  A void transaction has no\n  values, is unaffected by reconciliation, and, by default is not\n  included in any queries.  A voided transaction may not be altered.\n\n  @param transaction The transaction to void.\n\n  @param reason The textual reason why this transaction is being\n  voided."]
    pub fn xaccTransVoid(transaction: *mut Transaction, reason: *const ::std::os::raw::c_char);
}
unsafe extern "C" {
    #[doc = " xaccTransUnvoid restores a voided transaction to its original\n  state.  At some point when gnucash is enhanced to support an audit\n  trail (i.e. write only transactions) this command should be\n  automatically disabled when the audit trail feature is enabled.\n\n  @param transaction The transaction to restore from voided state."]
    pub fn xaccTransUnvoid(transaction: *mut Transaction);
}
unsafe extern "C" {
    #[doc = " xaccTransReverse creates a Transaction that reverses the given\n  transaction by inverting all the numerical values in the given\n  transaction.  This function cancels out the effect of an earlier\n  transaction.  This will be needed by write only accounts as a way\n  to void a previous transaction (since you can't alter the existing\n  transaction).\n\n  @param transaction The transaction to create a reverse of.\n\n  @return a new transaction which reverses the given transaction"]
    pub fn xaccTransReverse(transaction: *mut Transaction) -> *mut Transaction;
}
unsafe extern "C" {
    #[doc = " Returns the transaction that reversed the given transaction.\n\n  @param trans a Transaction that has been reversed\n\n  @return the transaction that reversed the given transaction, or\n  NULL if the given transaction has not been reversed."]
    pub fn xaccTransGetReversedBy(trans: *const Transaction) -> *mut Transaction;
}
unsafe extern "C" {
    #[doc = " Retrieve information on whether or not a transaction has been voided.\n\n  @param transaction The transaction in question.\n\n  @return TRUE if the transaction is void, FALSE otherwise. Also\n  returns FALSE upon an error."]
    pub fn xaccTransGetVoidStatus(transaction: *const Transaction) -> gboolean;
}
unsafe extern "C" {
    #[doc = " Returns the user supplied textual reason why a transaction was\n  voided.\n\n  @param transaction The transaction in question.\n\n  @return A pointer to the user supplied reason for voiding."]
    pub fn xaccTransGetVoidReason(transaction: *const Transaction)
    -> *const ::std::os::raw::c_char;
}
unsafe extern "C" {
    #[doc = " Returns the time that a transaction was voided.\n\n  @param tr The transaction in question.\n\n  @return A time64 containing the time that this transaction was\n  voided. Returns a time of zero upon error."]
    pub fn xaccTransGetVoidTime(tr: *const Transaction) -> time64;
}
unsafe extern "C" {
    #[doc = " The xaccTransRecordPrice() method iterates through the splits and\n  and record the non-currency equivalent prices in the price database.\n\n  @param trans The transaction whose price is recorded\n  @param source The price priority level"]
    pub fn xaccTransRecordPrice(trans: *mut Transaction, source: PriceSource);
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _gncAddress {
    _unused: [u8; 0],
}
#[doc = " \\struct GncAddress\n\n@param  QofInstance The address instance.\n@param\tQofBook*\t  Copy of the book pointer.\n@param\tQofInstance* parent entity.\n@param\tgboolean\tdirty flag\n@param\tchar*\tname of addressee\n@param\tchar*\tfirst line of address\n@param\tchar*\tsecond line of address\n@param\tchar*\tthird line of address\n@param\tchar*\tfourth line of address\n@param\tchar*\tphone number\n@param\tchar*\tfax number\n@param\tchar*\temail address"]
pub type GncAddress = _gncAddress;
unsafe extern "C" {
    pub fn gnc_address_get_type() -> GType;
}
unsafe extern "C" {
    #[doc = " @name Create/Destroy functions\n@{"]
    pub fn gncAddressCreate(book: *mut QofBook, parent: *mut QofInstance) -> *mut GncAddress;
}
unsafe extern "C" {
    pub fn gncAddressDestroy(addr: *mut GncAddress);
}
unsafe extern "C" {
    pub fn gncAddressBeginEdit(addr: *mut GncAddress);
}
unsafe extern "C" {
    pub fn gncAddressCommitEdit(addr: *mut GncAddress);
}
unsafe extern "C" {
    #[doc = " @name Set functions\n@{"]
    pub fn gncAddressSetName(addr: *mut GncAddress, name: *const ::std::os::raw::c_char);
}
unsafe extern "C" {
    pub fn gncAddressSetAddr1(addr: *mut GncAddress, addr1: *const ::std::os::raw::c_char);
}
unsafe extern "C" {
    pub fn gncAddressSetAddr2(addr: *mut GncAddress, addr2: *const ::std::os::raw::c_char);
}
unsafe extern "C" {
    pub fn gncAddressSetAddr3(addr: *mut GncAddress, addr3: *const ::std::os::raw::c_char);
}
unsafe extern "C" {
    pub fn gncAddressSetAddr4(addr: *mut GncAddress, addr4: *const ::std::os::raw::c_char);
}
unsafe extern "C" {
    pub fn gncAddressSetPhone(addr: *mut GncAddress, phone: *const ::std::os::raw::c_char);
}
unsafe extern "C" {
    pub fn gncAddressSetFax(addr: *mut GncAddress, fax: *const ::std::os::raw::c_char);
}
unsafe extern "C" {
    pub fn gncAddressSetEmail(addr: *mut GncAddress, email: *const ::std::os::raw::c_char);
}
unsafe extern "C" {
    pub fn gncAddressClearDirty(address: *mut GncAddress);
}
unsafe extern "C" {
    #[doc = " @name Get Functions\n@{"]
    pub fn gncAddressGetName(addr: *const GncAddress) -> *const ::std::os::raw::c_char;
}
unsafe extern "C" {
    pub fn gncAddressGetAddr1(addr: *const GncAddress) -> *const ::std::os::raw::c_char;
}
unsafe extern "C" {
    pub fn gncAddressGetAddr2(addr: *const GncAddress) -> *const ::std::os::raw::c_char;
}
unsafe extern "C" {
    pub fn gncAddressGetAddr3(addr: *const GncAddress) -> *const ::std::os::raw::c_char;
}
unsafe extern "C" {
    pub fn gncAddressGetAddr4(addr: *const GncAddress) -> *const ::std::os::raw::c_char;
}
unsafe extern "C" {
    pub fn gncAddressGetPhone(addr: *const GncAddress) -> *const ::std::os::raw::c_char;
}
unsafe extern "C" {
    pub fn gncAddressGetFax(addr: *const GncAddress) -> *const ::std::os::raw::c_char;
}
unsafe extern "C" {
    pub fn gncAddressGetEmail(addr: *const GncAddress) -> *const ::std::os::raw::c_char;
}
unsafe extern "C" {
    #[doc = " @}"]
    pub fn gncAddressIsDirty(addr: *const GncAddress) -> gboolean;
}
unsafe extern "C" {
    #[doc = " \\brief compare two addresses\n\n\\return 0 if identical, -1 if a is empty or less than b\nand +1 if a is more than b or if b is empty."]
    pub fn gncAddressCompare(a: *const GncAddress, b: *const GncAddress) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    #[doc = " \\brief Deeply compare two addresses\n\n\\return TRUE if all fields match, FALSE otherwise"]
    pub fn gncAddressEqual(a: *const GncAddress, b: *const GncAddress) -> gboolean;
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _gncCustomer {
    _unused: [u8; 0],
}
#[doc = " @struct GncCustomer\n\ncredit, discount and shipaddr are unique to GncCustomer\\n\nid, name, notes, terms, addr, currency, taxtable, taxtable_override\ntaxincluded, active and jobs are identical to ::GncVendor.\n\n@param\tQofInstance     inst;\n@param\tchar *          id;\n@param\tchar *          name;\n@param\tchar *          notes;\n@param\tGncBillTerm *   terms;\n@param\tGncAddress *    addr;\n@param\tgnc_commodity * currency;\n@param\tGncTaxTable*    taxtable;\n@param\tgboolean        taxtable_override;\n@param\tGncTaxIncluded  taxincluded;\n@param\tgboolean        active;\n@param\tGList *         jobs;\n@param\tgnc_numeric     credit;\n@param\tgnc_numeric     discount;\n@param\tGncAddress *    shipaddr;"]
pub type GncCustomer = _gncCustomer;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _gncBillTerm {
    _unused: [u8; 0],
}
pub type GncBillTerm = _gncBillTerm;
unsafe extern "C" {
    pub fn gnc_billterm_get_type() -> GType;
}
#[repr(u32)]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub enum GncBillTermType {
    GNC_TERM_TYPE_DAYS = 1,
    GNC_TERM_TYPE_PROXIMO = 2,
}
unsafe extern "C" {
    #[doc = " @name Create/Destroy Functions\n@{"]
    pub fn gncBillTermCreate(book: *mut QofBook) -> *mut GncBillTerm;
}
unsafe extern "C" {
    pub fn gncBillTermDestroy(term: *mut GncBillTerm);
}
unsafe extern "C" {
    pub fn gncBillTermIncRef(term: *mut GncBillTerm);
}
unsafe extern "C" {
    pub fn gncBillTermDecRef(term: *mut GncBillTerm);
}
unsafe extern "C" {
    pub fn gncBillTermChanged(term: *mut GncBillTerm);
}
unsafe extern "C" {
    pub fn gncBillTermBeginEdit(term: *mut GncBillTerm);
}
unsafe extern "C" {
    pub fn gncBillTermCommitEdit(term: *mut GncBillTerm);
}
unsafe extern "C" {
    #[doc = " @name Set Functions\n@{"]
    pub fn gncBillTermSetName(term: *mut GncBillTerm, name: *const ::std::os::raw::c_char);
}
unsafe extern "C" {
    pub fn gncBillTermSetDescription(term: *mut GncBillTerm, name: *const ::std::os::raw::c_char);
}
unsafe extern "C" {
    pub fn gncBillTermSetType(term: *mut GncBillTerm, type_: GncBillTermType);
}
unsafe extern "C" {
    pub fn gncBillTermSetDueDays(term: *mut GncBillTerm, days: gint);
}
unsafe extern "C" {
    pub fn gncBillTermSetDiscountDays(term: *mut GncBillTerm, days: gint);
}
unsafe extern "C" {
    pub fn gncBillTermSetDiscount(term: *mut GncBillTerm, discount: gnc_numeric);
}
unsafe extern "C" {
    pub fn gncBillTermSetCutoff(term: *mut GncBillTerm, cutoff: gint);
}
unsafe extern "C" {
    pub fn gncBillTermLookupByName(
        book: *mut QofBook,
        name: *const ::std::os::raw::c_char,
    ) -> *mut GncBillTerm;
}
unsafe extern "C" {
    pub fn gncBillTermGetTerms(book: *mut QofBook) -> *mut GList;
}
unsafe extern "C" {
    pub fn gncBillTermGetName(term: *const GncBillTerm) -> *const ::std::os::raw::c_char;
}
unsafe extern "C" {
    pub fn gncBillTermGetDescription(term: *const GncBillTerm) -> *const ::std::os::raw::c_char;
}
unsafe extern "C" {
    pub fn gncBillTermGetType(term: *const GncBillTerm) -> GncBillTermType;
}
unsafe extern "C" {
    pub fn gncBillTermGetDueDays(term: *const GncBillTerm) -> gint;
}
unsafe extern "C" {
    pub fn gncBillTermGetDiscountDays(term: *const GncBillTerm) -> gint;
}
unsafe extern "C" {
    pub fn gncBillTermGetDiscount(term: *const GncBillTerm) -> gnc_numeric;
}
unsafe extern "C" {
    pub fn gncBillTermGetCutoff(term: *const GncBillTerm) -> gint;
}
unsafe extern "C" {
    pub fn gncBillTermIsDirty(term: *const GncBillTerm) -> gboolean;
}
unsafe extern "C" {
    pub fn gncBillTermGetParent(term: *const GncBillTerm) -> *mut GncBillTerm;
}
unsafe extern "C" {
    pub fn gncBillTermReturnChild(term: *mut GncBillTerm, make_new: gboolean) -> *mut GncBillTerm;
}
unsafe extern "C" {
    pub fn gncBillTermGetRefcount(term: *const GncBillTerm) -> gint64;
}
unsafe extern "C" {
    #[doc = " @name Comparison Functions\n@{ */\n/** Compare BillTerms on their name for sorting."]
    pub fn gncBillTermCompare(
        a: *const GncBillTerm,
        b: *const GncBillTerm,
    ) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    #[doc = " Check if all internal fields of a and b match."]
    pub fn gncBillTermEqual(a: *const GncBillTerm, b: *const GncBillTerm) -> gboolean;
}
unsafe extern "C" {
    #[doc = " Check only if the bill terms are \"family\". This is the case if\n  - a and b are the same bill term\n  - a is b's parent or vice versa\n  - a and be are children of the same parent\n\n  In practice, this check if performed by comparing the bill term's names.\n  This is required to be unique per parent/children group."]
    pub fn gncBillTermIsFamily(a: *const GncBillTerm, b: *const GncBillTerm) -> gboolean;
}
unsafe extern "C" {
    pub fn gncBillTermComputeDueDate(term: *const GncBillTerm, post_date: time64) -> time64;
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _gncTaxTable {
    _unused: [u8; 0],
}
#[doc = " @struct GncTaxTable\n\nmodtime is the internal date of the last modtime\\n\nSee libgnucash/engine/TaxTableBillTermImmutability.txt for an explanation of the following\\n\nCode that handles refcount, parent, child, invisible and children\nis *identical* to that in ::GncBillTerm\n\n@param\tQofInstance     inst;\n@param \tchar *          name;\n@param \tGncTaxTableEntryList*  entries;\n@param \ttime64        modtime;\n@param \tgint64          refcount;\n@param \tGncTaxTable *   parent; if non-null, we are an immutable child\n@param \tGncTaxTable *   child;  if non-null, we have not changed\n@param \tgboolean        invisible;\n@param \tGList *         children; list of children for disconnection"]
pub type GncTaxTable = _gncTaxTable;
#[repr(u32)]
#[doc = " @struct GncTaxTableEntry\n\n@param\tGncTaxTable *   table;\n@param  Account *       account;\n@param\tGncAmountType   type;\n@param\tgnc_numeric     amount;\n};\n\n/\n/**\n How to interpret the amount.\n You can interpret it as a VALUE or a PERCENT."]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub enum GncAmountType {
    #[doc = "< tax is a number"]
    GNC_AMT_TYPE_VALUE = 1,
    #[doc = "< tax is a percentage"]
    GNC_AMT_TYPE_PERCENT = 2,
}
#[doc = "< tax is included"]
pub const GncTaxIncluded_GNC_TAXINCLUDED_YES: GncTaxIncluded = 1;
#[doc = "< tax is not included"]
pub const GncTaxIncluded_GNC_TAXINCLUDED_NO: GncTaxIncluded = 2;
#[doc = "< use the global setting"]
pub const GncTaxIncluded_GNC_TAXINCLUDED_USEGLOBAL: GncTaxIncluded = 3;
#[doc = " How to interpret the TaxIncluded"]
pub type GncTaxIncluded = ::std::os::raw::c_uint;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _gncTaxTableEntry {
    _unused: [u8; 0],
}
pub type GncTaxTableEntry = _gncTaxTableEntry;
#[doc = " \\struct GncOwner"]
pub type GncOwner = _gncOwner;
#[repr(u32)]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub enum GncOwnerType {
    GNC_OWNER_NONE = 0,
    GNC_OWNER_UNDEFINED = 1,
    GNC_OWNER_CUSTOMER = 2,
    GNC_OWNER_JOB = 3,
    GNC_OWNER_VENDOR = 4,
    GNC_OWNER_EMPLOYEE = 5,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _gncJob {
    _unused: [u8; 0],
}
pub type GncJob = _gncJob;
unsafe extern "C" {
    pub fn gnc_job_get_type() -> GType;
}
unsafe extern "C" {
    pub fn gncJobCreate(book: *mut QofBook) -> *mut GncJob;
}
unsafe extern "C" {
    pub fn gncJobDestroy(job: *mut GncJob);
}
unsafe extern "C" {
    pub fn gncJobFreeList(jobs: *mut GList);
}
unsafe extern "C" {
    #[doc = " \\name Set Functions\n@{"]
    pub fn gncJobSetID(job: *mut GncJob, id: *const ::std::os::raw::c_char);
}
unsafe extern "C" {
    pub fn gncJobSetName(job: *mut GncJob, jobname: *const ::std::os::raw::c_char);
}
unsafe extern "C" {
    pub fn gncJobSetReference(job: *mut GncJob, owner_reference: *const ::std::os::raw::c_char);
}
unsafe extern "C" {
    pub fn gncJobSetRate(job: *mut GncJob, rate: gnc_numeric);
}
unsafe extern "C" {
    pub fn gncJobSetOwner(job: *mut GncJob, owner: *mut GncOwner);
}
unsafe extern "C" {
    pub fn gncJobSetActive(job: *mut GncJob, active: gboolean);
}
unsafe extern "C" {
    #[doc = " @}"]
    pub fn gncJobBeginEdit(job: *mut GncJob);
}
unsafe extern "C" {
    pub fn gncJobCommitEdit(job: *mut GncJob);
}
unsafe extern "C" {
    #[doc = " \\name Get Functions\n@{"]
    pub fn gncJobGetID(job: *const GncJob) -> *const ::std::os::raw::c_char;
}
unsafe extern "C" {
    pub fn gncJobGetName(job: *const GncJob) -> *const ::std::os::raw::c_char;
}
unsafe extern "C" {
    pub fn gncJobGetReference(job: *const GncJob) -> *const ::std::os::raw::c_char;
}
unsafe extern "C" {
    pub fn gncJobGetRate(job: *const GncJob) -> gnc_numeric;
}
unsafe extern "C" {
    pub fn gncJobGetOwner(job: *mut GncJob) -> *mut GncOwner;
}
unsafe extern "C" {
    pub fn gncJobGetActive(job: *const GncJob) -> gboolean;
}
unsafe extern "C" {
    pub fn gncJobCompare(a: *const GncJob, b: *const GncJob) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn gncJobEqual(a: *const GncJob, b: *const GncJob) -> gboolean;
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _gncVendor {
    _unused: [u8; 0],
}
pub type GncVendor = _gncVendor;
unsafe extern "C" {
    pub fn gnc_vendor_get_type() -> GType;
}
unsafe extern "C" {
    pub fn gncVendorCreate(book: *mut QofBook) -> *mut GncVendor;
}
unsafe extern "C" {
    pub fn gncVendorDestroy(vendor: *mut GncVendor);
}
unsafe extern "C" {
    #[doc = " @name Set Functions\n@{"]
    pub fn gncVendorSetID(vendor: *mut GncVendor, id: *const ::std::os::raw::c_char);
}
unsafe extern "C" {
    pub fn gncVendorSetName(vendor: *mut GncVendor, name: *const ::std::os::raw::c_char);
}
unsafe extern "C" {
    pub fn gncVendorSetNotes(vendor: *mut GncVendor, notes: *const ::std::os::raw::c_char);
}
unsafe extern "C" {
    pub fn gncVendorSetTerms(vendor: *mut GncVendor, terms: *mut GncBillTerm);
}
unsafe extern "C" {
    pub fn gncVendorSetTaxIncluded(vendor: *mut GncVendor, taxincl: GncTaxIncluded);
}
unsafe extern "C" {
    pub fn gncVendorSetCurrency(vendor: *mut GncVendor, currency: *mut gnc_commodity);
}
unsafe extern "C" {
    pub fn gncVendorSetActive(vendor: *mut GncVendor, active: gboolean);
}
unsafe extern "C" {
    pub fn gncVendorSetTaxTableOverride(vendor: *mut GncVendor, override_: gboolean);
}
unsafe extern "C" {
    pub fn gncVendorSetTaxTable(vendor: *mut GncVendor, table: *mut GncTaxTable);
}
unsafe extern "C" {
    #[doc = " @}"]
    pub fn gncVendorAddJob(vendor: *mut GncVendor, job: *mut GncJob);
}
unsafe extern "C" {
    pub fn gncVendorRemoveJob(vendor: *mut GncVendor, job: *mut GncJob);
}
unsafe extern "C" {
    pub fn gncVendorBeginEdit(vendor: *mut GncVendor);
}
unsafe extern "C" {
    pub fn gncVendorCommitEdit(vendor: *mut GncVendor);
}
unsafe extern "C" {
    #[doc = " @name Get Functions\n@{"]
    pub fn gncVendorGetID(vendor: *const GncVendor) -> *const ::std::os::raw::c_char;
}
unsafe extern "C" {
    pub fn gncVendorGetName(vendor: *const GncVendor) -> *const ::std::os::raw::c_char;
}
unsafe extern "C" {
    pub fn gncVendorGetAddr(vendor: *const GncVendor) -> *mut GncAddress;
}
unsafe extern "C" {
    pub fn gncVendorGetNotes(vendor: *const GncVendor) -> *const ::std::os::raw::c_char;
}
unsafe extern "C" {
    pub fn gncVendorGetTerms(vendor: *const GncVendor) -> *mut GncBillTerm;
}
unsafe extern "C" {
    pub fn gncVendorGetTaxIncluded(vendor: *const GncVendor) -> GncTaxIncluded;
}
unsafe extern "C" {
    pub fn gncVendorGetCurrency(vendor: *const GncVendor) -> *mut gnc_commodity;
}
unsafe extern "C" {
    pub fn gncVendorGetActive(vendor: *const GncVendor) -> gboolean;
}
unsafe extern "C" {
    pub fn gncVendorGetTaxTableOverride(vendor: *const GncVendor) -> gboolean;
}
unsafe extern "C" {
    pub fn gncVendorGetTaxTable(vendor: *const GncVendor) -> *mut GncTaxTable;
}
unsafe extern "C" {
    #[doc = " @} */\n/** XXX should be renamed to RetJobList to be consistent with\n other usage, since caller must free the copied list"]
    pub fn gncVendorCompare(a: *const GncVendor, b: *const GncVendor) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    #[doc = " Test support function, used by test-dbi-business-stuff.c"]
    pub fn gncVendorEqual(a: *const GncVendor, b: *const GncVendor) -> gboolean;
}
unsafe extern "C" {
    pub fn gncVendorIsDirty(vendor: *const GncVendor) -> gboolean;
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _gncEmployee {
    _unused: [u8; 0],
}
pub type GncEmployee = _gncEmployee;
unsafe extern "C" {
    pub fn gnc_employee_get_type() -> GType;
}
unsafe extern "C" {
    #[doc = " @name Create/Destroy Functions\n@{"]
    pub fn gncEmployeeCreate(book: *mut QofBook) -> *mut GncEmployee;
}
unsafe extern "C" {
    pub fn gncEmployeeDestroy(employee: *mut GncEmployee);
}
unsafe extern "C" {
    pub fn gncEmployeeBeginEdit(employee: *mut GncEmployee);
}
unsafe extern "C" {
    pub fn gncEmployeeCommitEdit(employee: *mut GncEmployee);
}
unsafe extern "C" {
    pub fn gncEmployeeCompare(
        a: *const GncEmployee,
        b: *const GncEmployee,
    ) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    #[doc = " @name Set Functions\n@{"]
    pub fn gncEmployeeSetID(employee: *mut GncEmployee, id: *const ::std::os::raw::c_char);
}
unsafe extern "C" {
    pub fn gncEmployeeSetUsername(
        employee: *mut GncEmployee,
        username: *const ::std::os::raw::c_char,
    );
}
unsafe extern "C" {
    pub fn gncEmployeeSetName(employee: *mut GncEmployee, name: *const ::std::os::raw::c_char);
}
unsafe extern "C" {
    pub fn gncEmployeeSetLanguage(
        employee: *mut GncEmployee,
        language: *const ::std::os::raw::c_char,
    );
}
unsafe extern "C" {
    pub fn gncEmployeeSetAcl(employee: *mut GncEmployee, acl: *const ::std::os::raw::c_char);
}
unsafe extern "C" {
    pub fn gncEmployeeSetWorkday(employee: *mut GncEmployee, workday: gnc_numeric);
}
unsafe extern "C" {
    pub fn gncEmployeeSetRate(employee: *mut GncEmployee, rate: gnc_numeric);
}
unsafe extern "C" {
    pub fn gncEmployeeSetCurrency(employee: *mut GncEmployee, currency: *mut gnc_commodity);
}
unsafe extern "C" {
    pub fn gncEmployeeSetActive(employee: *mut GncEmployee, active: gboolean);
}
unsafe extern "C" {
    pub fn gncEmployeeSetCCard(employee: *mut GncEmployee, ccard_acc: *mut Account);
}
unsafe extern "C" {
    #[doc = " @name Get Functions\n@{"]
    pub fn gncEmployeeGetBook(employee: *mut GncEmployee) -> *mut QofBook;
}
unsafe extern "C" {
    pub fn gncEmployeeGetID(employee: *const GncEmployee) -> *const ::std::os::raw::c_char;
}
unsafe extern "C" {
    pub fn gncEmployeeGetUsername(employee: *const GncEmployee) -> *const ::std::os::raw::c_char;
}
unsafe extern "C" {
    pub fn gncEmployeeGetName(employee: *const GncEmployee) -> *const ::std::os::raw::c_char;
}
unsafe extern "C" {
    pub fn gncEmployeeGetAddr(employee: *const GncEmployee) -> *mut GncAddress;
}
unsafe extern "C" {
    pub fn gncEmployeeGetLanguage(employee: *const GncEmployee) -> *const ::std::os::raw::c_char;
}
unsafe extern "C" {
    pub fn gncEmployeeGetAcl(employee: *const GncEmployee) -> *const ::std::os::raw::c_char;
}
unsafe extern "C" {
    pub fn gncEmployeeGetWorkday(employee: *const GncEmployee) -> gnc_numeric;
}
unsafe extern "C" {
    pub fn gncEmployeeGetRate(employee: *const GncEmployee) -> gnc_numeric;
}
unsafe extern "C" {
    pub fn gncEmployeeGetCurrency(employee: *const GncEmployee) -> *mut gnc_commodity;
}
unsafe extern "C" {
    pub fn gncEmployeeGetActive(employee: *const GncEmployee) -> gboolean;
}
unsafe extern "C" {
    pub fn gncEmployeeGetCCard(employee: *const GncEmployee) -> *mut Account;
}
unsafe extern "C" {
    #[doc = " Test support function, used by test-dbi-business-stuff.c"]
    pub fn gncEmployeeEqual(e1: *const GncEmployee, e2: *const GncEmployee) -> gboolean;
}
unsafe extern "C" {
    pub fn gncEmployeeIsDirty(employee: *const GncEmployee) -> gboolean;
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _gncInvoice {
    _unused: [u8; 0],
}
pub type GncInvoice = _gncInvoice;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _gncEntry {
    _unused: [u8; 0],
}
pub type GncEntry = _gncEntry;
#[repr(u32)]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub enum GncEntryPaymentType {
    GNC_PAYMENT_CASH = 1,
    GNC_PAYMENT_CARD = 2,
}
#[repr(u32)]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub enum GncDiscountHow {
    GNC_DISC_PRETAX = 1,
    GNC_DISC_SAMETIME = 2,
    GNC_DISC_POSTTAX = 3,
}
pub type AccountValueList = GList;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _gncOrder {
    _unused: [u8; 0],
}
pub type GncOrder = _gncOrder;
unsafe extern "C" {
    pub fn gnc_order_get_type() -> GType;
}
unsafe extern "C" {
    pub fn gnc_entry_get_type() -> GType;
}
unsafe extern "C" {
    #[doc = " How to apply the discount and taxes.  There are three distinct ways to\n apply them:\n\n Type:\tdiscount\ttax\n PRETAX\tpretax\t\tpretax-discount\n SAMETIME\tpretax\t\tpretax\n POSTTAX\tpretax+tax\tpretax"]
    pub fn gncEntryDiscountHowToString(how: GncDiscountHow) -> *const ::std::os::raw::c_char;
}
unsafe extern "C" {
    pub fn gncEntryDiscountStringToHow(
        str_: *const ::std::os::raw::c_char,
        how: *mut GncDiscountHow,
    ) -> gboolean;
}
unsafe extern "C" {
    pub fn gncEntryPaymentTypeToString(type_: GncEntryPaymentType)
    -> *const ::std::os::raw::c_char;
}
unsafe extern "C" {
    pub fn gncEntryPaymentStringToType(
        str_: *const ::std::os::raw::c_char,
        type_: *mut GncEntryPaymentType,
    ) -> gboolean;
}
unsafe extern "C" {
    #[doc = " @name Create/Destroy Functions\n@{"]
    pub fn gncEntryCreate(book: *mut QofBook) -> *mut GncEntry;
}
unsafe extern "C" {
    pub fn gncEntryDestroy(entry: *mut GncEntry);
}
unsafe extern "C" {
    #[doc = " @name Generic (shared) data\n@{ */\n/** Set the date of this entry"]
    pub fn gncEntrySetDateGDate(entry: *mut GncEntry, date: *const GDate);
}
unsafe extern "C" {
    #[doc = " DEPRECATED - use gncEntrySetDateGDate() instead! (Because the time-of-day\nis a misleading extra information. We are only dealing with the day\ninformation!"]
    pub fn gncEntrySetDate(entry: *mut GncEntry, date: time64);
}
unsafe extern "C" {
    pub fn gncEntrySetDateEntered(entry: *mut GncEntry, date: time64);
}
unsafe extern "C" {
    pub fn gncEntrySetDescription(entry: *mut GncEntry, desc: *const ::std::os::raw::c_char);
}
unsafe extern "C" {
    pub fn gncEntrySetAction(entry: *mut GncEntry, action: *const ::std::os::raw::c_char);
}
unsafe extern "C" {
    pub fn gncEntrySetNotes(entry: *mut GncEntry, notes: *const ::std::os::raw::c_char);
}
unsafe extern "C" {
    #[doc = " Set the internal quantity without any conversion.\n  This distinction is made because credit notes store their quantity\n  sign-reversed compared to how the quantity is written on the\n  actual credit note (and hence how the ledger and reports show it\n  to the user)."]
    pub fn gncEntrySetQuantity(entry: *mut GncEntry, quantity: gnc_numeric);
}
unsafe extern "C" {
    #[doc = " Set the internal quantity converting from the quantity as\n  visible on the physical document.\n  This distinction is made because credit notes store their quantity\n  sign-reversed compared to how the quantity is written on the\n  actual credit note (and hence how the ledger and reports show it\n  to the user)."]
    pub fn gncEntrySetDocQuantity(entry: *mut GncEntry, quantity: gnc_numeric, is_cn: gboolean);
}
unsafe extern "C" {
    #[doc = " @name Customer Invoices\n@{"]
    pub fn gncEntrySetInvAccount(entry: *mut GncEntry, acc: *mut Account);
}
unsafe extern "C" {
    pub fn gncEntrySetInvPrice(entry: *mut GncEntry, price: gnc_numeric);
}
unsafe extern "C" {
    pub fn gncEntrySetInvTaxable(entry: *mut GncEntry, taxable: gboolean);
}
unsafe extern "C" {
    pub fn gncEntrySetInvTaxIncluded(entry: *mut GncEntry, tax_included: gboolean);
}
unsafe extern "C" {
    pub fn gncEntrySetInvTaxTable(entry: *mut GncEntry, table: *mut GncTaxTable);
}
unsafe extern "C" {
    pub fn gncEntrySetInvDiscount(entry: *mut GncEntry, discount: gnc_numeric);
}
unsafe extern "C" {
    pub fn gncEntrySetInvDiscountType(entry: *mut GncEntry, type_: GncAmountType);
}
unsafe extern "C" {
    pub fn gncEntrySetInvDiscountHow(entry: *mut GncEntry, how: GncDiscountHow);
}
unsafe extern "C" {
    #[doc = " @name Vendor Bills (and Employee Expenses)\n@{"]
    pub fn gncEntrySetBillAccount(entry: *mut GncEntry, acc: *mut Account);
}
unsafe extern "C" {
    pub fn gncEntrySetBillPrice(entry: *mut GncEntry, price: gnc_numeric);
}
unsafe extern "C" {
    pub fn gncEntrySetBillTaxable(entry: *mut GncEntry, taxable: gboolean);
}
unsafe extern "C" {
    pub fn gncEntrySetBillTaxIncluded(entry: *mut GncEntry, tax_included: gboolean);
}
unsafe extern "C" {
    pub fn gncEntrySetBillTaxTable(entry: *mut GncEntry, table: *mut GncTaxTable);
}
unsafe extern "C" {
    pub fn gncEntrySetBillable(entry: *mut GncEntry, billable: gboolean);
}
unsafe extern "C" {
    pub fn gncEntrySetBillTo(entry: *mut GncEntry, billto: *mut GncOwner);
}
unsafe extern "C" {
    #[doc = " @name employee-stuff\n@{"]
    pub fn gncEntrySetBillPayment(entry: *mut GncEntry, type_: GncEntryPaymentType);
}
unsafe extern "C" {
    #[doc = " @name Generic (shared) data\n@{ */\n/** Returns the day of this entry"]
    pub fn gncEntryGetDateGDate(entry: *const GncEntry) -> GDate;
}
unsafe extern "C" {
    #[doc = " DEPRECATED - use gncEntryGetDateGDate() instead! (Because the time-of-day\nis a misleading extra information. We are only dealing with the day\ninformation!"]
    pub fn gncEntryGetDate(entry: *const GncEntry) -> time64;
}
unsafe extern "C" {
    pub fn gncEntryGetDateEntered(entry: *const GncEntry) -> time64;
}
unsafe extern "C" {
    pub fn gncEntryGetDescription(entry: *const GncEntry) -> *const ::std::os::raw::c_char;
}
unsafe extern "C" {
    pub fn gncEntryGetAction(entry: *const GncEntry) -> *const ::std::os::raw::c_char;
}
unsafe extern "C" {
    pub fn gncEntryGetNotes(notes: *const GncEntry) -> *const ::std::os::raw::c_char;
}
unsafe extern "C" {
    #[doc = " Get the quantity as stored internally.\n  This distinction is made because credit notes store their quantity\n  sign-reversed compared to how the quantity is written on the\n  actual credit note (and hence how the ledger and reports show it\n  to the user)."]
    pub fn gncEntryGetQuantity(entry: *const GncEntry) -> gnc_numeric;
}
unsafe extern "C" {
    #[doc = " Get the quantity as on the physical document.\n  This distinction is made because credit notes store their quantity\n  sign-reversed compared to how the quantity is written on the\n  actual credit note (and hence how the ledger and reports show it\n  to the user)."]
    pub fn gncEntryGetDocQuantity(entry: *const GncEntry, is_cn: gboolean) -> gnc_numeric;
}
unsafe extern "C" {
    #[doc = " @name Customer Invoices\n@{"]
    pub fn gncEntryGetInvAccount(entry: *const GncEntry) -> *mut Account;
}
unsafe extern "C" {
    pub fn gncEntryGetInvPrice(entry: *const GncEntry) -> gnc_numeric;
}
unsafe extern "C" {
    pub fn gncEntryGetPrice(
        entry: *const GncEntry,
        cust_doc: gboolean,
        net: gboolean,
    ) -> gnc_numeric;
}
unsafe extern "C" {
    pub fn gncEntryGetInvDiscount(entry: *const GncEntry) -> gnc_numeric;
}
unsafe extern "C" {
    pub fn gncEntryGetInvDiscountType(entry: *const GncEntry) -> GncAmountType;
}
unsafe extern "C" {
    pub fn gncEntryGetInvDiscountHow(entry: *const GncEntry) -> GncDiscountHow;
}
unsafe extern "C" {
    pub fn gncEntryGetInvTaxable(entry: *const GncEntry) -> gboolean;
}
unsafe extern "C" {
    pub fn gncEntryGetInvTaxIncluded(entry: *const GncEntry) -> gboolean;
}
unsafe extern "C" {
    pub fn gncEntryGetInvTaxTable(entry: *const GncEntry) -> *mut GncTaxTable;
}
unsafe extern "C" {
    #[doc = " @name Vendor Bills (and Employee Expenses)\n@{"]
    pub fn gncEntryGetBillAccount(entry: *const GncEntry) -> *mut Account;
}
unsafe extern "C" {
    pub fn gncEntryGetBillPrice(entry: *const GncEntry) -> gnc_numeric;
}
unsafe extern "C" {
    pub fn gncEntryGetBillTaxable(entry: *const GncEntry) -> gboolean;
}
unsafe extern "C" {
    pub fn gncEntryGetBillTaxIncluded(entry: *const GncEntry) -> gboolean;
}
unsafe extern "C" {
    pub fn gncEntryGetBillTaxTable(entry: *const GncEntry) -> *mut GncTaxTable;
}
unsafe extern "C" {
    pub fn gncEntryGetBillable(entry: *const GncEntry) -> gboolean;
}
unsafe extern "C" {
    pub fn gncEntryGetBillTo(entry: *mut GncEntry) -> *mut GncOwner;
}
unsafe extern "C" {
    pub fn gncEntryGetBillPayment(entry: *const GncEntry) -> GncEntryPaymentType;
}
unsafe extern "C" {
    #[doc = " @}"]
    pub fn gncEntryCopy(src: *const GncEntry, dest: *mut GncEntry, add_entry: gboolean);
}
unsafe extern "C" {
    #[doc = " @name Getting Values\n\n An entry has three important values:\n - entry value: the amount the merchant gets\n - tax value: the amount the government gets\n - discount value: the amount the customer saved\n\n These values can be retrieved in several variants. Depending on\n how they will be used some sign reversals can be applied on\n the values:\n - Doc value: the value as listed on the document. This is usually\n              a positive value, unless the document was a\n              negative invoice/bill or negative credit note.\n              Since credit note entry values are stored negatively\n              internally, they will be sign-reversed before returning\n              them.\n - Bal value: the value as it will impact the balance. Customer\n              invoices and vendor credit notes have a positive\n              influence on the balance, so these values will be positive.\n              For vendor bills and customer credit notes, the\n              values will be negative.\n\n For tax there are TaxValue and TaxValues variants: the first one\n returns to total tax value for this entry, meaning the sum of all\n individual taxes. The second one returns a list of all the individual\n tax values for this entry. This list holds unrounded values only, there's\n no variant with rounded values.\n\n Note that this list is not owned by the entry. When no longer needed,\n it should be freed with gncAccountValueDestroy.\n\n Finally, there are rounded and unrounded variants of most of\n these functions.\n@{"]
    pub fn gncEntryGetDocValue(
        entry: *mut GncEntry,
        round: gboolean,
        is_cust_doc: gboolean,
        is_cn: gboolean,
    ) -> gnc_numeric;
}
unsafe extern "C" {
    pub fn gncEntryGetDocTaxValue(
        entry: *mut GncEntry,
        round: gboolean,
        is_cust_doc: gboolean,
        is_cn: gboolean,
    ) -> gnc_numeric;
}
unsafe extern "C" {
    #[doc = " Careful: the returned list is NOT owned by the entry and should be freed by the caller"]
    pub fn gncEntryGetDocTaxValues(
        entry: *mut GncEntry,
        is_cust_doc: gboolean,
        is_cn: gboolean,
    ) -> *mut AccountValueList;
}
unsafe extern "C" {
    pub fn gncEntryGetDocDiscountValue(
        entry: *mut GncEntry,
        round: gboolean,
        is_cust_doc: gboolean,
        is_cn: gboolean,
    ) -> gnc_numeric;
}
unsafe extern "C" {
    pub fn gncEntryGetBalValue(
        entry: *mut GncEntry,
        round: gboolean,
        is_cust_doc: gboolean,
    ) -> gnc_numeric;
}
unsafe extern "C" {
    pub fn gncEntryGetBalTaxValue(
        entry: *mut GncEntry,
        round: gboolean,
        is_cust_doc: gboolean,
    ) -> gnc_numeric;
}
unsafe extern "C" {
    #[doc = " Careful: the returned list is NOT owned by the entry and should be freed by the caller"]
    pub fn gncEntryGetBalTaxValues(
        entry: *mut GncEntry,
        is_cust_doc: gboolean,
    ) -> *mut AccountValueList;
}
unsafe extern "C" {
    pub fn gncEntryGetBalDiscountValue(
        entry: *mut GncEntry,
        round: gboolean,
        is_cust_doc: gboolean,
    ) -> gnc_numeric;
}
unsafe extern "C" {
    #[doc = " Compute the Entry value, tax_value, and discount_value, based on\n the quantity, price, discount, tax_-table, and types.  The value is\n the amount the merchant gets, the taxes are what the gov't gets,\n and the discount is how much the customer saved.  The SCU is the\n target denominator of the value and tax -- it should be the\n account or commodity SCU of the target.\n\n  The return values are NOT rounded.\n\n If the tax_values list is owned by the entry, it will be destroyed\n automatically. Otherwise use gncAccountValueDestroy to free it."]
    pub fn gncEntryComputeValue(
        qty: gnc_numeric,
        price: gnc_numeric,
        tax_table: *const GncTaxTable,
        tax_included: gboolean,
        discount: gnc_numeric,
        discount_type: GncAmountType,
        discount_how: GncDiscountHow,
        SCU: ::std::os::raw::c_int,
        value: *mut gnc_numeric,
        discount_value: *mut gnc_numeric,
        tax_values: *mut *mut GList,
    );
}
unsafe extern "C" {
    #[doc = " @}"]
    pub fn gncEntryGetOrder(entry: *const GncEntry) -> *mut GncOrder;
}
unsafe extern "C" {
    pub fn gncEntryGetInvoice(entry: *const GncEntry) -> *mut GncInvoice;
}
unsafe extern "C" {
    pub fn gncEntryGetBill(entry: *const GncEntry) -> *mut GncInvoice;
}
unsafe extern "C" {
    pub fn gncEntryIsOpen(entry: *const GncEntry) -> gboolean;
}
unsafe extern "C" {
    pub fn gncEntryBeginEdit(entry: *mut GncEntry);
}
unsafe extern "C" {
    pub fn gncEntryCommitEdit(entry: *mut GncEntry);
}
unsafe extern "C" {
    pub fn gncEntryCompare(a: *const GncEntry, b: *const GncEntry) -> ::std::os::raw::c_int;
}
#[repr(u32)]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub enum GncInvoiceType {
    GNC_INVOICE_UNDEFINED = 0,
    GNC_INVOICE_CUST_INVOICE = 1,
    GNC_INVOICE_VEND_INVOICE = 2,
    GNC_INVOICE_EMPL_INVOICE = 3,
    GNC_INVOICE_CUST_CREDIT_NOTE = 4,
    GNC_INVOICE_VEND_CREDIT_NOTE = 5,
    GNC_INVOICE_EMPL_CREDIT_NOTE = 6,
    GNC_INVOICE_NUM_TYPES = 7,
}
unsafe extern "C" {
    pub fn gnc_invoice_get_type() -> GType;
}
unsafe extern "C" {
    #[doc = " @name Create/Destroy Functions\n@{"]
    pub fn gncInvoiceCreate(book: *mut QofBook) -> *mut GncInvoice;
}
unsafe extern "C" {
    pub fn gncInvoiceDestroy(invoice: *mut GncInvoice);
}
unsafe extern "C" {
    #[doc = " Create a new GncInvoice object as a deep copy of the given other\n invoice.\n\n The returned new invoice has everything copied from the other\n invoice, including the ID string field. All GncEntries are newly\n allocated copies of the original invoice's entries."]
    pub fn gncInvoiceCopy(other_invoice: *const GncInvoice) -> *mut GncInvoice;
}
unsafe extern "C" {
    #[doc = " @name Set Functions\n@{"]
    pub fn gncInvoiceSetID(invoice: *mut GncInvoice, id: *const ::std::os::raw::c_char);
}
unsafe extern "C" {
    pub fn gncInvoiceSetOwner(invoice: *mut GncInvoice, owner: *mut GncOwner);
}
unsafe extern "C" {
    #[doc = " Set the DateOpened using a GDate argument. (Note: Internally this stores\nthe date in a time64 as created through time64CanonicalDayTime())."]
    pub fn gncInvoiceSetDateOpenedGDate(invoice: *mut GncInvoice, date: *const GDate);
}
unsafe extern "C" {
    pub fn gncInvoiceSetDateOpened(invoice: *mut GncInvoice, date: time64);
}
unsafe extern "C" {
    pub fn gncInvoiceSetDatePosted(invoice: *mut GncInvoice, date: time64);
}
unsafe extern "C" {
    pub fn gncInvoiceSetTerms(invoice: *mut GncInvoice, terms: *mut GncBillTerm);
}
unsafe extern "C" {
    pub fn gncInvoiceSetBillingID(
        invoice: *mut GncInvoice,
        billing_id: *const ::std::os::raw::c_char,
    );
}
unsafe extern "C" {
    pub fn gncInvoiceSetNotes(invoice: *mut GncInvoice, notes: *const ::std::os::raw::c_char);
}
unsafe extern "C" {
    pub fn gncInvoiceSetDocLink(invoice: *mut GncInvoice, doclink: *const ::std::os::raw::c_char);
}
unsafe extern "C" {
    pub fn gncInvoiceSetCurrency(invoice: *mut GncInvoice, currency: *mut gnc_commodity);
}
unsafe extern "C" {
    pub fn gncInvoiceSetActive(invoice: *mut GncInvoice, active: gboolean);
}
unsafe extern "C" {
    pub fn gncInvoiceSetIsCreditNote(invoice: *mut GncInvoice, credit_note: gboolean);
}
unsafe extern "C" {
    pub fn gncInvoiceSetBillTo(invoice: *mut GncInvoice, billto: *mut GncOwner);
}
unsafe extern "C" {
    pub fn gncInvoiceSetToChargeAmount(invoice: *mut GncInvoice, amount: gnc_numeric);
}
unsafe extern "C" {
    #[doc = " @}"]
    pub fn gncInvoiceAddEntry(invoice: *mut GncInvoice, entry: *mut GncEntry);
}
unsafe extern "C" {
    pub fn gncInvoiceRemoveEntry(invoice: *mut GncInvoice, entry: *mut GncEntry);
}
unsafe extern "C" {
    pub fn gncInvoiceAddPrice(invoice: *mut GncInvoice, price: *mut GNCPrice);
}
unsafe extern "C" {
    #[doc = " Call this function when an Entry is changed and you want to\nre-sort the list of entries"]
    pub fn gncInvoiceSortEntries(invoice: *mut GncInvoice);
}
unsafe extern "C" {
    #[doc = " Remove all entries from an invoice. To be called before\n  destroying an invoice."]
    pub fn gncInvoiceRemoveEntries(invoice: *mut GncInvoice);
}
unsafe extern "C" {
    #[doc = " @name Get Functions\n@{"]
    pub fn gncInvoiceGetID(invoice: *const GncInvoice) -> *const ::std::os::raw::c_char;
}
unsafe extern "C" {
    pub fn gncInvoiceGetOwner(invoice: *const GncInvoice) -> *const GncOwner;
}
unsafe extern "C" {
    pub fn gncInvoiceGetDateOpened(invoice: *const GncInvoice) -> time64;
}
unsafe extern "C" {
    pub fn gncInvoiceGetDatePosted(invoice: *const GncInvoice) -> time64;
}
unsafe extern "C" {
    pub fn gncInvoiceGetDateDue(invoice: *const GncInvoice) -> time64;
}
unsafe extern "C" {
    pub fn gncInvoiceGetTerms(invoice: *const GncInvoice) -> *mut GncBillTerm;
}
unsafe extern "C" {
    pub fn gncInvoiceGetBillingID(invoice: *const GncInvoice) -> *const ::std::os::raw::c_char;
}
unsafe extern "C" {
    pub fn gncInvoiceGetNotes(invoice: *const GncInvoice) -> *const ::std::os::raw::c_char;
}
unsafe extern "C" {
    pub fn gncInvoiceGetDocLink(invoice: *const GncInvoice) -> *const ::std::os::raw::c_char;
}
unsafe extern "C" {
    pub fn gncInvoiceGetOwnerType(invoice: *const GncInvoice) -> GncOwnerType;
}
unsafe extern "C" {
    pub fn gncInvoiceGetTypeListForOwnerType(type_: GncOwnerType) -> *mut GList;
}
unsafe extern "C" {
    pub fn gncInvoiceGetType(invoice: *const GncInvoice) -> GncInvoiceType;
}
unsafe extern "C" {
    pub fn gncInvoiceGetTypeString(invoice: *const GncInvoice) -> *const ::std::os::raw::c_char;
}
unsafe extern "C" {
    pub fn gncInvoiceGetCurrency(invoice: *const GncInvoice) -> *mut gnc_commodity;
}
unsafe extern "C" {
    pub fn gncInvoiceGetBillTo(invoice: *mut GncInvoice) -> *mut GncOwner;
}
unsafe extern "C" {
    pub fn gncInvoiceGetToChargeAmount(invoice: *const GncInvoice) -> gnc_numeric;
}
unsafe extern "C" {
    pub fn gncInvoiceGetActive(invoice: *const GncInvoice) -> gboolean;
}
unsafe extern "C" {
    pub fn gncInvoiceGetIsCreditNote(invoice: *const GncInvoice) -> gboolean;
}
unsafe extern "C" {
    pub fn gncInvoiceGetPostedLot(invoice: *const GncInvoice) -> *mut GNCLot;
}
unsafe extern "C" {
    pub fn gncInvoiceGetPostedTxn(invoice: *const GncInvoice) -> *mut Transaction;
}
unsafe extern "C" {
    pub fn gncInvoiceGetPostedAcc(invoice: *const GncInvoice) -> *mut Account;
}
unsafe extern "C" {
    #[doc = " Return the \"total\" amount of the invoice as seen on the document\n  (and shown to the user in the reports and invoice ledger)."]
    pub fn gncInvoiceGetTotal(invoice: *mut GncInvoice) -> gnc_numeric;
}
unsafe extern "C" {
    pub fn gncInvoiceGetTotalOf(
        invoice: *mut GncInvoice,
        type_: GncEntryPaymentType,
    ) -> gnc_numeric;
}
unsafe extern "C" {
    pub fn gncInvoiceGetTotalSubtotal(invoice: *mut GncInvoice) -> gnc_numeric;
}
unsafe extern "C" {
    pub fn gncInvoiceGetTotalTax(invoice: *mut GncInvoice) -> gnc_numeric;
}
unsafe extern "C" {
    #[doc = " Return a list of tax totals accumulated per tax account."]
    pub fn gncInvoiceGetTotalTaxList(invoice: *mut GncInvoice) -> *mut AccountValueList;
}
pub type EntryList = GList;
unsafe extern "C" {
    pub fn gncInvoiceGetEntries(invoice: *mut GncInvoice) -> *mut EntryList;
}
unsafe extern "C" {
    pub fn gncInvoiceGetPrice(
        invoice: *mut GncInvoice,
        commodity: *mut gnc_commodity,
    ) -> *mut GNCPrice;
}
unsafe extern "C" {
    #[doc = " Depending on the invoice type, invoices have a different effect\n  on the balance. Customer invoices increase the balance, while\n  vendor bills decrease the balance. Credit notes have the opposite\n  effect.\n\n  Returns TRUE if the invoice will increase the balance or FALSE\n  otherwise."]
    pub fn gncInvoiceAmountPositive(invoice: *const GncInvoice) -> gboolean;
}
unsafe extern "C" {
    #[doc = " Return an overview of amounts on this invoice that will be posted to\n  accounts in currencies that are different from the invoice currency.\n  These accounts can be the accounts referred to in invoice entries\n  or tax tables. This information is returned in the from of a hash\n  table. The keys in the hash table are the foreign currencies, the\n  values are the accumulated amounts in that currency.\n  Drop the reference to the hash table with g_hash_table_unref when\n  no longer needed."]
    pub fn gncInvoiceGetForeignCurrencies(invoice: *const GncInvoice) -> *mut GHashTable;
}
unsafe extern "C" {
    #[doc = " Post this invoice to an account.  Returns the new Transaction\n that is tied to this invoice.   The transaction is set with\n the supplied posted date, due date, and memo.  The Transaction\n description is set to the name of the company.\n\n If accumulate splits is TRUE, entries in the same account\n will be merged into one single split in that account.\n Otherwise each entry will be posted as a separate split,\n possibly resulting in multiple splits in one account.\n\n If autopay is TRUE, the code will try to find pre-payments,\n invoices or credit notes that can reduce the amount due for this\n invoice, marking the invoice as fully or partially paid, depending\n on the amounts on all documents involved. If autopay is FALSE,\n it's the user's responsibility to explicitly pay the invoice.\n"]
    pub fn gncInvoicePostToAccount(
        invoice: *mut GncInvoice,
        acc: *mut Account,
        posted_date: time64,
        due_date: time64,
        memo: *const ::std::os::raw::c_char,
        accumulatesplits: gboolean,
        autopay: gboolean,
    ) -> *mut Transaction;
}
unsafe extern "C" {
    #[doc = " Unpost this invoice.  This will destroy the posted transaction and\n return the invoice to its unposted state.  It may leave empty lots\n out there.  If reset_tax_tables is TRUE, then it will also revert\n all the Tax Tables to the parent, which will potentially change the\n total value of the invoice.  It may also leave some orphaned Tax\n Table children.\n\n Returns TRUE if successful, FALSE if there is a problem."]
    pub fn gncInvoiceUnpost(invoice: *mut GncInvoice, reset_tax_tables: gboolean) -> gboolean;
}
unsafe extern "C" {
    #[doc = " Attempt to pay the invoice using open payment lots and\n lots for documents of the opposite sign (credit notes versus\n invoices)."]
    pub fn gncInvoiceAutoApplyPayments(invoice: *mut GncInvoice);
}
unsafe extern "C" {
    #[doc = " A convenience function to apply a payment to an invoice.\n It creates a lot for a payment optionally based on an existing\n transaction and then tries to balance it with\n the given invoice.\n Contrary to gncOwnerApplyPayment, no other open documents\n or payments for the owner will be considered\n to balance the payment.\n\n This code is actually a convenience wrapper around gncOwnerCreatePaymentLotSecs\n and gncOwnerAutoApplyPaymentsWithLots. See their descriptions for more\n details on what happens exactly."]
    pub fn gncInvoiceApplyPayment(
        invoice: *const GncInvoice,
        txn: *mut Transaction,
        xfer_acc: *mut Account,
        amount: gnc_numeric,
        exch: gnc_numeric,
        date: time64,
        memo: *const ::std::os::raw::c_char,
        num: *const ::std::os::raw::c_char,
    );
}
unsafe extern "C" {
    #[doc = " Given a transaction, find and return the Invoice"]
    pub fn gncInvoiceGetInvoiceFromTxn(txn: *const Transaction) -> *mut GncInvoice;
}
unsafe extern "C" {
    #[doc = " Given a LOT, find and return the Invoice attached to the lot"]
    pub fn gncInvoiceGetInvoiceFromLot(lot: *mut GNCLot) -> *mut GncInvoice;
}
unsafe extern "C" {
    pub fn gncInvoiceBeginEdit(invoice: *mut GncInvoice);
}
unsafe extern "C" {
    pub fn gncInvoiceCommitEdit(invoice: *mut GncInvoice);
}
unsafe extern "C" {
    pub fn gncInvoiceCompare(a: *const GncInvoice, b: *const GncInvoice) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn gncInvoiceIsPosted(invoice: *const GncInvoice) -> gboolean;
}
unsafe extern "C" {
    pub fn gncInvoiceIsPaid(invoice: *const GncInvoice) -> gboolean;
}
unsafe extern "C" {
    pub fn gncInvoiceGetBook(x: *mut GncInvoice) -> *mut QofBook;
}
unsafe extern "C" {
    #[doc = " Test support function used by test-dbi-business-stuff.c"]
    pub fn gncInvoiceEqual(a: *const GncInvoice, b: *const GncInvoice) -> gboolean;
}
unsafe extern "C" {
    #[doc = " return the type for the owner as an untranslated string."]
    pub fn gncOwnerGetTypeString(owner: *const GncOwner) -> *const ::std::os::raw::c_char;
}
unsafe extern "C" {
    #[doc = " Returns the QofIdType of the given GncOwnerType, or NULL if no\n suitable one exists."]
    pub fn gncOwnerTypeToQofIdType(t: GncOwnerType) -> QofIdTypeConst;
}
unsafe extern "C" {
    pub fn gncOwnerRegister() -> gboolean;
}
#[doc = " \\struct GncOwner"]
#[repr(C)]
#[derive(Copy, Clone)]
pub struct _gncOwner {
    #[doc = "< Customer, Job, Vendor, Employee or Undefined."]
    pub type_: GncOwnerType,
    #[doc = "< holds the pointer to the owner object."]
    pub owner: _gncOwner__bindgen_ty_1,
    #[doc = "< Set type independently of the owner."]
    pub qof_temp: gpointer,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union _gncOwner__bindgen_ty_1 {
    pub undefined: gpointer,
    pub customer: *mut GncCustomer,
    pub job: *mut GncJob,
    pub vendor: *mut GncVendor,
    pub employee: *mut GncEmployee,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of _gncOwner__bindgen_ty_1"][::std::mem::size_of::<_gncOwner__bindgen_ty_1>() - 8usize];
    ["Alignment of _gncOwner__bindgen_ty_1"]
        [::std::mem::align_of::<_gncOwner__bindgen_ty_1>() - 8usize];
    ["Offset of field: _gncOwner__bindgen_ty_1::undefined"]
        [::std::mem::offset_of!(_gncOwner__bindgen_ty_1, undefined) - 0usize];
    ["Offset of field: _gncOwner__bindgen_ty_1::customer"]
        [::std::mem::offset_of!(_gncOwner__bindgen_ty_1, customer) - 0usize];
    ["Offset of field: _gncOwner__bindgen_ty_1::job"]
        [::std::mem::offset_of!(_gncOwner__bindgen_ty_1, job) - 0usize];
    ["Offset of field: _gncOwner__bindgen_ty_1::vendor"]
        [::std::mem::offset_of!(_gncOwner__bindgen_ty_1, vendor) - 0usize];
    ["Offset of field: _gncOwner__bindgen_ty_1::employee"]
        [::std::mem::offset_of!(_gncOwner__bindgen_ty_1, employee) - 0usize];
};
impl Default for _gncOwner__bindgen_ty_1 {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of _gncOwner"][::std::mem::size_of::<_gncOwner>() - 24usize];
    ["Alignment of _gncOwner"][::std::mem::align_of::<_gncOwner>() - 8usize];
    ["Offset of field: _gncOwner::type_"][::std::mem::offset_of!(_gncOwner, type_) - 0usize];
    ["Offset of field: _gncOwner::owner"][::std::mem::offset_of!(_gncOwner, owner) - 8usize];
    ["Offset of field: _gncOwner::qof_temp"][::std::mem::offset_of!(_gncOwner, qof_temp) - 16usize];
};
impl Default for _gncOwner {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
unsafe extern "C" {
    #[doc = " \\name Setup routines\n@{"]
    pub fn gncOwnerInitUndefined(owner: *mut GncOwner, obj: gpointer);
}
unsafe extern "C" {
    pub fn gncOwnerInitCustomer(owner: *mut GncOwner, customer: *mut GncCustomer);
}
unsafe extern "C" {
    pub fn gncOwnerInitJob(owner: *mut GncOwner, job: *mut GncJob);
}
unsafe extern "C" {
    pub fn gncOwnerInitVendor(owner: *mut GncOwner, vendor: *mut GncVendor);
}
unsafe extern "C" {
    pub fn gncOwnerInitEmployee(owner: *mut GncOwner, employee: *mut GncEmployee);
}
unsafe extern "C" {
    #[doc = " @} */\n/** \\name Get routines.\n@{\n/\n/** Returns the GncOwnerType of this owner. (Not to be confused with qofOwnerGetType().)"]
    pub fn gncOwnerGetType(owner: *const GncOwner) -> GncOwnerType;
}
unsafe extern "C" {
    #[doc = " Returns TRUE if the given owner is one of the valid objects.\n Returns FALSE if the owner is (still) undefined, or if it is NULL."]
    pub fn gncOwnerIsValid(owner: *const GncOwner) -> gboolean;
}
unsafe extern "C" {
    #[doc = " If the given owner is of type GNC_OWNER_UNDEFINED, returns the undefined\n pointer, which is usually NULL. Otherwise returns NULL."]
    pub fn gncOwnerGetUndefined(owner: *const GncOwner) -> gpointer;
}
unsafe extern "C" {
    #[doc = " If the given owner is of type GNC_OWNER_CUSTOMER, returns the pointer\n to the customer object. Otherwise returns NULL."]
    pub fn gncOwnerGetCustomer(owner: *const GncOwner) -> *mut GncCustomer;
}
unsafe extern "C" {
    #[doc = " If the given owner is of type GNC_OWNER_JOB, returns the pointer\n to the job object. Otherwise returns NULL."]
    pub fn gncOwnerGetJob(owner: *const GncOwner) -> *mut GncJob;
}
unsafe extern "C" {
    #[doc = " If the given owner is of type GNC_OWNER_VENDOR, returns the pointer\n to the vendor object. Otherwise returns NULL."]
    pub fn gncOwnerGetVendor(owner: *const GncOwner) -> *mut GncVendor;
}
unsafe extern "C" {
    #[doc = " If the given owner is of type GNC_OWNER_EMPLOYEE, returns the pointer\n to the employee object. Otherwise returns NULL."]
    pub fn gncOwnerGetEmployee(owner: *const GncOwner) -> *mut GncEmployee;
}
unsafe extern "C" {
    pub fn gncOwnerGetID(owner: *const GncOwner) -> *const ::std::os::raw::c_char;
}
unsafe extern "C" {
    pub fn gncOwnerGetName(owner: *const GncOwner) -> *const ::std::os::raw::c_char;
}
unsafe extern "C" {
    pub fn gncOwnerGetAddr(owner: *const GncOwner) -> *mut GncAddress;
}
unsafe extern "C" {
    pub fn gncOwnerGetActive(owner: *const GncOwner) -> gboolean;
}
unsafe extern "C" {
    pub fn gncOwnerGetCurrency(owner: *const GncOwner) -> *mut gnc_commodity;
}
unsafe extern "C" {
    #[doc = " \\name Set routines.\n@{"]
    pub fn gncOwnerSetActive(owner: *const GncOwner, active: gboolean);
}
unsafe extern "C" {
    #[doc = " @}"]
    pub fn gncOwnerCopy(src: *const GncOwner, dest: *mut GncOwner);
}
unsafe extern "C" {
    #[doc = " \\name Comparison routines.\n@{\n/\n/** Assess equality by checking\n  - if both owner objects refer to the same owner type\n  - and if the owner reference points to the same\n    {vendor/customer/employee} in memory"]
    pub fn gncOwnerEqual(a: *const GncOwner, b: *const GncOwner) -> gboolean;
}
unsafe extern "C" {
    #[doc = " Same as gncOwnerEqual, but returns 0 if\nequal to be used as a GList custom compare function"]
    pub fn gncOwnerGCompareFunc(a: *const GncOwner, b: *const GncOwner) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    #[doc = " Sort on name"]
    pub fn gncOwnerCompare(a: *const GncOwner, b: *const GncOwner) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    #[doc = " Get the GncGUID of the immediate owner"]
    pub fn gncOwnerGetGUID(owner: *const GncOwner) -> *const GncGUID;
}
unsafe extern "C" {
    pub fn gncOwnerRetGUID(owner: *mut GncOwner) -> GncGUID;
}
unsafe extern "C" {
    #[doc = " Get the \"parent\" Owner or GncGUID thereof.  The \"parent\" owner\n is the Customer or Vendor, or the Owner of a Job"]
    pub fn gncOwnerGetEndOwner(owner: *const GncOwner) -> *const GncOwner;
}
unsafe extern "C" {
    pub fn gncOwnerGetEndGUID(owner: *const GncOwner) -> *const GncGUID;
}
unsafe extern "C" {
    #[doc = " Attach an owner to a lot"]
    pub fn gncOwnerAttachToLot(owner: *const GncOwner, lot: *mut GNCLot);
}
unsafe extern "C" {
    #[doc = " Helper function used to filter a list of lots by owner."]
    pub fn gncOwnerLotMatchOwnerFunc(lot: *mut GNCLot, user_data: gpointer) -> gboolean;
}
unsafe extern "C" {
    #[doc = " Helper function used to sort lots by date. If the lot is\n linked to an invoice, use the invoice posted date, otherwise\n use the lot's opened date."]
    pub fn gncOwnerLotsSortFunc(lotA: *mut GNCLot, lotB: *mut GNCLot) -> gint;
}
unsafe extern "C" {
    #[doc = " Get the owner from the lot.  If an owner is found in the lot,\n fill in \"owner\" and return TRUE.  Otherwise return FALSE."]
    pub fn gncOwnerGetOwnerFromLot(lot: *mut GNCLot, owner: *mut GncOwner) -> gboolean;
}
unsafe extern "C" {
    #[doc = " Convenience function to get the owner from a transaction.\n Transactions don't really have an owner. What this function will\n do it figure out whether the transaction is part of a business\n transaction (either a posted invoice/bill/voucher/credit note or\n a payment transaction) and use the business object behind it\n to extract owner information."]
    pub fn gncOwnerGetOwnerFromTxn(txn: *mut Transaction, owner: *mut GncOwner) -> gboolean;
}
unsafe extern "C" {
    pub fn gncOwnerGetOwnerFromTypeGuid(
        book: *mut QofBook,
        owner: *mut GncOwner,
        type_: QofIdType,
        guid: *mut GncGUID,
    ) -> gboolean;
}
unsafe extern "C" {
    #[doc = " Create a lot for a payment to the owner using the other\n parameters passed in. If a transaction is set, this transaction will be\n reused if possible (meaning, if the transaction currency matches\n the owner's currency and if the transaction has (at least?) one\n split in the transfer account)."]
    pub fn gncOwnerCreatePaymentLotSecs(
        owner: *const GncOwner,
        preset_txn: *mut *mut Transaction,
        posted_acc: *mut Account,
        xfer_acc: *mut Account,
        amount: gnc_numeric,
        exch: gnc_numeric,
        date: time64,
        memo: *const ::std::os::raw::c_char,
        num: *const ::std::os::raw::c_char,
    ) -> *mut GNCLot;
}
unsafe extern "C" {
    #[doc = " Given a list of lots, try to balance as many of them as possible\n by creating balancing transactions between them. This can be used\n to automatically link invoices to payments (to \"mark\" invoices as\n paid) or to credit notes or the other way around.\n\n The function starts with the first lot in the list and tries to\n create balancing transactions to the remainder of the lots in the\n list. If it reaches the end of the list, it will find the next\n still open lot in the list and tries to balance it with all lots\n that follow it (the ones that precede it are either already closed\n or not suitable or they would have been processed in a previous\n iteration).\n\n By intelligently sorting the list of lots, you can play with the\n order of precedence in which the lots should be processed. For\n example, by sorting the oldest invoice lots first, the code will\n attempt to balance these first.\n\n Some restrictions:\n - the algorithm is lazy: it will create the smallest balancing\n   transaction(s) possible, not the largest ones. Since the process\n   is iterative, you will have balanced the maximum amount possible\n   in the end, but it may be done in several transactions instead of\n   only one big one.\n - the balancing transactions only work within one account. If a\n   balancing lot is from another account than the lot currently being\n   balanced, it will be skipped during balance evaluation. However\n   if there is a mix of lots from two different accounts, the algorithm\n   will still attempt to match all lots per account.\n - the calling function is responsible for the memory management\n   of the lots list. If it created the list, it should properly free\n   it as well."]
    pub fn gncOwnerAutoApplyPaymentsWithLots(owner: *const GncOwner, lots: *mut GList);
}
unsafe extern "C" {
    #[doc = " A convenience function to apply a payment to the owner.\n It creates a lot for a payment, optionally based on an existing\n transaction and then tries to balance it with the list of\n document/payment lots passed in. If not lots were given,\n all open lots for the owner are considered.\n\n This code is actually a convenience wrapper around gncOwnerCreatePaymentLot\n and gncOwnerAutoApplyPaymentsWithLots. See their descriptions for more\n details on what happens exactly."]
    pub fn gncOwnerApplyPaymentSecs(
        owner: *const GncOwner,
        preset_txn: *mut *mut Transaction,
        lots: *mut GList,
        posted_acc: *mut Account,
        xfer_acc: *mut Account,
        amount: gnc_numeric,
        exch: gnc_numeric,
        date: time64,
        memo: *const ::std::os::raw::c_char,
        num: *const ::std::os::raw::c_char,
        auto_pay: gboolean,
    );
}
unsafe extern "C" {
    #[doc = " Helper function to find a split in lot that best offsets target_amount\n  Obviously it should be of opposite sign.\n If there are more splits of opposite sign the following\n criteria are used in order of preference:\n 1. exact match in abs amount is preferred over larger abs amount\n 2. larger abs amount is preferred over smaller abs amount\n 3. if previous and new candidate are in the same amount category,\n    prefer real payment splits over lot link splits\n 4. if previous and new candidate are of same split type\n    prefer biggest abs amount."]
    pub fn gncOwnerFindOffsettingSplit(lot: *mut GNCLot, target_amount: gnc_numeric) -> *mut Split;
}
unsafe extern "C" {
    #[doc = " Helper function to reduce the amount of a split to target_amount. To make\n  sure the split's parent transaction remains balanced a second split\n  will be created with the remainder. Similarly if the split was part of a\n  (business) lot, the remainder split will be added to the same lot to\n  keep the lot's balance unchanged."]
    pub fn gncOwnerReduceSplitTo(split: *mut Split, target_amount: gnc_numeric) -> gboolean;
}
unsafe extern "C" {
    #[doc = " To help a user understand what a lot link transaction does,\n  we set the memo to name all documents involved in the link.\n  The function below calculates this memo and sets it for\n  all splits in the lot link transaction."]
    pub fn gncOwnerSetLotLinkMemo(ll_txn: *mut Transaction);
}
unsafe extern "C" {
    #[doc = " Returns a GList of account-types based on the owner type"]
    pub fn gncOwnerGetAccountTypesList(owner: *const GncOwner) -> *mut GList;
}
unsafe extern "C" {
    #[doc = " Returns a GList of currencies associated with the owner"]
    pub fn gncOwnerGetCommoditiesList(owner: *const GncOwner) -> *mut GList;
}
unsafe extern "C" {
    #[doc = " Given an owner, extract the open balance from the owner and then\n  convert it to the desired currency."]
    pub fn gncOwnerGetBalanceInCurrency(
        owner: *const GncOwner,
        report_currency: *const gnc_commodity,
    ) -> gnc_numeric;
}
unsafe extern "C" {
    #[doc = " These two functions are mainly for the convenience of scheme code.\n Normal C code has no need to ever use these two functions, and rather\n can just use a GncOwner directly and just pass around a pointer to it."]
    pub fn gncOwnerNew() -> *mut GncOwner;
}
unsafe extern "C" {
    pub fn gncOwnerFree(owner: *mut GncOwner);
}
unsafe extern "C" {
    #[doc = " These are convenience wrappers around gnc{Vendor,Customer,Job,Employee}*\n functions. This allows you to begin edit, destroy commit edit an owner\n without knowing its type."]
    pub fn gncOwnerBeginEdit(owner: *mut GncOwner);
}
unsafe extern "C" {
    pub fn gncOwnerCommitEdit(owner: *mut GncOwner);
}
unsafe extern "C" {
    pub fn gncOwnerDestroy(owner: *mut GncOwner);
}
unsafe extern "C" {
    pub fn gnc_taxtable_get_type() -> GType;
}
unsafe extern "C" {
    #[doc = " @name Create/Destroy Functions\n@{"]
    pub fn gncTaxTableCreate(book: *mut QofBook) -> *mut GncTaxTable;
}
unsafe extern "C" {
    pub fn gncTaxTableDestroy(table: *mut GncTaxTable);
}
unsafe extern "C" {
    pub fn gncTaxTableEntryCreate() -> *mut GncTaxTableEntry;
}
unsafe extern "C" {
    pub fn gncTaxTableEntryDestroy(entry: *mut GncTaxTableEntry);
}
unsafe extern "C" {
    #[doc = " @} */\n/** \\name Set Functions\n@{"]
    pub fn gncTaxTableSetName(table: *mut GncTaxTable, name: *const ::std::os::raw::c_char);
}
unsafe extern "C" {
    pub fn gncTaxTableIncRef(table: *mut GncTaxTable);
}
unsafe extern "C" {
    pub fn gncTaxTableDecRef(table: *mut GncTaxTable);
}
unsafe extern "C" {
    pub fn gncTaxTableEntrySetAccount(entry: *mut GncTaxTableEntry, account: *mut Account);
}
unsafe extern "C" {
    pub fn gncTaxTableEntrySetType(entry: *mut GncTaxTableEntry, type_: GncAmountType);
}
unsafe extern "C" {
    pub fn gncTaxTableEntrySetAmount(entry: *mut GncTaxTableEntry, amount: gnc_numeric);
}
unsafe extern "C" {
    #[doc = " @}"]
    pub fn gncTaxTableAddEntry(table: *mut GncTaxTable, entry: *mut GncTaxTableEntry);
}
unsafe extern "C" {
    pub fn gncTaxTableRemoveEntry(table: *mut GncTaxTable, entry: *mut GncTaxTableEntry);
}
unsafe extern "C" {
    pub fn gncTaxTableChanged(table: *mut GncTaxTable);
}
unsafe extern "C" {
    pub fn gncTaxTableBeginEdit(table: *mut GncTaxTable);
}
unsafe extern "C" {
    pub fn gncTaxTableCommitEdit(table: *mut GncTaxTable);
}
unsafe extern "C" {
    pub fn gncTaxTableEqual(a: *const GncTaxTable, b: *const GncTaxTable) -> gboolean;
}
unsafe extern "C" {
    pub fn gncTaxTableLookupByName(
        book: *mut QofBook,
        name: *const ::std::os::raw::c_char,
    ) -> *mut GncTaxTable;
}
unsafe extern "C" {
    pub fn gncTaxTableGetDefault(book: *mut QofBook, type_: GncOwnerType) -> *mut GncTaxTable;
}
pub type GncTaxTableList = GList;
unsafe extern "C" {
    pub fn gncTaxTableGetTables(book: *mut QofBook) -> *mut GncTaxTableList;
}
unsafe extern "C" {
    pub fn gncTaxTableGetName(table: *const GncTaxTable) -> *const ::std::os::raw::c_char;
}
unsafe extern "C" {
    pub fn gncTaxTableGetParent(table: *const GncTaxTable) -> *mut GncTaxTable;
}
unsafe extern "C" {
    pub fn gncTaxTableReturnChild(table: *mut GncTaxTable, make_new: gboolean) -> *mut GncTaxTable;
}
pub type GncTaxTableEntryList = GList;
unsafe extern "C" {
    pub fn gncTaxTableGetEntries(table: *const GncTaxTable) -> *mut GncTaxTableEntryList;
}
unsafe extern "C" {
    pub fn gncTaxTableGetRefcount(table: *const GncTaxTable) -> gint64;
}
unsafe extern "C" {
    pub fn gncTaxTableLastModifiedSecs(table: *const GncTaxTable) -> time64;
}
unsafe extern "C" {
    pub fn gncTaxTableEntryGetAccount(entry: *const GncTaxTableEntry) -> *mut Account;
}
unsafe extern "C" {
    pub fn gncTaxTableEntryGetType(entry: *const GncTaxTableEntry) -> GncAmountType;
}
unsafe extern "C" {
    pub fn gncTaxTableEntryGetAmount(entry: *const GncTaxTableEntry) -> gnc_numeric;
}
unsafe extern "C" {
    #[doc = " @}"]
    pub fn gncTaxTableCompare(
        a: *const GncTaxTable,
        b: *const GncTaxTable,
    ) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn gncTaxTableEntryCompare(
        a: *const GncTaxTableEntry,
        b: *const GncTaxTableEntry,
    ) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn gncTaxTableEntryEqual(
        a: *const GncTaxTableEntry,
        b: *const GncTaxTableEntry,
    ) -> gboolean;
}
unsafe extern "C" {
    pub fn gnc_customer_get_type() -> GType;
}
unsafe extern "C" {
    #[doc = " @name Create/Destroy Functions\n@{"]
    pub fn gncCustomerCreate(book: *mut QofBook) -> *mut GncCustomer;
}
unsafe extern "C" {
    pub fn gncCustomerDestroy(customer: *mut GncCustomer);
}
unsafe extern "C" {
    pub fn gncCustomerBeginEdit(customer: *mut GncCustomer);
}
unsafe extern "C" {
    pub fn gncCustomerCommitEdit(customer: *mut GncCustomer);
}
unsafe extern "C" {
    #[doc = " @name Set Functions\n@{"]
    pub fn gncCustomerSetID(customer: *mut GncCustomer, id: *const ::std::os::raw::c_char);
}
unsafe extern "C" {
    pub fn gncCustomerSetName(customer: *mut GncCustomer, name: *const ::std::os::raw::c_char);
}
unsafe extern "C" {
    pub fn gncCustomerSetNotes(customer: *mut GncCustomer, notes: *const ::std::os::raw::c_char);
}
unsafe extern "C" {
    pub fn gncCustomerSetTerms(customer: *mut GncCustomer, term: *mut GncBillTerm);
}
unsafe extern "C" {
    pub fn gncCustomerSetTaxIncluded(customer: *mut GncCustomer, taxincl: GncTaxIncluded);
}
unsafe extern "C" {
    pub fn gncCustomerSetActive(customer: *mut GncCustomer, active: gboolean);
}
unsafe extern "C" {
    pub fn gncCustomerSetDiscount(customer: *mut GncCustomer, discount: gnc_numeric);
}
unsafe extern "C" {
    pub fn gncCustomerSetCredit(customer: *mut GncCustomer, credit: gnc_numeric);
}
unsafe extern "C" {
    pub fn gncCustomerSetCurrency(customer: *mut GncCustomer, currency: *mut gnc_commodity);
}
unsafe extern "C" {
    pub fn gncCustomerSetTaxTableOverride(customer: *mut GncCustomer, override_: gboolean);
}
unsafe extern "C" {
    pub fn gncCustomerSetTaxTable(customer: *mut GncCustomer, table: *mut GncTaxTable);
}
unsafe extern "C" {
    pub fn gncCustomerAddJob(customer: *mut GncCustomer, job: *mut GncJob);
}
unsafe extern "C" {
    pub fn gncCustomerRemoveJob(customer: *mut GncCustomer, job: *mut GncJob);
}
unsafe extern "C" {
    pub fn gncCustomerGetID(customer: *const GncCustomer) -> *const ::std::os::raw::c_char;
}
unsafe extern "C" {
    pub fn gncCustomerGetName(customer: *const GncCustomer) -> *const ::std::os::raw::c_char;
}
unsafe extern "C" {
    pub fn gncCustomerGetAddr(customer: *const GncCustomer) -> *mut GncAddress;
}
unsafe extern "C" {
    pub fn gncCustomerGetShipAddr(customer: *const GncCustomer) -> *mut GncAddress;
}
unsafe extern "C" {
    pub fn gncCustomerGetNotes(customer: *const GncCustomer) -> *const ::std::os::raw::c_char;
}
unsafe extern "C" {
    pub fn gncCustomerGetTerms(customer: *const GncCustomer) -> *mut GncBillTerm;
}
unsafe extern "C" {
    pub fn gncCustomerGetTaxIncluded(customer: *const GncCustomer) -> GncTaxIncluded;
}
unsafe extern "C" {
    pub fn gncCustomerGetActive(customer: *const GncCustomer) -> gboolean;
}
unsafe extern "C" {
    pub fn gncCustomerGetDiscount(customer: *const GncCustomer) -> gnc_numeric;
}
unsafe extern "C" {
    pub fn gncCustomerGetCredit(customer: *const GncCustomer) -> gnc_numeric;
}
unsafe extern "C" {
    pub fn gncCustomerGetCurrency(customer: *const GncCustomer) -> *mut gnc_commodity;
}
unsafe extern "C" {
    pub fn gncCustomerGetTaxTableOverride(customer: *const GncCustomer) -> gboolean;
}
unsafe extern "C" {
    pub fn gncCustomerGetTaxTable(customer: *const GncCustomer) -> *mut GncTaxTable;
}
unsafe extern "C" {
    #[doc = " @}"]
    pub fn gncCustomerCompare(
        a: *const GncCustomer,
        b: *const GncCustomer,
    ) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    #[doc = " Test support function, used in gets-dbi-business-stuff.c"]
    pub fn gncCustomerEqual(a: *const GncCustomer, b: *const GncCustomer) -> gboolean;
}
unsafe extern "C" {
    pub fn gncCustomerGetJoblist(customer: *const GncCustomer, show_all: gboolean) -> *mut GList;
}
unsafe extern "C" {
    pub fn gncCustomerIsDirty(customer: *mut GncCustomer) -> gboolean;
}
